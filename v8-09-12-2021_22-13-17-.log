v8-version,9,4,146,19,-node.13,0
v8-platform,macos,macos
shared-library,/usr/local/bin/node,0x10e956000,0x10fd047c3,244662272
shared-library,/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation,0x7fff20462f50,0x7fff2061ef37,897024
shared-library,/usr/lib/libSystem.B.dylib,0x7fff2a5c3511,0x7fff2a5c3a1e,897024
shared-library,/usr/lib/libc++.1.dylib,0x7fff2034ba70,0x7fff20393200,897024
shared-library,/usr/lib/libobjc.A.dylib,0x7fff20282b80,0x7fff202a8d4f,897024
shared-library,/usr/lib/liboah.dylib,0x7fff2a590350,0x7fff2a595d2a,897024
shared-library,/usr/lib/libfakelink.dylib,0x7fff2a5c4dc0,0x7fff2a5c7bc8,897024
shared-library,/usr/lib/libicucore.A.dylib,0x7fff225d11d0,0x7fff227c344a,897024
shared-library,/System/Library/PrivateFrameworks/SoftLinking.framework/Versions/A/SoftLinking,0x7fff2a5c8ef8,0x7fff2a5c8f4e,897024
shared-library,/usr/lib/libc++abi.dylib,0x7fff2039e460,0x7fff203afcc4,897024
shared-library,/usr/lib/system/libcache.dylib,0x7fff2a5bd85c,0x7fff2a5c03ac,897024
shared-library,/usr/lib/system/libcommonCrypto.dylib,0x7fff2a578a00,0x7fff2a58282c,897024
shared-library,/usr/lib/system/libcompiler_rt.dylib,0x7fff2a5a2f28,0x7fff2a5a7a25,897024
shared-library,/usr/lib/system/libcopyfile.dylib,0x7fff2a598780,0x7fff2a5a0040,897024
shared-library,/usr/lib/system/libcorecrypto.dylib,0x7fff20172780,0x7fff201edcad,897024
shared-library,/usr/lib/system/libdispatch.dylib,0x7fff2023dde0,0x7fff202711a4,897024
shared-library,/usr/lib/system/libdyld.dylib,0x7fff203f0330,0x7fff204216a0,897024
shared-library,/usr/lib/system/libkeymgr.dylib,0x7fff2a5b3a61,0x7fff2a5b3e90,897024
shared-library,/usr/lib/system/liblaunch.dylib,0x7fff2d9cbfc0,0x7fff2d9cbfc0,897024
shared-library,/usr/lib/system/libmacho.dylib,0x7fff2a55745c,0x7fff2a55b95c,897024
shared-library,/usr/lib/system/libquarantine.dylib,0x7fff29d4f019,0x7fff29d50bd0,897024
shared-library,/usr/lib/system/libremovefile.dylib,0x7fff2a5b1770,0x7fff2a5b2bdb,897024
shared-library,/usr/lib/system/libsystem_asl.dylib,0x7fff24c54df8,0x7fff24c6907d,897024
shared-library,/usr/lib/system/libsystem_blocks.dylib,0x7fff2012227c,0x7fff201227e8,897024
shared-library,/usr/lib/system/libsystem_c.dylib,0x7fff202bfab0,0x7fff2033eb59,897024
shared-library,/usr/lib/system/libsystem_collections.dylib,0x7fff2a5aaa95,0x7fff2a5acb80,897024
shared-library,/usr/lib/system/libsystem_configuration.dylib,0x7fff29054e5c,0x7fff290576c0,897024
shared-library,/usr/lib/system/libsystem_containermanager.dylib,0x7fff28340ce0,0x7fff2834d0de,897024
shared-library,/usr/lib/system/libsystem_coreservices.dylib,0x7fff2a2fa440,0x7fff2a2fd2d0,897024
shared-library,/usr/lib/system/libsystem_darwin.dylib,0x7fff22831210,0x7fff228370d3,897024
shared-library,/usr/lib/system/libsystem_dnssd.dylib,0x7fff2a5b4df4,0x7fff2a5ba0bc,897024
shared-library,/usr/lib/system/libsystem_featureflags.dylib,0x7fff202bc500,0x7fff202bdc60,897024
shared-library,/usr/lib/system/libsystem_info.dylib,0x7fff20436530,0x7fff2045c130,897024
shared-library,/usr/lib/system/libsystem_m.dylib,0x7fff2a50e240,0x7fff2a53a38f,897024
shared-library,/usr/lib/system/libsystem_malloc.dylib,0x7fff202103b0,0x7fff20232e30,897024
shared-library,/usr/lib/system/libsystem_networkextension.dylib,0x7fff24be82ba,0x7fff24bf325e,897024
shared-library,/usr/lib/system/libsystem_notify.dylib,0x7fff22c4ffbc,0x7fff22c59b9d,897024
shared-library,/usr/lib/system/libsystem_product_info_filter.dylib,0x7fff2fe63000,0x7fff2fe63000,897024
shared-library,/usr/lib/system/libsystem_sandbox.dylib,0x7fff29058b0c,0x7fff2905c26c,897024
shared-library,/usr/lib/system/libsystem_secinit.dylib,0x7fff2a5adcad,0x7fff2a5af25e,897024
shared-library,/usr/lib/system/libsystem_kernel.dylib,0x7fff203b3fc0,0x7fff203d8797,897024
shared-library,/usr/lib/system/libsystem_platform.dylib,0x7fff2042bea0,0x7fff20432686,897024
shared-library,/usr/lib/system/libsystem_pthread.dylib,0x7fff203e4540,0x7fff203eca1e,897024
shared-library,/usr/lib/system/libsystem_symptoms.dylib,0x7fff26331edb,0x7fff263373ee,897024
shared-library,/usr/lib/system/libsystem_trace.dylib,0x7fff2015acf0,0x7fff2016dab3,897024
shared-library,/usr/lib/system/libunwind.dylib,0x7fff2a5894e0,0x7fff2a58e3da,897024
shared-library,/usr/lib/system/libxpc.dylib,0x7fff20124e30,0x7fff2014ab2e,897024
shared-library-end
tick,0x7fff203b42f6,1250,0,0x0,6
profiler,begin,1000
tick,0x10f608c00,2288,0,0x0,6
tick,0x11b589408,3714,0,0x0,6
tick,0x10f6b7ea3,4474,0,0x0,6
new,CodeRange,0x11b68f000,0
tick,0x10eda11a0,5739,0,0x0,6
tick,0x10edd0610,6839,0,0x0,6
tick,0x10ed098f0,8330,0,0x0,6
new,MemoryChunk,0x1eea39e40000,262144
tick,0x10f0dea70,9221,0,0x0,6
tick,0x10ebc9db0,10663,0,0x0,6
new,MemoryChunk,0x1eea86fc0000,262144
new,MemoryChunk,0x1eeaf2980000,262144
new,MemoryChunk,0x1eea9c500000,262144
new,MemoryChunk,0x1eeacbd80000,262144
heap-capacity,1031072
heap-available,4346136384
tick,0x10ed19df0,11500,0,0x0,6
new,MemoryChunk,0x1eeab58c0000,262144
new,MemoryChunk,0x1eea5b640000,262144
new,MemoryChunk,0x1eea1f7c0000,262144
new,MemoryChunk,0x1eeac2040000,262144
new,MemoryChunk,0x1eea56100000,262144
tick,0x10f0dea65,12627,0,0x0,6
new,MemoryChunk,0x1eeaaa640000,262144
new,MemoryChunk,0x1eea35d00000,262144
new,MemoryChunk,0x11b6c0000,262144
tick,0x10f0e8e7f,14059,0,0x0,6
new,MemoryChunk,0x1eea54280000,262144
tick,0x10ed09b54,14873,0,0x0,6
tick,0x10ec24ab0,16147,0,0x0,6
code-creation,Builtin,2,16435,0x10f3dea60,1340,RecordWriteEmitRememberedSetSaveFP
code-creation,Builtin,2,16482,0x10f3defa0,452,RecordWriteOmitRememberedSetSaveFP
code-creation,Builtin,2,16492,0x10f3df180,620,RecordWriteEmitRememberedSetIgnoreFP
code-creation,Builtin,2,16500,0x10f3df400,208,RecordWriteOmitRememberedSetIgnoreFP
code-creation,Builtin,2,16508,0x10f3df4e0,352,EphemeronKeyBarrierSaveFP
code-creation,Builtin,2,16516,0x10f3df660,116,EphemeronKeyBarrierIgnoreFP
code-creation,Builtin,2,16523,0x10f3df6e0,60,AdaptorWithBuiltinExitFrame
code-creation,Builtin,2,16531,0x10f3df720,360,CallFunction_ReceiverIsNullOrUndefined
code-creation,Builtin,2,16540,0x10f3df8a0,416,CallFunction_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,16548,0x10f3dfa60,444,CallFunction_ReceiverIsAny
code-creation,Builtin,2,16555,0x10f3dfc20,104,CallBoundFunction
code-creation,Builtin,2,16562,0x10f3dfca0,120,Call_ReceiverIsNullOrUndefined
code-creation,Builtin,2,16569,0x10f3dfd20,120,Call_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,16578,0x10f3dfda0,120,Call_ReceiverIsAny
code-creation,Builtin,2,16584,0x10f3dfe20,988,Call_ReceiverIsNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,16593,0x10f3e0200,984,Call_ReceiverIsNullOrUndefined_Baseline
code-creation,Builtin,2,16601,0x10f3e05e0,1072,Call_ReceiverIsNotNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,16610,0x10f3e0a20,1072,Call_ReceiverIsNotNullOrUndefined_Baseline
code-creation,Builtin,2,16620,0x10f3e0e60,1072,Call_ReceiverIsAny_Baseline_Compact
code-creation,Builtin,2,16628,0x10f3e12a0,1072,Call_ReceiverIsAny_Baseline
code-creation,Builtin,2,16636,0x10f3e16e0,944,Call_ReceiverIsNullOrUndefined_WithFeedback
code-creation,Builtin,2,16644,0x10f3e1aa0,944,Call_ReceiverIsNotNullOrUndefined_WithFeedback
code-creation,Builtin,2,16653,0x10f3e1e60,944,Call_ReceiverIsAny_WithFeedback
code-creation,Builtin,2,16660,0x10f3e2220,736,CallProxy
code-creation,Builtin,2,16667,0x10f3e2520,148,CallVarargs
code-creation,Builtin,2,16673,0x10f3e25c0,940,CallWithSpread
code-creation,Builtin,2,16680,0x10f3e2980,1948,CallWithSpread_Baseline
code-creation,Builtin,2,16687,0x10f3e3120,1920,CallWithSpread_WithFeedback
code-creation,Builtin,2,16695,0x10f3e38c0,864,CallWithArrayLike
code-creation,Builtin,2,16701,0x10f3e3c40,1812,CallWithArrayLike_WithFeedback
code-creation,Builtin,2,16709,0x10f3e4360,156,CallForwardVarargs
code-creation,Builtin,2,16715,0x10f3e4400,156,CallFunctionForwardVarargs
code-creation,Builtin,2,16723,0x10f3e44a0,132,CallFunctionTemplate_CheckAccess
code-creation,Builtin,2,16730,0x10f3e4540,228,CallFunctionTemplate_CheckCompatibleReceiver
code-creation,Builtin,2,16738,0x10f3e4640,316,CallFunctionTemplate_CheckAccessAndCompatibleReceiver
code-creation,Builtin,2,16747,0x10f3e4780,28,ConstructFunction
code-creation,Builtin,2,16754,0x10f3e47a0,104,ConstructBoundFunction
code-creation,Builtin,2,16776,0x10f3e4820,28,ConstructedNonConstructable
code-creation,Builtin,2,16784,0x10f3e4840,100,Construct
code-creation,Builtin,2,16790,0x10f3e48c0,148,ConstructVarargs
code-creation,Builtin,2,16797,0x10f3e4960,964,ConstructWithSpread
code-creation,Builtin,2,16804,0x10f3e4d40,1740,ConstructWithSpread_Baseline
code-creation,Builtin,2,16812,0x10f3e5420,1756,ConstructWithSpread_WithFeedback
code-creation,Builtin,2,16819,0x10f3e5b00,920,ConstructWithArrayLike
code-creation,Builtin,2,16826,0x10f3e5ea0,1644,ConstructWithArrayLike_WithFeedback
code-creation,Builtin,2,16834,0x10f3e6520,196,ConstructForwardVarargs
code-creation,Builtin,2,16841,0x10f3e6600,196,ConstructFunctionForwardVarargs
code-creation,Builtin,2,16849,0x10f3e66e0,792,Construct_Baseline
code-creation,Builtin,2,16855,0x10f3e6a00,812,Construct_WithFeedback
code-creation,Builtin,2,16863,0x10f3e6d40,476,JSConstructStubGeneric
code-creation,Builtin,2,16870,0x10f3e6f20,376,JSBuiltinsConstructStub
code-creation,Builtin,2,16877,0x10f3e70a0,676,FastNewObject
code-creation,Builtin,2,16884,0x10f3e7360,292,FastNewClosure
code-creation,Builtin,2,16891,0x10f3e74a0,720,ConstructProxy
code-creation,Builtin,2,16897,0x10f3e7780,192,JSEntry
code-creation,Builtin,2,16903,0x10f3e7860,192,JSConstructEntry
code-creation,Builtin,2,16910,0x10f3e7940,192,JSRunMicrotasksEntry
code-creation,Builtin,2,16917,0x10f3e7a20,96,JSEntryTrampoline
code-creation,Builtin,2,16924,0x10f3e7aa0,96,JSConstructEntryTrampoline
code-creation,Builtin,2,16931,0x10f3e7b20,280,ResumeGeneratorTrampoline
code-creation,Builtin,2,16939,0x10f3e7c40,1116,StringCodePointAt
code-creation,Builtin,2,16946,0x10f3e80a0,1548,StringFromCodePointAt
code-creation,Builtin,2,16953,0x10f3e86c0,544,StringEqual
code-creation,Builtin,2,16959,0x10f3e8900,276,StringGreaterThan
code-creation,Builtin,2,16967,0x10f3e8a20,276,StringGreaterThanOrEqual
code-creation,Builtin,2,16974,0x10f3e8b40,276,StringLessThan
code-creation,Builtin,2,16981,0x10f3e8c60,276,StringLessThanOrEqual
code-creation,Builtin,2,16988,0x10f3e8d80,2492,StringSubstring
code-creation,Builtin,2,16994,0x10f3e9740,80,OrderedHashTableHealIndex
code-creation,Builtin,2,17002,0x10f3e97a0,1168,InterpreterEntryTrampoline
code-creation,Builtin,2,17010,0x10f3e9c40,76,InterpreterPushArgsThenCall
code-creation,Builtin,2,17018,0x10f3e9ca0,84,InterpreterPushUndefinedAndArgsThenCall
code-creation,Builtin,2,17026,0x10f3e9d00,84,InterpreterPushArgsThenCallWithFinalSpread
code-creation,Builtin,2,17034,0x10f3e9d60,80,InterpreterPushArgsThenConstruct
code-creation,Builtin,2,17042,0x10f3e9dc0,80,InterpreterPushArgsThenConstructArrayFunction
code-creation,Builtin,2,17051,0x10f3e9e20,84,InterpreterPushArgsThenConstructWithFinalSpread
code-creation,Builtin,2,17072,0x10f3e9e80,84,InterpreterEnterAtBytecode
code-creation,Builtin,2,17079,0x10f3e9ee0,220,InterpreterEnterAtNextBytecode
code-creation,Builtin,2,17086,0x10f3e9fc0,52,InterpreterOnStackReplacement
code-creation,Builtin,2,17094,0x10f3ea000,592,BaselineOutOfLinePrologue
code-creation,Builtin,2,17102,0x10f3ea260,56,BaselineOnStackReplacement
code-creation,Builtin,2,17109,0x10f3ea2a0,84,BaselineLeaveFrame
code-creation,Builtin,2,17116,0x10f3ea300,212,BaselineOrInterpreterEnterAtBytecode
code-creation,Builtin,2,17124,0x10f3ea3e0,220,BaselineOrInterpreterEnterAtNextBytecode
code-creation,Builtin,2,17132,0x10f3ea4c0,188,InterpreterOnStackReplacement_ToBaseline
code-creation,Builtin,2,17140,0x10f3ea580,1000,CompileLazy
code-creation,Builtin,2,17147,0x10f3ea980,72,CompileLazyDeoptimizedCode
code-creation,Builtin,2,17155,0x10f3ea9e0,252,InstantiateAsmJs
code-creation,Builtin,2,17161,0x10f3eaae0,32,NotifyDeoptimized
code-creation,Builtin,2,17168,0x10f3eab20,784,DeoptimizationEntry_Eager
code-creation,Builtin,2,17176,0x10f3eae40,784,DeoptimizationEntry_Soft
code-creation,Builtin,2,17183,0x10f3eb160,784,DeoptimizationEntry_Bailout
code-creation,Builtin,2,17190,0x10f3eb480,784,DeoptimizationEntry_Lazy
code-creation,Builtin,2,17197,0x10f3eb7a0,52,ContinueToCodeStubBuiltin
code-creation,Builtin,2,17205,0x10f3eb7e0,60,ContinueToCodeStubBuiltinWithResult
code-creation,Builtin,2,17223,0x10f3eb820,56,ContinueToJavaScriptBuiltin
code-creation,Builtin,2,17231,0x10f3eb860,64,ContinueToJavaScriptBuiltinWithResult
code-creation,Builtin,2,17239,0x10f3eb8c0,288,CallApiCallback
code-creation,Builtin,2,17246,0x10f3eba00,272,CallApiGetter
code-creation,Builtin,2,17253,0x10f3ebb20,12,HandleApiCall
code-creation,Builtin,2,17260,0x10f3ebb40,12,HandleApiCallAsFunction
code-creation,Builtin,2,17267,0x10f3ebb60,12,HandleApiCallAsConstructor
code-creation,Builtin,2,17274,0x10f3ebb80,64,AllocateInYoungGeneration
code-creation,Builtin,2,17282,0x10f3ebbe0,52,AllocateRegularInYoungGeneration
code-creation,Builtin,2,17289,0x10f3ebc20,64,AllocateInOldGeneration
code-creation,Builtin,2,17296,0x10f3ebc80,52,AllocateRegularInOldGeneration
code-creation,Builtin,2,17305,0x10f3ebcc0,424,CopyFastSmiOrObjectElements
code-creation,Builtin,2,17312,0x10f3ebe80,496,GrowFastDoubleElements
code-creation,Builtin,2,17319,0x10f3ec080,396,GrowFastSmiOrObjectElements
code-creation,Builtin,2,17327,0x10f3ec220,388,DebugBreakTrampoline
code-creation,Builtin,2,17334,0x10f3ec3c0,180,ToNumber
code-creation,Builtin,2,17340,0x10f3ec480,292,ToNumber_Baseline
code-creation,Builtin,2,17347,0x10f3ec5c0,360,ToNumeric_Baseline
code-creation,Builtin,2,17354,0x10f3ec740,104,PlainPrimitiveToNumber
code-creation,Builtin,2,17361,0x10f3ec7c0,212,ToNumberConvertBigInt
code-creation,Builtin,2,17368,0x10f3ec8a0,132,Typeof
code-creation,Builtin,2,17374,0x10f3ec940,104,BigIntToI64
code-creation,Builtin,2,17390,0x10f3ec9c0,4,BigIntToI32Pair
code-creation,Builtin,2,17402,0x10f3ec9e0,232,I64ToBigInt
code-creation,Builtin,2,17410,0x10f3ecae0,4,I32PairToBigInt
code-creation,Builtin,2,17419,0x10f3ecb00,100,ToBooleanLazyDeoptContinuation
code-creation,Builtin,2,17429,0x10f3ecb80,4232,KeyedLoadIC_PolymorphicName
code-creation,Builtin,2,17438,0x10f3edc20,15704,KeyedStoreIC_Megamorphic
code-creation,Builtin,2,17447,0x10f3f1980,280,LoadGlobalIC_NoFeedback
code-creation,Builtin,2,17456,0x10f3f1aa0,60,LoadIC_FunctionPrototype
code-creation,Builtin,2,17466,0x10f3f1ae0,12,LoadIC_StringLength
code-creation,Builtin,2,17475,0x10f3f1b00,16,LoadIC_StringWrapperLength
code-creation,Builtin,2,17483,0x10f3f1b20,3056,LoadIC_NoFeedback
code-creation,Builtin,2,17491,0x10f3f2720,32,StoreGlobalIC_Slow
code-creation,Builtin,2,17499,0x10f3f2760,7284,StoreIC_NoFeedback
code-creation,Builtin,2,17506,0x10f3f43e0,180,KeyedLoadIC_SloppyArguments
code-creation,Builtin,2,17513,0x10f3f44a0,72,LoadIndexedInterceptorIC
code-creation,Builtin,2,17520,0x10f3f4500,240,KeyedStoreIC_SloppyArguments_Standard
code-creation,Builtin,2,17528,0x10f3f4600,240,KeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW
code-creation,Builtin,2,17537,0x10f3f4700,240,KeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB
code-creation,Builtin,2,17545,0x10f3f4800,240,KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW
code-creation,Builtin,2,17553,0x10f3f4900,13924,StoreFastElementIC_Standard
code-creation,Builtin,2,17561,0x10f3f7f80,9660,StoreFastElementIC_GrowNoTransitionHandleCOW
code-creation,Builtin,2,17671,0x10f3fa540,13104,StoreFastElementIC_NoTransitionIgnoreOOB
code-creation,Builtin,2,17689,0x10f3fd880,6160,StoreFastElementIC_NoTransitionHandleCOW
code-creation,Builtin,2,17726,0x10f3ff0a0,8468,ElementsTransitionAndStore_Standard
code-creation,Builtin,2,17756,0x10f4011c0,19332,ElementsTransitionAndStore_GrowNoTransitionHandleCOW
tick,0x7fff203b72be,17779,0,0x0,6
code-creation,Builtin,2,17806,0x10f405d60,8468,ElementsTransitionAndStore_NoTransitionIgnoreOOB
code-creation,Builtin,2,17882,0x10f407e80,11028,ElementsTransitionAndStore_NoTransitionHandleCOW
code-creation,Builtin,2,17911,0x10f40a9a0,792,KeyedHasIC_PolymorphicName
code-creation,Builtin,2,17919,0x10f40acc0,164,KeyedHasIC_SloppyArguments
code-creation,Builtin,2,17927,0x10f40ad80,72,HasIndexedInterceptorIC
code-creation,Builtin,2,17934,0x10f40ade0,88,DynamicCheckMapsTrampoline
code-creation,Builtin,2,17941,0x10f40ae40,260,DynamicCheckMaps
code-creation,Builtin,2,17948,0x10f40af60,88,DynamicCheckMapsWithFeedbackVectorTrampoline
code-creation,Builtin,2,17969,0x10f40afc0,224,DynamicCheckMapsWithFeedbackVector
code-creation,Builtin,2,17978,0x10f40b0c0,148,EnqueueMicrotask
code-creation,Builtin,2,17984,0x10f40b160,8,RunMicrotasksTrampoline
code-creation,Builtin,2,17991,0x10f40b180,3504,RunMicrotasks
code-creation,Builtin,2,17998,0x10f40bf40,2624,HasProperty
code-creation,Builtin,2,18004,0x10f40c9a0,1144,DeleteProperty
code-creation,Builtin,2,18011,0x10f40ce20,1972,CopyDataProperties
code-creation,Builtin,2,18018,0x10f40d5e0,9156,SetDataProperties
code-creation,Builtin,2,18025,0x10f40f9c0,28,Abort
code-creation,Builtin,2,18031,0x10f40f9e0,28,AbortCSAAssert
code-creation,Builtin,2,18037,0x10f40fa00,12,EmptyFunction
code-creation,Builtin,2,18043,0x10f40fa20,12,Illegal
code-creation,Builtin,2,18049,0x10f40fa40,12,StrictPoisonPillThrower
code-creation,Builtin,2,18056,0x10f40fa60,12,UnsupportedThrower
code-creation,Builtin,2,18063,0x10f40fa80,64,ReturnReceiver
code-creation,Builtin,2,18070,0x10f40fae0,28,ArrayConstructor
code-creation,Builtin,2,18076,0x10f40fb00,404,ArrayConstructorImpl
code-creation,Builtin,2,18083,0x10f40fca0,216,ArrayNoArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,18091,0x10f40fd80,216,ArrayNoArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,18099,0x10f40fe60,176,ArrayNoArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,18109,0x10f40ff20,176,ArrayNoArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,18118,0x10f40ffe0,176,ArrayNoArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,18127,0x10f4100a0,176,ArrayNoArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,18135,0x10f410160,188,ArrayNoArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,18145,0x10f410220,188,ArrayNoArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,18154,0x10f4102e0,512,ArraySingleArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,18163,0x10f410500,480,ArraySingleArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,18171,0x10f410700,436,ArraySingleArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,18180,0x10f4108c0,404,ArraySingleArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,18189,0x10f410a60,436,ArraySingleArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,18199,0x10f410c20,404,ArraySingleArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,18207,0x10f410dc0,448,ArraySingleArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,18217,0x10f410fa0,412,ArraySingleArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,18226,0x10f411140,64,ArrayNArgumentsConstructor
code-creation,Builtin,2,18233,0x10f4111a0,12,ArrayConcat
code-creation,Builtin,2,18240,0x10f4111c0,12,ArrayPrototypeFill
code-creation,Builtin,2,18247,0x10f4111e0,932,ArrayIncludesSmiOrObject
code-creation,Builtin,2,18254,0x10f4115a0,140,ArrayIncludesPackedDoubles
code-creation,Builtin,2,18261,0x10f411640,208,ArrayIncludesHoleyDoubles
code-creation,Builtin,2,18269,0x10f411720,548,ArrayIncludes
code-creation,Builtin,2,18275,0x10f411960,856,ArrayIndexOfSmiOrObject
code-creation,Builtin,2,18283,0x10f411cc0,116,ArrayIndexOfPackedDoubles
code-creation,Builtin,2,18290,0x10f411d40,116,ArrayIndexOfHoleyDoubles
code-creation,Builtin,2,18297,0x10f411dc0,552,ArrayIndexOf
code-creation,Builtin,2,18303,0x10f412000,12,ArrayPop
code-creation,Builtin,2,18310,0x10f412020,616,ArrayPrototypePop
code-creation,Builtin,2,18316,0x10f4122a0,12,ArrayPush
code-creation,Builtin,2,18322,0x10f4122c0,2412,ArrayPrototypePush
code-creation,Builtin,2,18329,0x10f412c40,12,ArrayShift
code-creation,Builtin,2,18335,0x10f412c60,12,ArrayUnshift
code-creation,Builtin,2,18341,0x10f412c80,944,CloneFastJSArray
code-creation,Builtin,2,18348,0x10f413040,2196,CloneFastJSArrayFillingHoles
code-creation,Builtin,2,18355,0x10f4138e0,968,ExtractFastJSArray
code-creation,Builtin,2,18362,0x10f413cc0,260,ArrayPrototypeEntries
code-creation,Builtin,2,18380,0x10f413de0,248,ArrayPrototypeKeys
code-creation,Builtin,2,18387,0x10f413ee0,260,ArrayPrototypeValues
code-creation,Builtin,2,18403,0x10f414000,4424,ArrayIteratorPrototypeNext
code-creation,Builtin,2,18415,0x10f415160,4164,FlattenIntoArray
code-creation,Builtin,2,18424,0x10f4161c0,4164,FlatMapIntoArray
code-creation,Builtin,2,18433,0x10f417220,372,ArrayPrototypeFlat
code-creation,Builtin,2,18441,0x10f4173a0,428,ArrayPrototypeFlatMap
code-creation,Builtin,2,18451,0x10f417560,12,ArrayBufferConstructor
code-creation,Builtin,2,18460,0x10f417580,12,ArrayBufferConstructor_DoNotInitialize
code-creation,Builtin,2,18469,0x10f4175a0,12,ArrayBufferPrototypeSlice
code-creation,Builtin,2,18479,0x10f4175c0,12,ArrayBufferPrototypeResize
code-creation,Builtin,2,18488,0x10f4175e0,804,AsyncFunctionEnter
code-creation,Builtin,2,18497,0x10f417920,132,AsyncFunctionReject
code-creation,Builtin,2,18508,0x10f4179c0,128,AsyncFunctionResolve
code-creation,Builtin,2,18518,0x10f417a60,12,AsyncFunctionLazyDeoptContinuation
code-creation,Builtin,2,18528,0x10f417a80,2804,AsyncFunctionAwaitCaught
code-creation,Builtin,2,18537,0x10f418580,2804,AsyncFunctionAwaitUncaught
code-creation,Builtin,2,18562,0x10f419080,172,AsyncFunctionAwaitRejectClosure
code-creation,Builtin,2,18572,0x10f419140,164,AsyncFunctionAwaitResolveClosure
code-creation,Builtin,2,18582,0x10f419200,12,BigIntConstructor
code-creation,Builtin,2,18589,0x10f419220,12,BigIntAsUintN
code-creation,Builtin,2,18595,0x10f419240,12,BigIntAsIntN
code-creation,Builtin,2,18602,0x10f419260,12,BigIntPrototypeToLocaleString
code-creation,Builtin,2,18609,0x10f419280,12,BigIntPrototypeToString
code-creation,Builtin,2,18616,0x10f4192a0,12,BigIntPrototypeValueOf
code-creation,Builtin,2,18623,0x10f4192c0,12,CallSitePrototypeGetColumnNumber
code-creation,Builtin,2,18630,0x10f4192e0,12,CallSitePrototypeGetEnclosingColumnNumber
code-creation,Builtin,2,18641,0x10f419300,12,CallSitePrototypeGetEnclosingLineNumber
code-creation,Builtin,2,18652,0x10f419320,12,CallSitePrototypeGetEvalOrigin
code-creation,Builtin,2,18661,0x10f419340,12,CallSitePrototypeGetFileName
code-creation,Builtin,2,18671,0x10f419360,12,CallSitePrototypeGetFunction
code-creation,Builtin,2,18678,0x10f419380,12,CallSitePrototypeGetFunctionName
code-creation,Builtin,2,18687,0x10f4193a0,12,CallSitePrototypeGetLineNumber
code-creation,Builtin,2,18695,0x10f4193c0,12,CallSitePrototypeGetMethodName
code-creation,Builtin,2,18705,0x10f4193e0,12,CallSitePrototypeGetPosition
code-creation,Builtin,2,18714,0x10f419400,12,CallSitePrototypeGetPromiseIndex
code-creation,Builtin,2,18723,0x10f419420,12,CallSitePrototypeGetScriptNameOrSourceURL
code-creation,Builtin,2,18734,0x10f419440,12,CallSitePrototypeGetThis
code-creation,Builtin,2,18743,0x10f419460,12,CallSitePrototypeGetTypeName
code-creation,Builtin,2,18753,0x10f419480,12,CallSitePrototypeIsAsync
code-creation,Builtin,2,18762,0x10f4194a0,12,CallSitePrototypeIsConstructor
code-creation,Builtin,2,18772,0x10f4194c0,12,CallSitePrototypeIsEval
code-creation,Builtin,2,18781,0x10f4194e0,12,CallSitePrototypeIsNative
code-creation,Builtin,2,18791,0x10f419500,12,CallSitePrototypeIsPromiseAll
code-creation,Builtin,2,18801,0x10f419520,12,CallSitePrototypeIsToplevel
code-creation,Builtin,2,18810,0x10f419540,12,CallSitePrototypeToString
code-creation,Builtin,2,18820,0x10f419560,12,ConsoleDebug
code-creation,Builtin,2,18830,0x10f419580,12,ConsoleError
code-creation,Builtin,2,18838,0x10f4195a0,12,ConsoleInfo
code-creation,Builtin,2,18848,0x10f4195c0,12,ConsoleLog
code-creation,Builtin,2,18856,0x10f4195e0,12,ConsoleWarn
code-creation,Builtin,2,18866,0x10f419600,12,ConsoleDir
code-creation,Builtin,2,18874,0x10f419620,12,ConsoleDirXml
code-creation,Builtin,2,18883,0x10f419640,12,ConsoleTable
code-creation,Builtin,2,18891,0x10f419660,12,ConsoleTrace
code-creation,Builtin,2,18899,0x10f419680,12,ConsoleGroup
code-creation,Builtin,2,18907,0x10f4196a0,12,ConsoleGroupCollapsed
code-creation,Builtin,2,18916,0x10f4196c0,12,ConsoleGroupEnd
code-creation,Builtin,2,18924,0x10f4196e0,12,ConsoleClear
code-creation,Builtin,2,18943,0x10f419700,12,ConsoleCount
code-creation,Builtin,2,18952,0x10f419720,12,ConsoleCountReset
code-creation,Builtin,2,18961,0x10f419740,12,ConsoleAssert
code-creation,Builtin,2,18969,0x10f419760,12,ConsoleProfile
code-creation,Builtin,2,18978,0x10f419780,12,ConsoleProfileEnd
code-creation,Builtin,2,18987,0x10f4197a0,12,ConsoleTime
code-creation,Builtin,2,18996,0x10f4197c0,12,ConsoleTimeLog
code-creation,Builtin,2,19006,0x10f4197e0,12,ConsoleTimeEnd
code-creation,Builtin,2,19014,0x10f419800,12,ConsoleTimeStamp
code-creation,Builtin,2,19024,0x10f419820,12,ConsoleContext
code-creation,Builtin,2,19034,0x10f419840,12,DataViewConstructor
code-creation,Builtin,2,19044,0x10f419860,12,DateConstructor
code-creation,Builtin,2,19053,0x10f419880,220,DatePrototypeGetDate
code-creation,Builtin,2,19064,0x10f419960,220,DatePrototypeGetDay
code-creation,Builtin,2,19073,0x10f419a40,220,DatePrototypeGetFullYear
code-creation,Builtin,2,19083,0x10f419b20,220,DatePrototypeGetHours
code-creation,Builtin,2,19092,0x10f419c00,196,DatePrototypeGetMilliseconds
code-creation,Builtin,2,19102,0x10f419ce0,220,DatePrototypeGetMinutes
code-creation,Builtin,2,19112,0x10f419dc0,220,DatePrototypeGetMonth
code-creation,Builtin,2,19123,0x10f419ea0,220,DatePrototypeGetSeconds
code-creation,Builtin,2,19132,0x10f419f80,124,DatePrototypeGetTime
code-creation,Builtin,2,19140,0x10f41a000,196,DatePrototypeGetTimezoneOffset
code-creation,Builtin,2,19150,0x10f41a0e0,196,DatePrototypeGetUTCDate
code-creation,Builtin,2,19158,0x10f41a1c0,196,DatePrototypeGetUTCDay
code-creation,Builtin,2,19168,0x10f41a2a0,196,DatePrototypeGetUTCFullYear
code-creation,Builtin,2,19177,0x10f41a380,196,DatePrototypeGetUTCHours
code-creation,Builtin,2,19187,0x10f41a460,196,DatePrototypeGetUTCMilliseconds
code-creation,Builtin,2,19197,0x10f41a540,196,DatePrototypeGetUTCMinutes
code-creation,Builtin,2,19206,0x10f41a620,196,DatePrototypeGetUTCMonth
code-creation,Builtin,2,19215,0x10f41a700,196,DatePrototypeGetUTCSeconds
code-creation,Builtin,2,19225,0x10f41a7e0,124,DatePrototypeValueOf
code-creation,Builtin,2,19234,0x10f41a860,352,DatePrototypeToPrimitive
code-creation,Builtin,2,19243,0x10f41a9e0,12,DatePrototypeGetYear
code-creation,Builtin,2,19252,0x10f41aa00,12,DatePrototypeSetYear
code-creation,Builtin,2,19261,0x10f41aa20,12,DateNow
code-creation,Builtin,2,19269,0x10f41aa40,12,DateParse
code-creation,Builtin,2,19277,0x10f41aa60,12,DatePrototypeSetDate
code-creation,Builtin,2,19286,0x10f41aa80,12,DatePrototypeSetFullYear
code-creation,Builtin,2,19296,0x10f41aaa0,12,DatePrototypeSetHours
code-creation,Builtin,2,19305,0x10f41aac0,12,DatePrototypeSetMilliseconds
code-creation,Builtin,2,19314,0x10f41aae0,12,DatePrototypeSetMinutes
code-creation,Builtin,2,19323,0x10f41ab00,12,DatePrototypeSetMonth
code-creation,Builtin,2,19333,0x10f41ab20,12,DatePrototypeSetSeconds
code-creation,Builtin,2,19343,0x10f41ab40,12,DatePrototypeSetTime
code-creation,Builtin,2,19353,0x10f41ab60,12,DatePrototypeSetUTCDate
code-creation,Builtin,2,19362,0x10f41ab80,12,DatePrototypeSetUTCFullYear
code-creation,Builtin,2,19372,0x10f41aba0,12,DatePrototypeSetUTCHours
code-creation,Builtin,2,19381,0x10f41abc0,12,DatePrototypeSetUTCMilliseconds
code-creation,Builtin,2,19390,0x10f41abe0,12,DatePrototypeSetUTCMinutes
code-creation,Builtin,2,19399,0x10f41ac00,12,DatePrototypeSetUTCMonth
code-creation,Builtin,2,19408,0x10f41ac20,12,DatePrototypeSetUTCSeconds
code-creation,Builtin,2,19417,0x10f41ac40,12,DatePrototypeToDateString
code-creation,Builtin,2,19427,0x10f41ac60,12,DatePrototypeToISOString
code-creation,Builtin,2,19436,0x10f41ac80,12,DatePrototypeToUTCString
code-creation,Builtin,2,19446,0x10f41aca0,12,DatePrototypeToString
code-creation,Builtin,2,19455,0x10f41acc0,12,DatePrototypeToTimeString
code-creation,Builtin,2,19465,0x10f41ace0,12,DatePrototypeToJson
code-creation,Builtin,2,19474,0x10f41ad00,12,DateUTC
code-creation,Builtin,2,19484,0x10f41ad20,12,ErrorConstructor
code-creation,Builtin,2,19493,0x10f41ad40,12,ErrorCaptureStackTrace
code-creation,Builtin,2,19502,0x10f41ad60,12,ErrorPrototypeToString
code-creation,Builtin,2,19521,0x10f41ad80,12,FunctionConstructor
code-creation,Builtin,2,19530,0x10f41ada0,68,FunctionPrototypeApply
code-creation,Builtin,2,19540,0x10f41ae00,12,FunctionPrototypeBind
code-creation,Builtin,2,19549,0x10f41ae20,32,FunctionPrototypeCall
code-creation,Builtin,2,19559,0x10f41ae60,12,FunctionPrototypeToString
code-creation,Builtin,2,19572,0x10f41ae80,192,CreateIterResultObject
code-creation,Builtin,2,19585,0x10f41af60,788,CreateGeneratorObject
code-creation,Builtin,2,19598,0x10f41b280,12,GeneratorFunctionConstructor
code-creation,Builtin,2,19612,0x10f41b2a0,412,GeneratorPrototypeNext
code-creation,Builtin,2,19625,0x10f41b440,420,GeneratorPrototypeReturn
code-creation,Builtin,2,19638,0x10f41b600,424,GeneratorPrototypeThrow
code-creation,Builtin,2,19659,0x10f41b7c0,12,AsyncFunctionConstructor
code-creation,Builtin,2,19673,0x10f41b7e0,368,SuspendGeneratorBaseline
code-creation,Builtin,2,19686,0x10f41b960,88,ResumeGeneratorBaseline
code-creation,Builtin,2,19696,0x10f41b9c0,36,GetIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,19707,0x10f41ba00,12,GlobalDecodeURI
code-creation,Builtin,2,19715,0x10f41ba20,12,GlobalDecodeURIComponent
code-creation,Builtin,2,19725,0x10f41ba40,12,GlobalEncodeURI
code-creation,Builtin,2,19735,0x10f41ba60,12,GlobalEncodeURIComponent
code-creation,Builtin,2,19744,0x10f41ba80,12,GlobalEscape
code-creation,Builtin,2,19753,0x10f41baa0,12,GlobalUnescape
code-creation,Builtin,2,19762,0x10f41bac0,12,GlobalEval
code-creation,Builtin,2,19770,0x10f41bae0,132,GlobalIsFinite
code-creation,Builtin,2,19779,0x10f41bb80,124,GlobalIsNaN
code-creation,Builtin,2,19787,0x10f41bc00,12,JsonParse
code-creation,Builtin,2,19795,0x10f41bc20,12,JsonStringify
code-creation,Builtin,2,19804,0x10f41bc40,4608,LoadIC
code-creation,Builtin,2,19812,0x10f41ce60,4296,LoadIC_Megamorphic
code-creation,Builtin,2,19821,0x10f41df40,4520,LoadIC_Noninlined
code-creation,Builtin,2,19830,0x10f41f100,44,LoadICTrampoline
code-creation,Builtin,2,19839,0x10f41f140,24,LoadICBaseline
code-creation,Builtin,2,19847,0x10f41f160,44,LoadICTrampoline_Megamorphic
code-creation,Builtin,2,19857,0x10f41f1a0,7380,LoadSuperIC
code-creation,Builtin,2,19865,0x10f420e80,24,LoadSuperICBaseline
code-creation,Builtin,2,19874,0x10f420ea0,8132,KeyedLoadIC
code-creation,Builtin,2,19882,0x10f422e80,13076,KeyedLoadIC_Megamorphic
code-creation,Builtin,2,19891,0x10f4261a0,44,KeyedLoadICTrampoline
code-creation,Builtin,2,19900,0x10f4261e0,24,KeyedLoadICBaseline
code-creation,Builtin,2,19909,0x10f426200,44,KeyedLoadICTrampoline_Megamorphic
code-creation,Builtin,2,19918,0x10f426240,5064,StoreGlobalIC
code-creation,Builtin,2,19927,0x10f427620,44,StoreGlobalICTrampoline
code-creation,Builtin,2,19936,0x10f427660,24,StoreGlobalICBaseline
code-creation,Builtin,2,19945,0x10f427680,5304,StoreIC
code-creation,Builtin,2,19953,0x10f428b40,44,StoreICTrampoline
code-creation,Builtin,2,19962,0x10f428b80,24,StoreICBaseline
code-creation,Builtin,2,19971,0x10f428ba0,5740,KeyedStoreIC
code-creation,Builtin,2,19981,0x10f42a220,44,KeyedStoreICTrampoline
code-creation,Builtin,2,19990,0x10f42a260,24,KeyedStoreICBaseline
code-creation,Builtin,2,19999,0x10f42a280,404,StoreInArrayLiteralIC
code-creation,Builtin,2,20009,0x10f42a420,24,StoreInArrayLiteralICBaseline
code-creation,Builtin,2,20020,0x10f42a440,140,LookupContextBaseline
code-creation,Builtin,2,20030,0x10f42a4e0,140,LookupContextInsideTypeofBaseline
code-creation,Builtin,2,20041,0x10f42a580,3244,LoadGlobalIC
code-creation,Builtin,2,20051,0x10f42b240,3224,LoadGlobalICInsideTypeof
code-creation,Builtin,2,20060,0x10f42bee0,44,LoadGlobalICTrampoline
code-creation,Builtin,2,20070,0x10f42bf20,24,LoadGlobalICBaseline
code-creation,Builtin,2,20080,0x10f42bf40,44,LoadGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,20091,0x10f42bf80,24,LoadGlobalICInsideTypeofBaseline
code-creation,Builtin,2,20101,0x10f42bfa0,140,LookupGlobalICBaseline
code-creation,Builtin,2,20110,0x10f42c040,140,LookupGlobalICInsideTypeofBaseline
code-creation,Builtin,2,20119,0x10f42c0e0,2056,CloneObjectIC
code-creation,Builtin,2,20136,0x10f42c900,24,CloneObjectICBaseline
code-creation,Builtin,2,20146,0x10f42c920,1988,CloneObjectIC_Slow
code-creation,Builtin,2,20155,0x10f42d100,2764,KeyedHasIC
code-creation,Builtin,2,20164,0x10f42dbe0,24,KeyedHasICBaseline
code-creation,Builtin,2,20173,0x10f42dc00,2620,KeyedHasIC_Megamorphic
code-creation,Builtin,2,20183,0x10f42e640,1428,IterableToList
code-creation,Builtin,2,20192,0x10f42ebe0,1228,IterableToFixedArray
code-creation,Builtin,2,20201,0x10f42f0c0,748,IterableToListWithSymbolLookup
code-creation,Builtin,2,20211,0x10f42f3c0,56,IterableToFixedArrayWithSymbolLookupSlow
code-creation,Builtin,2,20222,0x10f42f400,124,IterableToListMayPreserveHoles
code-creation,Builtin,2,20231,0x10f42f480,976,IterableToFixedArrayForWasm
code-creation,Builtin,2,20240,0x10f42f860,1616,StringListFromIterable
code-creation,Builtin,2,20249,0x10f42fec0,1220,FindOrderedHashMapEntry
code-creation,Builtin,2,20258,0x10f4303a0,4156,MapConstructor
code-creation,Builtin,2,20267,0x10f4313e0,1960,MapPrototypeSet
code-creation,Builtin,2,20275,0x10f431ba0,1524,MapPrototypeDelete
code-creation,Builtin,2,20284,0x10f4321a0,204,MapPrototypeGet
code-creation,Builtin,2,20292,0x10f432280,164,MapPrototypeHas
code-creation,Builtin,2,20301,0x10f432340,12,MapPrototypeClear
code-creation,Builtin,2,20310,0x10f432360,284,MapPrototypeEntries
code-creation,Builtin,2,20320,0x10f432480,144,MapPrototypeGetSize
code-creation,Builtin,2,20329,0x10f432520,492,MapPrototypeForEach
code-creation,Builtin,2,20353,0x10f432720,284,MapPrototypeKeys
code-creation,Builtin,2,20363,0x10f432840,284,MapPrototypeValues
code-creation,Builtin,2,20372,0x10f432960,1048,MapIteratorPrototypeNext
code-creation,Builtin,2,20383,0x10f432d80,1176,MapIteratorToList
code-creation,Builtin,2,20394,0x10f433220,12,NumberPrototypeToExponential
code-creation,Builtin,2,20405,0x10f433240,12,NumberPrototypeToFixed
code-creation,Builtin,2,20416,0x10f433260,12,NumberPrototypeToLocaleString
code-creation,Builtin,2,20427,0x10f433280,12,NumberPrototypeToPrecision
code-creation,Builtin,2,20436,0x10f4332a0,328,SameValue
code-creation,Builtin,2,20445,0x10f433400,204,SameValueNumbersOnly
code-creation,Builtin,2,20455,0x10f4334e0,792,Add_Baseline
code-creation,Builtin,2,20463,0x10f433800,828,Subtract_Baseline
code-creation,Builtin,2,20472,0x10f433b40,808,Multiply_Baseline
code-creation,Builtin,2,20480,0x10f433e80,832,Divide_Baseline
code-creation,Builtin,2,20490,0x10f4341e0,764,Modulus_Baseline
code-creation,Builtin,2,20499,0x10f4344e0,804,Exponentiate_Baseline
code-creation,Builtin,2,20508,0x10f434820,708,BitwiseAnd_Baseline
code-creation,Builtin,2,20516,0x10f434b00,700,BitwiseOr_Baseline
code-creation,Builtin,2,20525,0x10f434dc0,708,BitwiseXor_Baseline
code-creation,Builtin,2,20533,0x10f4350a0,720,ShiftLeft_Baseline
code-creation,Builtin,2,20542,0x10f435380,720,ShiftRight_Baseline
code-creation,Builtin,2,20550,0x10f435660,836,ShiftRightLogical_Baseline
code-creation,Builtin,2,20559,0x10f4359c0,720,Add_WithFeedback
code-creation,Builtin,2,20568,0x10f435ca0,780,Subtract_WithFeedback
code-creation,Builtin,2,20578,0x10f435fc0,776,Multiply_WithFeedback
code-creation,Builtin,2,20588,0x10f4362e0,804,Divide_WithFeedback
code-creation,Builtin,2,20598,0x10f436620,724,Modulus_WithFeedback
code-creation,Builtin,2,20607,0x10f436900,760,Exponentiate_WithFeedback
code-creation,Builtin,2,20618,0x10f436c00,684,BitwiseAnd_WithFeedback
code-creation,Builtin,2,20628,0x10f436ec0,676,BitwiseOr_WithFeedback
code-creation,Builtin,2,20637,0x10f437180,684,BitwiseXor_WithFeedback
code-creation,Builtin,2,20646,0x10f437440,692,ShiftLeft_WithFeedback
code-creation,Builtin,2,20656,0x10f437700,692,ShiftRight_WithFeedback
tick,0x7fff203b72be,20674,0,0x0,6
tick,0x7fff203e5287,20693,0,0x0,6
tick,0x7fff203b65fe,20704,0,0x0,6
code-creation,Builtin,2,20718,0x10f4379c0,808,ShiftRightLogical_WithFeedback
code-creation,Builtin,2,20729,0x10f437d00,1696,Equal_Baseline
code-creation,Builtin,2,20736,0x10f4383c0,908,StrictEqual_Baseline
code-creation,Builtin,2,20743,0x10f438760,1264,LessThan_Baseline
code-creation,Builtin,2,20751,0x10f438c60,1264,GreaterThan_Baseline
code-creation,Builtin,2,20770,0x10f439160,1264,LessThanOrEqual_Baseline
code-creation,Builtin,2,20778,0x10f439660,1264,GreaterThanOrEqual_Baseline
code-creation,Builtin,2,20786,0x10f439b60,1624,Equal_WithFeedback
code-creation,Builtin,2,20793,0x10f43a1c0,940,StrictEqual_WithFeedback
code-creation,Builtin,2,20801,0x10f43a580,1240,LessThan_WithFeedback
code-creation,Builtin,2,20807,0x10f43aa60,1240,GreaterThan_WithFeedback
code-creation,Builtin,2,20814,0x10f43af40,1240,LessThanOrEqual_WithFeedback
code-creation,Builtin,2,20822,0x10f43b420,1240,GreaterThanOrEqual_WithFeedback
code-creation,Builtin,2,20830,0x10f43b900,332,BitwiseNot_Baseline
code-creation,Builtin,2,20837,0x10f43ba60,460,Decrement_Baseline
code-creation,Builtin,2,20844,0x10f43bc40,464,Increment_Baseline
code-creation,Builtin,2,20852,0x10f43be20,488,Negate_Baseline
code-creation,Builtin,2,20858,0x10f43c020,316,BitwiseNot_WithFeedback
code-creation,Builtin,2,20865,0x10f43c160,440,Decrement_WithFeedback
code-creation,Builtin,2,20872,0x10f43c320,444,Increment_WithFeedback
code-creation,Builtin,2,20879,0x10f43c4e0,472,Negate_WithFeedback
code-creation,Builtin,2,20886,0x10f43c6c0,252,ObjectAssign
code-creation,Builtin,2,20893,0x10f43c7c0,864,ObjectCreate
code-creation,Builtin,2,20899,0x10f43cb40,12,ObjectDefineGetter
code-creation,Builtin,2,20906,0x10f43cb60,12,ObjectDefineProperties
code-creation,Builtin,2,20913,0x10f43cb80,12,ObjectDefineProperty
code-creation,Builtin,2,20920,0x10f43cba0,12,ObjectDefineSetter
code-creation,Builtin,2,20927,0x10f43cbc0,1512,ObjectEntries
code-creation,Builtin,2,20933,0x10f43d1c0,12,ObjectFreeze
code-creation,Builtin,2,20940,0x10f43d1e0,5592,ObjectGetOwnPropertyDescriptor
code-creation,Builtin,2,20948,0x10f43e7c0,12,ObjectGetOwnPropertyDescriptors
code-creation,Builtin,2,20955,0x10f43e7e0,600,ObjectGetOwnPropertyNames
code-creation,Builtin,2,20963,0x10f43ea40,12,ObjectGetOwnPropertySymbols
code-creation,Builtin,2,20970,0x10f43ea60,164,ObjectHasOwn
code-creation,Builtin,2,20977,0x10f43eb20,388,ObjectIs
code-creation,Builtin,2,20983,0x10f43ecc0,12,ObjectIsFrozen
code-creation,Builtin,2,20990,0x10f43ece0,12,ObjectIsSealed
code-creation,Builtin,2,20996,0x10f43ed00,536,ObjectKeys
code-creation,Builtin,2,21003,0x10f43ef20,12,ObjectLookupGetter
code-creation,Builtin,2,21009,0x10f43ef40,12,ObjectLookupSetter
code-creation,Builtin,2,21016,0x10f43ef60,2264,ObjectPrototypeHasOwnProperty
code-creation,Builtin,2,21023,0x10f43f840,216,ObjectPrototypeIsPrototypeOf
code-creation,Builtin,2,21031,0x10f43f920,12,ObjectPrototypePropertyIsEnumerable
code-creation,Builtin,2,21039,0x10f43f940,12,ObjectPrototypeGetProto
code-creation,Builtin,2,21046,0x10f43f960,12,ObjectPrototypeSetProto
code-creation,Builtin,2,21053,0x10f43f980,12,ObjectSeal
code-creation,Builtin,2,21059,0x10f43f9a0,1108,ObjectToString
code-creation,Builtin,2,21066,0x10f43fe00,1280,ObjectValues
code-creation,Builtin,2,21073,0x10f440320,280,OrdinaryHasInstance
code-creation,Builtin,2,21080,0x10f440440,344,InstanceOf
code-creation,Builtin,2,21086,0x10f4405a0,628,InstanceOf_WithFeedback
code-creation,Builtin,2,21093,0x10f440820,648,InstanceOf_Baseline
code-creation,Builtin,2,21100,0x10f440ac0,268,ForInEnumerate
code-creation,Builtin,2,21107,0x10f440be0,148,ForInPrepare
code-creation,Builtin,2,21113,0x10f440c80,2576,ForInFilter
code-creation,Builtin,2,21120,0x10f4416a0,52,ReflectApply
code-creation,Builtin,2,21126,0x10f4416e0,60,ReflectConstruct
code-creation,Builtin,2,21133,0x10f441720,12,ReflectDefineProperty
code-creation,Builtin,2,21139,0x10f441740,12,ReflectGetOwnPropertyDescriptor
code-creation,Builtin,2,21147,0x10f441760,12,ReflectOwnKeys
code-creation,Builtin,2,21154,0x10f441780,12,ReflectSet
code-creation,Builtin,2,21160,0x10f4417a0,12,RegExpCapture1Getter
code-creation,Builtin,2,21168,0x10f4417c0,12,RegExpCapture2Getter
code-creation,Builtin,2,21176,0x10f4417e0,12,RegExpCapture3Getter
code-creation,Builtin,2,21183,0x10f441800,12,RegExpCapture4Getter
code-creation,Builtin,2,21190,0x10f441820,12,RegExpCapture5Getter
code-creation,Builtin,2,21197,0x10f441840,12,RegExpCapture6Getter
code-creation,Builtin,2,21212,0x10f441860,12,RegExpCapture7Getter
code-creation,Builtin,2,21220,0x10f441880,12,RegExpCapture8Getter
code-creation,Builtin,2,21227,0x10f4418a0,12,RegExpCapture9Getter
code-creation,Builtin,2,21234,0x10f4418c0,2212,RegExpConstructor
code-creation,Builtin,2,21241,0x10f442180,12,RegExpInputGetter
code-creation,Builtin,2,21247,0x10f4421a0,12,RegExpInputSetter
code-creation,Builtin,2,21254,0x10f4421c0,12,RegExpLastMatchGetter
code-creation,Builtin,2,21261,0x10f4421e0,12,RegExpLastParenGetter
code-creation,Builtin,2,21268,0x10f442200,12,RegExpLeftContextGetter
code-creation,Builtin,2,21275,0x10f442220,908,RegExpPrototypeCompile
code-creation,Builtin,2,21282,0x10f4425c0,12,RegExpPrototypeToString
code-creation,Builtin,2,21289,0x10f4425e0,12,RegExpRightContextGetter
code-creation,Builtin,2,21296,0x10f442600,248,RegExpExecAtom
code-creation,Builtin,2,21303,0x10f442700,1024,RegExpExecInternal
code-creation,Builtin,2,21309,0x10f442b20,8,RegExpInterpreterTrampoline
code-creation,Builtin,2,21316,0x10f442b40,8,RegExpExperimentalTrampoline
code-creation,Builtin,2,21324,0x10f442b60,2676,SetConstructor
code-creation,Builtin,2,21331,0x10f4435e0,1276,SetPrototypeHas
code-creation,Builtin,2,21337,0x10f443ae0,1708,SetPrototypeAdd
code-creation,Builtin,2,21344,0x10f4441a0,1476,SetPrototypeDelete
code-creation,Builtin,2,21351,0x10f444780,12,SetPrototypeClear
code-creation,Builtin,2,21358,0x10f4447a0,284,SetPrototypeEntries
code-creation,Builtin,2,21365,0x10f4448c0,144,SetPrototypeGetSize
code-creation,Builtin,2,21372,0x10f444960,444,SetPrototypeForEach
code-creation,Builtin,2,21379,0x10f444b20,284,SetPrototypeValues
code-creation,Builtin,2,21385,0x10f444c40,984,SetIteratorPrototypeNext
code-creation,Builtin,2,21392,0x10f445020,1104,SetOrSetIteratorToList
code-creation,Builtin,2,21399,0x10f445480,12,SharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,21408,0x10f4454a0,12,SharedArrayBufferPrototypeSlice
code-creation,Builtin,2,21415,0x10f4454c0,12,SharedArrayBufferPrototypeGrow
code-creation,Builtin,2,21423,0x10f4454e0,1280,AtomicsLoad
code-creation,Builtin,2,21429,0x10f445a00,1008,AtomicsStore
code-creation,Builtin,2,21436,0x10f445e00,1704,AtomicsExchange
code-creation,Builtin,2,21443,0x10f4464c0,2092,AtomicsCompareExchange
code-creation,Builtin,2,21450,0x10f446d00,1804,AtomicsAdd
code-creation,Builtin,2,21458,0x10f447420,1804,AtomicsSub
code-creation,Builtin,2,21464,0x10f447b40,1804,AtomicsAnd
code-creation,Builtin,2,21470,0x10f448260,1804,AtomicsOr
code-creation,Builtin,2,21476,0x10f448980,1804,AtomicsXor
code-creation,Builtin,2,21483,0x10f4490a0,12,AtomicsNotify
code-creation,Builtin,2,21490,0x10f4490c0,12,AtomicsIsLockFree
code-creation,Builtin,2,21496,0x10f4490e0,12,AtomicsWait
code-creation,Builtin,2,21502,0x10f449100,12,AtomicsWaitAsync
code-creation,Builtin,2,21509,0x10f449120,12,StringFromCodePoint
code-creation,Builtin,2,21515,0x10f449140,1428,StringFromCharCode
code-creation,Builtin,2,21522,0x10f4496e0,12,StringPrototypeLastIndexOf
code-creation,Builtin,2,21529,0x10f449700,4360,StringPrototypeMatchAll
code-creation,Builtin,2,21536,0x10f44a820,12,StringPrototypeLocaleCompare
code-creation,Builtin,2,21543,0x10f44a840,1228,StringPrototypeReplace
code-creation,Builtin,2,21550,0x10f44ad20,2896,StringPrototypeSplit
code-creation,Builtin,2,21557,0x10f44b880,12,StringRaw
code-creation,Builtin,2,21563,0x10f44b8a0,12,SymbolConstructor
code-creation,Builtin,2,21569,0x10f44b8c0,12,SymbolFor
code-creation,Builtin,2,21576,0x10f44b8e0,12,SymbolKeyFor
code-creation,Builtin,2,21582,0x10f44b900,88,TypedArrayBaseConstructor
code-creation,Builtin,2,21589,0x10f44b960,256,TypedArrayConstructor
code-creation,Builtin,2,21595,0x10f44ba80,12,TypedArrayPrototypeBuffer
code-creation,Builtin,2,21603,0x10f44baa0,884,TypedArrayPrototypeByteLength
code-creation,Builtin,2,21611,0x10f44be20,368,TypedArrayPrototypeByteOffset
code-creation,Builtin,2,21618,0x10f44bfa0,588,TypedArrayPrototypeLength
code-creation,Builtin,2,21625,0x10f44c200,12,TypedArrayPrototypeCopyWithin
code-creation,Builtin,2,21633,0x10f44c220,12,TypedArrayPrototypeFill
code-creation,Builtin,2,21648,0x10f44c240,12,TypedArrayPrototypeIncludes
code-creation,Builtin,2,21656,0x10f44c260,12,TypedArrayPrototypeIndexOf
code-creation,Builtin,2,21663,0x10f44c280,12,TypedArrayPrototypeLastIndexOf
code-creation,Builtin,2,21670,0x10f44c2a0,12,TypedArrayPrototypeReverse
code-creation,Builtin,2,21678,0x10f44c2c0,316,TypedArrayPrototypeToStringTag
code-creation,Builtin,2,21685,0x10f44c400,10648,TypedArrayPrototypeMap
code-creation,Builtin,2,21692,0x10f44eda0,792,GenericJSToWasmWrapper
code-creation,Builtin,2,21699,0x10f44f0c0,148,WasmCompileLazy
code-creation,Builtin,2,21706,0x10f44f160,168,WasmDebugBreak
code-creation,Builtin,2,21712,0x10f44f220,16,WasmOnStackReplace
code-creation,Builtin,2,21719,0x10f44f240,140,WasmFloat32ToNumber
code-creation,Builtin,2,21725,0x10f44f2e0,152,WasmFloat64ToNumber
code-creation,Builtin,2,21732,0x10f44f380,4,WasmI32AtomicWait32
code-creation,Builtin,2,21739,0x10f44f3a0,4,WasmI64AtomicWait32
code-creation,Builtin,2,21746,0x10f44f3c0,24,JSToWasmLazyDeoptContinuation
code-creation,Builtin,2,21753,0x10f44f3e0,4316,WeakMapConstructor
code-creation,Builtin,2,21760,0x10f4504c0,196,WeakMapLookupHashIndex
code-creation,Builtin,2,21767,0x10f4505a0,220,WeakMapGet
code-creation,Builtin,2,21773,0x10f450680,176,WeakMapPrototypeHas
code-creation,Builtin,2,21779,0x10f450740,204,WeakMapPrototypeSet
code-creation,Builtin,2,21786,0x10f450820,144,WeakMapPrototypeDelete
code-creation,Builtin,2,21793,0x10f4508c0,2876,WeakSetConstructor
code-creation,Builtin,2,21800,0x10f451400,176,WeakSetPrototypeHas
code-creation,Builtin,2,21807,0x10f4514c0,204,WeakSetPrototypeAdd
code-creation,Builtin,2,21813,0x10f4515a0,144,WeakSetPrototypeDelete
code-creation,Builtin,2,21820,0x10f451640,372,WeakCollectionDelete
code-creation,Builtin,2,21827,0x10f4517c0,768,WeakCollectionSet
code-creation,Builtin,2,21833,0x10f451ae0,296,AsyncGeneratorResolve
code-creation,Builtin,2,21840,0x10f451c20,100,AsyncGeneratorReject
code-creation,Builtin,2,21847,0x10f451ca0,2760,AsyncGeneratorYield
code-creation,Builtin,2,21854,0x10f452780,2872,AsyncGeneratorReturn
code-creation,Builtin,2,21861,0x10f4532c0,292,AsyncGeneratorResumeNext
code-creation,Builtin,2,21867,0x10f453400,12,AsyncGeneratorFunctionConstructor
code-creation,Builtin,2,21875,0x10f453420,1016,AsyncGeneratorPrototypeNext
code-creation,Builtin,2,21897,0x10f453820,1024,AsyncGeneratorPrototypeReturn
code-creation,Builtin,2,21904,0x10f453c40,1024,AsyncGeneratorPrototypeThrow
code-creation,Builtin,2,21912,0x10f454060,2736,AsyncGeneratorAwaitCaught
code-creation,Builtin,2,21919,0x10f454b20,2736,AsyncGeneratorAwaitUncaught
code-creation,Builtin,2,21926,0x10f4555e0,116,AsyncGeneratorAwaitResolveClosure
code-creation,Builtin,2,21947,0x10f455660,128,AsyncGeneratorAwaitRejectClosure
code-creation,Builtin,2,21957,0x10f455700,116,AsyncGeneratorYieldResolveClosure
code-creation,Builtin,2,21966,0x10f455780,116,AsyncGeneratorReturnClosedResolveClosure
code-creation,Builtin,2,21976,0x10f455800,112,AsyncGeneratorReturnClosedRejectClosure
code-creation,Builtin,2,21986,0x10f455880,128,AsyncGeneratorReturnResolveClosure
code-creation,Builtin,2,21995,0x10f455920,1592,AsyncFromSyncIteratorPrototypeNext
code-creation,Builtin,2,22005,0x10f455f60,1696,AsyncFromSyncIteratorPrototypeThrow
code-creation,Builtin,2,22014,0x10f456620,1716,AsyncFromSyncIteratorPrototypeReturn
code-creation,Builtin,2,22024,0x10f456ce0,100,AsyncIteratorValueUnwrap
code-creation,Builtin,2,22033,0x10f456d60,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,22043,0x10f456e40,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,22054,0x10f456f20,204,CEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,22065,0x10f457000,396,CEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,22076,0x10f4571a0,396,CEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,22087,0x10f457340,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,22107,0x10f457420,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,22119,0x10f457500,204,CEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,22130,0x10f4575e0,396,CEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,22141,0x10f457780,396,CEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,22151,0x10f457920,4,DirectCEntry
code-creation,Builtin,2,22159,0x10f457940,1096,StringAdd_CheckNone
code-creation,Builtin,2,22168,0x10f457da0,2480,SubString
code-creation,Builtin,2,22176,0x10f458760,16,StackCheck
code-creation,Builtin,2,22185,0x10f458780,84,DoubleToI
code-creation,Builtin,2,22193,0x10f4587e0,2236,GetProperty
code-creation,Builtin,2,22202,0x10f4590a0,2308,GetPropertyWithReceiver
code-creation,Builtin,2,22212,0x10f4599c0,15844,SetProperty
code-creation,Builtin,2,22220,0x10f45d7c0,13404,SetPropertyInLiteral
code-creation,Builtin,2,22229,0x10f460c20,8,MemCopyUint8Uint8
code-creation,Builtin,2,22238,0x10f460c40,8,MemMove
code-creation,Builtin,2,22246,0x10f460c60,12,IsTraceCategoryEnabled
code-creation,Builtin,2,22255,0x10f460c80,12,Trace
code-creation,Builtin,2,22263,0x10f460ca0,12,FinalizationRegistryUnregister
code-creation,Builtin,2,22272,0x10f460cc0,416,AsyncModuleEvaluate
code-creation,Builtin,2,22281,0x10f460e80,12,CallAsyncModuleFulfilled
code-creation,Builtin,2,22291,0x10f460ea0,12,CallAsyncModuleRejected
code-creation,Builtin,2,22300,0x10f460ec0,260,AggregateErrorConstructor
code-creation,Builtin,2,22309,0x10f460fe0,856,ArrayPrototypeAt
code-creation,Builtin,2,22317,0x10f461340,656,ArrayPrototypeConcat
code-creation,Builtin,2,22326,0x10f4615e0,5820,ArrayPrototypeCopyWithin
code-creation,Builtin,2,22336,0x10f462ca0,212,ArrayEveryLoopEagerDeoptContinuation
code-creation,Builtin,2,22345,0x10f462d80,612,ArrayEveryLoopLazyDeoptContinuation
code-creation,Builtin,2,22355,0x10f463000,3256,ArrayEveryLoopContinuation
code-creation,Builtin,2,22364,0x10f463cc0,1464,ArrayEvery
code-creation,Builtin,2,22372,0x10f464280,284,ArrayFilterLoopEagerDeoptContinuation
code-creation,Builtin,2,22382,0x10f4643a0,988,ArrayFilterLoopLazyDeoptContinuation
code-creation,Builtin,2,22392,0x10f464780,3560,ArrayFilterLoopContinuation
code-creation,Builtin,2,22401,0x10f465580,4248,ArrayFilter
code-creation,Builtin,2,22410,0x10f466620,204,ArrayFindLoopEagerDeoptContinuation
code-creation,Builtin,2,22419,0x10f466700,32,ArrayFindLoopLazyDeoptContinuation
code-creation,Builtin,2,22429,0x10f466740,312,ArrayFindLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,22440,0x10f466880,528,ArrayFindLoopContinuation
code-creation,Builtin,2,22449,0x10f466aa0,1460,ArrayPrototypeFind
code-creation,Builtin,2,22458,0x10f467060,204,ArrayFindIndexLoopEagerDeoptContinuation
code-creation,Builtin,2,22468,0x10f467140,32,ArrayFindIndexLoopLazyDeoptContinuation
code-creation,Builtin,2,22478,0x10f467180,312,ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,22489,0x10f4672c0,524,ArrayFindIndexLoopContinuation
code-creation,Builtin,2,22498,0x10f4674e0,1460,ArrayPrototypeFindIndex
code-creation,Builtin,2,22507,0x10f467aa0,448,ArrayFindLastLoopContinuation
code-creation,Builtin,2,22516,0x10f467c80,1700,ArrayPrototypeFindLast
code-creation,Builtin,2,22525,0x10f468340,448,ArrayFindLastIndexLoopContinuation
code-creation,Builtin,2,22535,0x10f468520,1700,ArrayPrototypeFindLastIndex
code-creation,Builtin,2,22544,0x10f468be0,212,ArrayForEachLoopEagerDeoptContinuation
code-creation,Builtin,2,22554,0x10f468cc0,212,ArrayForEachLoopLazyDeoptContinuation
code-creation,Builtin,2,22561,0x10f468da0,3144,ArrayForEachLoopContinuation
code-creation,Builtin,2,22571,0x10f469a00,1328,ArrayForEach
code-creation,Builtin,2,22579,0x10f469f40,3572,ArrayFrom
code-creation,Builtin,2,22587,0x10f46ad40,148,ArrayIsArray
code-creation,Builtin,2,22596,0x10f46ade0,408,LoadJoinElement_DictionaryElements_0
code-creation,Builtin,2,22605,0x10f46af80,36,LoadJoinElement_FastSmiOrObjectElements_0
code-creation,Builtin,2,22615,0x10f46afc0,140,LoadJoinElement_FastDoubleElements_0
code-creation,Builtin,2,22634,0x10f46b060,312,ConvertToLocaleString
code-creation,Builtin,2,22643,0x10f46b1a0,748,JoinStackPush
code-creation,Builtin,2,22652,0x10f46b4a0,268,JoinStackPop
code-creation,Builtin,2,22660,0x10f46b5c0,6620,ArrayPrototypeJoin
code-creation,Builtin,2,22669,0x10f46cfa0,5360,ArrayPrototypeToLocaleString
code-creation,Builtin,2,22678,0x10f46e4a0,236,ArrayPrototypeToString
code-creation,Builtin,2,22687,0x10f46e5a0,5924,TypedArrayPrototypeJoin
code-creation,Builtin,2,22696,0x10f46fce0,4640,TypedArrayPrototypeToLocaleString
code-creation,Builtin,2,22705,0x10f470f20,3824,ArrayPrototypeLastIndexOf
code-creation,Builtin,2,22714,0x10f471e20,260,ArrayMapPreLoopLazyDeoptContinuation
code-creation,Builtin,2,22738,0x10f471f40,252,ArrayMapLoopEagerDeoptContinuation
code-creation,Builtin,2,22748,0x10f472040,532,ArrayMapLoopLazyDeoptContinuation
code-creation,Builtin,2,22758,0x10f472260,3188,ArrayMapLoopContinuation
code-creation,Builtin,2,22767,0x10f472ee0,3904,ArrayMap
code-creation,Builtin,2,22775,0x10f473e40,1000,ArrayOf
code-creation,Builtin,2,22783,0x10f474240,444,ArrayReduceRightPreLoopEagerDeoptContinuation
code-creation,Builtin,2,22794,0x10f474400,204,ArrayReduceRightLoopEagerDeoptContinuation
code-creation,Builtin,2,22804,0x10f4744e0,204,ArrayReduceRightLoopLazyDeoptContinuation
code-creation,Builtin,2,22813,0x10f4745c0,3204,ArrayReduceRightLoopContinuation
code-creation,Builtin,2,22823,0x10f475260,2000,ArrayReduceRight
code-creation,Builtin,2,22831,0x10f475a40,176,ArrayReducePreLoopEagerDeoptContinuation
code-creation,Builtin,2,22841,0x10f475b00,204,ArrayReduceLoopEagerDeoptContinuation
code-creation,Builtin,2,22850,0x10f475be0,204,ArrayReduceLoopLazyDeoptContinuation
code-creation,Builtin,2,22860,0x10f475cc0,3216,ArrayReduceLoopContinuation
code-creation,Builtin,2,22869,0x10f476960,1604,ArrayReduce
code-creation,Builtin,2,22877,0x10f476fc0,3208,ArrayPrototypeReverse
code-creation,Builtin,2,22886,0x10f477c60,3604,ArrayPrototypeShift
code-creation,Builtin,2,22895,0x10f478a80,5172,ArrayPrototypeSlice
code-creation,Builtin,2,22903,0x10f479ec0,212,ArraySomeLoopEagerDeoptContinuation
code-creation,Builtin,2,22913,0x10f479fa0,580,ArraySomeLoopLazyDeoptContinuation
code-creation,Builtin,2,22923,0x10f47a200,3244,ArraySomeLoopContinuation
code-creation,Builtin,2,22932,0x10f47aec0,1448,ArraySome
code-creation,Builtin,2,22940,0x10f47b480,14208,ArrayPrototypeSplice
code-creation,Builtin,2,22949,0x10f47ec20,3268,ArrayPrototypeUnshift
code-creation,Builtin,2,22958,0x10f47f900,332,ArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,22967,0x10f47fa60,348,ArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,22977,0x10f47fbc0,208,ArrayBufferPrototypeGetResizable
code-creation,Builtin,2,22986,0x10f47fca0,332,SharedArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,22996,0x10f47fe00,208,SharedArrayBufferPrototypeGetGrowable
code-creation,Builtin,2,23006,0x10f47fee0,96,ArrayBufferIsView
code-creation,Builtin,2,23015,0x10f47ff60,396,ToInteger
code-creation,Builtin,2,23023,0x10f480100,3068,FastCreateDataProperty
code-creation,Builtin,2,23032,0x10f480d00,676,CheckNumberInRange
code-creation,Builtin,2,23040,0x10f480fc0,584,CheckSameObject
code-creation,Builtin,2,23049,0x10f481220,904,BooleanConstructor
code-creation,Builtin,2,23058,0x10f4815c0,164,BooleanPrototypeToString
code-creation,Builtin,2,23067,0x10f481680,156,BooleanPrototypeValueOf
code-creation,Builtin,2,23075,0x10f481720,1180,BigIntAddNoThrow
code-creation,Builtin,2,23084,0x10f481bc0,1276,BigIntAdd
code-creation,Builtin,2,23092,0x10f4820c0,1180,BigIntSubtractNoThrow
code-creation,Builtin,2,23102,0x10f482560,1276,BigIntSubtract
code-creation,Builtin,2,23110,0x10f482a60,284,BigIntUnaryMinus
code-creation,Builtin,2,23119,0x10f482b80,1356,ToString
code-creation,Builtin,2,23127,0x10f4830e0,156,StringPrototypeToString
code-creation,Builtin,2,23136,0x10f483180,156,StringPrototypeValueOf
code-creation,Builtin,2,23146,0x10f483220,2452,StringToList
code-creation,Builtin,2,23154,0x10f483bc0,1012,StringPrototypeCharAt
code-creation,Builtin,2,23162,0x10f483fc0,700,StringPrototypeCharCodeAt
code-creation,Builtin,2,23180,0x10f484280,1288,StringPrototypeCodePointAt
code-creation,Builtin,2,23190,0x10f4847a0,400,StringPrototypeConcat
code-creation,Builtin,2,23204,0x10f484940,992,StringConstructor
code-creation,Builtin,2,23211,0x10f484d40,1432,StringAddConvertLeft
code-creation,Builtin,2,23286,0x10f4852e0,1460,StringAddConvertRight
code-creation,Builtin,2,23295,0x10f4858a0,812,StringCharAt
code-creation,Builtin,2,23302,0x10f485be0,16,FastNewClosureBaseline
code-creation,Builtin,2,23309,0x10f485c00,196,FastNewFunctionContextEval
code-creation,Builtin,2,23316,0x10f485ce0,196,FastNewFunctionContextFunction
code-creation,Builtin,2,23324,0x10f485dc0,248,CreateRegExpLiteral
code-creation,Builtin,2,23334,0x10f485ec0,1080,CreateShallowArrayLiteral
code-creation,Builtin,2,23342,0x10f486300,496,CreateEmptyArrayLiteral
code-creation,Builtin,2,23349,0x10f486500,1724,CreateShallowObjectLiteral
code-creation,Builtin,2,23356,0x10f486bc0,384,ObjectConstructor
code-creation,Builtin,2,23363,0x10f486d60,176,CreateEmptyLiteralObject
code-creation,Builtin,2,23385,0x10f486e20,532,NumberConstructor
code-creation,Builtin,2,23392,0x10f487040,64,GenericLazyDeoptContinuation
code-creation,Builtin,2,23400,0x10f4870a0,64,StringToNumber
code-creation,Builtin,2,23406,0x10f487100,184,NonNumberToNumber
code-creation,Builtin,2,23413,0x10f4871c0,240,NonNumberToNumeric
code-creation,Builtin,2,23419,0x10f4872c0,36,ToNumeric
code-creation,Builtin,2,23426,0x10f487300,1180,NumberToString
code-creation,Builtin,2,23433,0x10f4877a0,92,ToBoolean
code-creation,Builtin,2,23439,0x10f487800,96,ToBooleanForBaselineJump
code-creation,Builtin,2,23446,0x10f487880,728,ToLength
code-creation,Builtin,2,23452,0x10f487b60,1308,ToName
code-creation,Builtin,2,23458,0x10f488080,756,ToObject
code-creation,Builtin,2,23464,0x10f488380,208,NonPrimitiveToPrimitive_Default
code-creation,Builtin,2,23472,0x10f488460,208,NonPrimitiveToPrimitive_Number
code-creation,Builtin,2,23479,0x10f488540,208,NonPrimitiveToPrimitive_String
code-creation,Builtin,2,23487,0x10f488620,288,OrdinaryToPrimitive_Number
code-creation,Builtin,2,23494,0x10f488760,288,OrdinaryToPrimitive_String
code-creation,Builtin,2,23501,0x10f4888a0,216,FastConsoleAssert
code-creation,Builtin,2,23507,0x10f488980,160,DataViewPrototypeGetBuffer
code-creation,Builtin,2,23514,0x10f488a40,336,DataViewPrototypeGetByteLength
code-creation,Builtin,2,23522,0x10f488ba0,336,DataViewPrototypeGetByteOffset
code-creation,Builtin,2,23529,0x10f488d00,572,DataViewPrototypeGetUint8
code-creation,Builtin,2,23536,0x10f488f40,572,DataViewPrototypeGetInt8
code-creation,Builtin,2,23543,0x10f489180,644,DataViewPrototypeGetUint16
code-creation,Builtin,2,23550,0x10f489420,644,DataViewPrototypeGetInt16
code-creation,Builtin,2,23557,0x10f4896c0,808,DataViewPrototypeGetUint32
code-creation,Builtin,2,23565,0x10f489a00,684,DataViewPrototypeGetInt32
code-creation,Builtin,2,23572,0x10f489cc0,848,DataViewPrototypeGetFloat32
code-creation,Builtin,2,23579,0x10f48a020,912,DataViewPrototypeGetFloat64
code-creation,Builtin,2,23586,0x10f48a3c0,984,DataViewPrototypeGetBigUint64
code-creation,Builtin,2,23593,0x10f48a7a0,1004,DataViewPrototypeGetBigInt64
code-creation,Builtin,2,23601,0x10f48aba0,928,DataViewPrototypeSetUint8
code-creation,Builtin,2,23608,0x10f48af60,928,DataViewPrototypeSetInt8
code-creation,Builtin,2,23615,0x10f48b320,1028,DataViewPrototypeSetUint16
code-creation,Builtin,2,23622,0x10f48b740,1028,DataViewPrototypeSetInt16
code-creation,Builtin,2,23629,0x10f48bb60,1064,DataViewPrototypeSetUint32
code-creation,Builtin,2,23636,0x10f48bfa0,1064,DataViewPrototypeSetInt32
code-creation,Builtin,2,23645,0x10f48c3e0,1032,DataViewPrototypeSetFloat32
code-creation,Builtin,2,23652,0x10f48c800,1096,DataViewPrototypeSetFloat64
code-creation,Builtin,2,23659,0x10f48cc60,944,DataViewPrototypeSetBigUint64
code-creation,Builtin,2,23667,0x10f48d020,944,DataViewPrototypeSetBigInt64
code-creation,Builtin,2,23674,0x10f48d3e0,828,FinalizationRegistryConstructor
code-creation,Builtin,2,23681,0x10f48d720,1136,FinalizationRegistryRegister
code-creation,Builtin,2,23704,0x10f48dba0,644,FinalizationRegistryPrototypeCleanupSome
code-creation,Builtin,2,23713,0x10f48de40,328,FunctionPrototypeHasInstance
code-creation,Builtin,2,23720,0x10f48dfa0,924,FastFunctionPrototypeBind
code-creation,Builtin,2,23728,0x10f48e340,88,IncBlockCounter
code-creation,Builtin,2,23734,0x10f48e3a0,236,GetTemplateObject
code-creation,Builtin,2,23741,0x10f48e4a0,28,BytecodeBudgetInterruptFromCode
code-creation,Builtin,2,23748,0x10f48e4c0,92,ForInNext
code-creation,Builtin,2,23754,0x10f48e520,128,GetImportMetaObjectBaseline
code-creation,Builtin,2,23762,0x10f48e5c0,116,GetIteratorWithFeedback
code-creation,Builtin,2,23769,0x10f48e640,100,GetIteratorBaseline
code-creation,Builtin,2,23775,0x10f48e6c0,268,CreateAsyncFromSyncIteratorBaseline
code-creation,Builtin,2,23783,0x10f48e7e0,1076,CallIteratorWithFeedback
code-creation,Builtin,2,23790,0x10f48ec20,288,MathAbs
code-creation,Builtin,2,23796,0x10f48ed60,428,MathCeil
code-creation,Builtin,2,23802,0x10f48ef20,432,MathFloor
code-creation,Builtin,2,23809,0x10f48f0e0,488,MathRound
code-creation,Builtin,2,23815,0x10f48f2e0,428,MathTrunc
code-creation,Builtin,2,23821,0x10f48f4a0,364,MathPow
code-creation,Builtin,2,23827,0x10f48f620,396,MathMax
code-creation,Builtin,2,23833,0x10f48f7c0,404,MathMin
code-creation,Builtin,2,23840,0x10f48f960,320,MathAcos
code-creation,Builtin,2,23846,0x10f48fac0,320,MathAcosh
code-creation,Builtin,2,23852,0x10f48fc20,320,MathAsin
code-creation,Builtin,2,23858,0x10f48fd80,320,MathAsinh
code-creation,Builtin,2,23865,0x10f48fee0,320,MathAtan
code-creation,Builtin,2,24353,0x10f490040,412,MathAtan2
code-creation,Builtin,2,24523,0x10f4901e0,320,MathAtanh
code-creation,Builtin,2,24540,0x10f490340,320,MathCbrt
code-creation,Builtin,2,24547,0x10f4904a0,168,MathClz32
code-creation,Builtin,2,24554,0x10f490560,320,MathCos
code-creation,Builtin,2,24560,0x10f4906c0,320,MathCosh
code-creation,Builtin,2,24566,0x10f490820,320,MathExp
code-creation,Builtin,2,24572,0x10f490980,320,MathExpm1
code-creation,Builtin,2,24578,0x10f490ae0,272,MathFround
code-creation,Builtin,2,24585,0x10f490c00,304,MathImul
code-creation,Builtin,2,24591,0x10f490d40,320,MathLog
code-creation,Builtin,2,24598,0x10f490ea0,320,MathLog1p
code-creation,Builtin,2,24604,0x10f491000,320,MathLog10
code-creation,Builtin,2,24610,0x10f491160,320,MathLog2
code-creation,Builtin,2,24616,0x10f4912c0,320,MathSin
code-creation,Builtin,2,24622,0x10f491420,180,MathSign
code-creation,Builtin,2,24628,0x10f4914e0,320,MathSinh
code-creation,Builtin,2,24634,0x10f491640,268,MathSqrt
code-creation,Builtin,2,24640,0x10f491760,320,MathTan
code-creation,Builtin,2,24646,0x10f4918c0,320,MathTanh
code-creation,Builtin,2,24653,0x10f491a20,1056,MathHypot
code-creation,Builtin,2,24659,0x10f491e60,324,MathRandom
code-creation,Builtin,2,24665,0x10f491fc0,2952,NumberPrototypeToString
code-creation,Builtin,2,24711,0x10f492b60,136,NumberIsFinite
code-creation,Builtin,2,24932,0x10f492c00,340,NumberIsInteger
code-creation,Builtin,2,24939,0x10f492d60,116,NumberIsNaN
code-creation,Builtin,2,24946,0x10f492de0,372,NumberIsSafeInteger
code-creation,Builtin,2,24953,0x10f492f60,156,NumberPrototypeValueOf
code-creation,Builtin,2,24960,0x10f493000,196,NumberParseFloat
code-creation,Builtin,2,24968,0x10f4930e0,248,ParseInt
code-creation,Builtin,2,24977,0x10f4931e0,84,NumberParseInt
code-creation,Builtin,2,24984,0x10f493240,860,Add
code-creation,Builtin,2,24990,0x10f4935a0,424,Subtract
code-creation,Builtin,2,24996,0x10f493760,608,Multiply
code-creation,Builtin,2,25003,0x10f4939e0,532,Divide
code-creation,Builtin,2,25010,0x10f493c00,592,Modulus
code-creation,Builtin,2,25018,0x10f493e60,524,Exponentiate
code-creation,Builtin,2,25025,0x10f494080,344,Negate
code-creation,Builtin,2,25033,0x10f4941e0,112,BitwiseNot
code-creation,Builtin,2,25042,0x10f494260,112,Decrement
code-creation,Builtin,2,25050,0x10f4942e0,112,Increment
code-creation,Builtin,2,25056,0x10f494360,392,ShiftLeft
code-creation,Builtin,2,25063,0x10f494500,392,ShiftRight
code-creation,Builtin,2,25070,0x10f4946a0,508,ShiftRightLogical
code-creation,Builtin,2,25089,0x10f4948a0,388,BitwiseAnd
code-creation,Builtin,2,25097,0x10f494a40,388,BitwiseOr
code-creation,Builtin,2,25103,0x10f494be0,388,BitwiseXor
code-creation,Builtin,2,25110,0x10f494d80,796,LessThan
code-creation,Builtin,2,25116,0x10f4950a0,796,LessThanOrEqual
code-creation,Builtin,2,25146,0x10f4953c0,796,GreaterThan
code-creation,Builtin,2,25153,0x10f4956e0,796,GreaterThanOrEqual
code-creation,Builtin,2,25162,0x10f495a00,860,Equal
code-creation,Builtin,2,25171,0x10f495d60,348,StrictEqual
code-creation,Builtin,2,25179,0x10f495ec0,3132,ObjectFromEntries
code-creation,Builtin,2,25188,0x10f496b00,756,CreateObjectWithoutProperties
code-creation,Builtin,2,25197,0x10f496e00,144,ObjectIsExtensible
code-creation,Builtin,2,25206,0x10f496ea0,148,ObjectPreventExtensions
code-creation,Builtin,2,25214,0x10f496f40,144,ObjectGetPrototypeOf
code-creation,Builtin,2,25224,0x10f496fe0,300,ObjectSetPrototypeOf
code-creation,Builtin,2,25232,0x10f497120,80,ObjectPrototypeToString
code-creation,Builtin,2,25241,0x10f497180,96,ObjectPrototypeValueOf
code-creation,Builtin,2,25250,0x10f497200,164,ObjectPrototypeToLocaleString
code-creation,Builtin,2,25259,0x10f4972c0,860,FulfillPromise
code-creation,Builtin,2,25267,0x10f497620,980,RejectPromise
code-creation,Builtin,2,25276,0x10f497a00,2412,NewPromiseCapability
code-creation,Builtin,2,25284,0x10f498380,164,PromiseCapabilityDefaultReject
code-creation,Builtin,2,25293,0x10f498440,148,PromiseCapabilityDefaultResolve
tick,0x7fff2030d8b1,25308,0,0x0,6
tick,0x7fff202fa556,25329,0,0x0,6
tick,0x7fff203b72be,25337,0,0x0,6
code-creation,Builtin,2,25364,0x10f4984e0,1412,PerformPromiseThen
code-creation,Builtin,2,25384,0x10f498a80,648,PromiseReject
code-creation,Builtin,2,25392,0x10f498d20,292,PromiseGetCapabilitiesExecutor
code-creation,Builtin,2,25400,0x10f498e60,104,PromiseConstructorLazyDeoptContinuation
code-creation,Builtin,2,25408,0x10f498ee0,4556,PromiseAll
code-creation,Builtin,2,25415,0x10f49a0c0,4876,PromiseAllSettled
code-creation,Builtin,2,25422,0x10f49b3e0,1100,PromiseAllResolveElementClosure
code-creation,Builtin,2,25429,0x10f49b840,1388,PromiseAllSettledResolveElementClosure
code-creation,Builtin,2,25437,0x10f49bdc0,1396,PromiseAllSettledRejectElementClosure
code-creation,Builtin,2,25445,0x10f49c340,1172,PromiseAnyRejectElementClosure
code-creation,Builtin,2,25453,0x10f49c7e0,2368,PromiseAny
code-creation,Builtin,2,25460,0x10f49d140,2908,PromiseConstructor
code-creation,Builtin,2,25466,0x10f49dca0,296,PromisePrototypeCatch
code-creation,Builtin,2,25474,0x10f49dde0,88,PromiseValueThunkFinally
code-creation,Builtin,2,25481,0x10f49de40,84,PromiseThrowerFinally
code-creation,Builtin,2,25488,0x10f49dea0,904,PromiseCatchFinally
code-creation,Builtin,2,25495,0x10f49e240,904,PromiseThenFinally
code-creation,Builtin,2,25502,0x10f49e5e0,1700,PromisePrototypeFinally
code-creation,Builtin,2,25509,0x10f49eca0,1336,PromiseRace
code-creation,Builtin,2,25516,0x10f49f1e0,268,PromiseFulfillReactionJob
code-creation,Builtin,2,25524,0x10f49f300,364,PromiseRejectReactionJob
code-creation,Builtin,2,25531,0x10f49f480,156,PromiseResolveTrampoline
code-creation,Builtin,2,25538,0x10f49f520,656,PromiseResolve
code-creation,Builtin,2,25544,0x10f49f7c0,712,ResolvePromise
code-creation,Builtin,2,25552,0x10f49faa0,2220,PromisePrototypeThen
code-creation,Builtin,2,25558,0x10f4a0360,1144,PromiseResolveThenableJob
code-creation,Builtin,2,25565,0x10f4a07e0,448,ProxyConstructor
code-creation,Builtin,2,25572,0x10f4a09c0,1760,ProxyDeleteProperty
code-creation,Builtin,2,25580,0x10f4a10c0,2112,ProxyGetProperty
code-creation,Builtin,2,25587,0x10f4a1920,1060,ProxyGetPrototypeOf
code-creation,Builtin,2,25593,0x10f4a1d60,1668,ProxyHasProperty
code-creation,Builtin,2,25600,0x10f4a2400,760,ProxyIsExtensible
code-creation,Builtin,2,25608,0x10f4a2700,800,ProxyPreventExtensions
code-creation,Builtin,2,25615,0x10f4a2a40,1148,ProxyRevocable
code-creation,Builtin,2,25622,0x10f4a2ec0,120,ProxyRevoke
code-creation,Builtin,2,25628,0x10f4a2f40,2216,ProxySetProperty
code-creation,Builtin,2,25635,0x10f4a3800,1292,ProxySetPrototypeOf
code-creation,Builtin,2,25655,0x10f4a3d20,208,ReflectIsExtensible
code-creation,Builtin,2,25663,0x10f4a3e00,212,ReflectPreventExtensions
code-creation,Builtin,2,25670,0x10f4a3ee0,188,ReflectGetPrototypeOf
code-creation,Builtin,2,25677,0x10f4a3fa0,292,ReflectSetPrototypeOf
code-creation,Builtin,2,25684,0x10f4a40e0,284,ReflectGet
code-creation,Builtin,2,25690,0x10f4a4200,160,ReflectDeleteProperty
code-creation,Builtin,2,25697,0x10f4a42c0,148,ReflectHas
code-creation,Builtin,2,25703,0x10f4a4360,5108,RegExpPrototypeExecSlow
code-creation,Builtin,2,25710,0x10f4a5760,5100,RegExpPrototypeExec
code-creation,Builtin,2,25717,0x10f4a6b60,2360,RegExpPrototypeMatchAll
code-creation,Builtin,2,25724,0x10f4a74a0,9384,RegExpStringIteratorPrototypeNext
code-creation,Builtin,2,25731,0x10f4a9960,8796,RegExpMatchFast
code-creation,Builtin,2,25738,0x10f4abbc0,3592,RegExpPrototypeMatch
code-creation,Builtin,2,25745,0x10f4ac9e0,6304,RegExpReplace
code-creation,Builtin,2,25751,0x10f4ae2a0,524,RegExpPrototypeReplace
code-creation,Builtin,2,25758,0x10f4ae4c0,1400,RegExpSearchFast
code-creation,Builtin,2,25779,0x10f4aea40,1640,RegExpPrototypeSearch
code-creation,Builtin,2,25790,0x10f4af0c0,200,RegExpPrototypeSourceGetter
code-creation,Builtin,2,25800,0x10f4af1a0,5784,RegExpSplit
code-creation,Builtin,2,25808,0x10f4b0840,476,RegExpPrototypeSplit
code-creation,Builtin,2,25818,0x10f4b0a20,2236,RegExpPrototypeTest
code-creation,Builtin,2,25827,0x10f4b12e0,1348,RegExpPrototypeTestFast
code-creation,Builtin,2,25835,0x10f4b1840,228,RegExpPrototypeGlobalGetter
code-creation,Builtin,2,25844,0x10f4b1940,244,RegExpPrototypeIgnoreCaseGetter
code-creation,Builtin,2,25854,0x10f4b1a40,244,RegExpPrototypeMultilineGetter
code-creation,Builtin,2,25863,0x10f4b1b40,244,RegExpPrototypeHasIndicesGetter
code-creation,Builtin,2,25872,0x10f4b1c40,244,RegExpPrototypeLinearGetter
code-creation,Builtin,2,25881,0x10f4b1d40,244,RegExpPrototypeDotAllGetter
code-creation,Builtin,2,25890,0x10f4b1e40,272,RegExpPrototypeStickyGetter
code-creation,Builtin,2,25900,0x10f4b1f60,272,RegExpPrototypeUnicodeGetter
code-creation,Builtin,2,25909,0x10f4b2080,2256,RegExpPrototypeFlagsGetter
code-creation,Builtin,2,25919,0x10f4b2960,1500,StringPrototypeAt
code-creation,Builtin,2,25927,0x10f4b2f40,2992,StringPrototypeEndsWith
code-creation,Builtin,2,25936,0x10f4b3b00,480,CreateHTML
code-creation,Builtin,2,25944,0x10f4b3d00,164,StringPrototypeAnchor
code-creation,Builtin,2,25953,0x10f4b3dc0,128,StringPrototypeBig
code-creation,Builtin,2,25961,0x10f4b3e60,128,StringPrototypeBlink
code-creation,Builtin,2,25971,0x10f4b3f00,128,StringPrototypeBold
code-creation,Builtin,2,25979,0x10f4b3fa0,168,StringPrototypeFontcolor
code-creation,Builtin,2,25989,0x10f4b4060,168,StringPrototypeFontsize
code-creation,Builtin,2,25998,0x10f4b4120,128,StringPrototypeFixed
code-creation,Builtin,2,26023,0x10f4b41c0,128,StringPrototypeItalics
code-creation,Builtin,2,26032,0x10f4b4260,168,StringPrototypeLink
code-creation,Builtin,2,26040,0x10f4b4320,128,StringPrototypeSmall
code-creation,Builtin,2,26049,0x10f4b43c0,128,StringPrototypeStrike
code-creation,Builtin,2,26058,0x10f4b4460,128,StringPrototypeSub
code-creation,Builtin,2,26067,0x10f4b4500,128,StringPrototypeSup
code-creation,Builtin,2,26075,0x10f4b45a0,1028,StringPrototypeIncludes
code-creation,Builtin,2,26084,0x10f4b49c0,628,StringPrototypeIndexOf
code-creation,Builtin,2,26093,0x10f4b4c40,344,StringPrototypeIterator
code-creation,Builtin,2,26102,0x10f4b4da0,2028,StringIteratorPrototypeNext
code-creation,Builtin,2,26112,0x10f4b55a0,1304,StringPrototypeMatch
code-creation,Builtin,2,26120,0x10f4b5ac0,1304,StringPrototypeSearch
code-creation,Builtin,2,26129,0x10f4b5fe0,824,StringPrototypePadStart
code-creation,Builtin,2,26138,0x10f4b6320,824,StringPrototypePadEnd
code-creation,Builtin,2,26147,0x10f4b6660,120,StringRepeat
code-creation,Builtin,2,26156,0x10f4b66e0,400,StringPrototypeRepeat
code-creation,Builtin,2,26165,0x10f4b6880,10964,StringPrototypeReplaceAll
code-creation,Builtin,2,26175,0x10f4b9360,3384,StringPrototypeSlice
code-creation,Builtin,2,26185,0x10f4ba0a0,3004,StringPrototypeStartsWith
code-creation,Builtin,2,26204,0x10f4bac60,3324,StringPrototypeSubstr
code-creation,Builtin,2,26214,0x10f4bb960,3260,StringPrototypeSubstring
code-creation,Builtin,2,26225,0x10f4bc620,6904,StringPrototypeTrim
code-creation,Builtin,2,26234,0x10f4be120,6316,StringPrototypeTrimStart
code-creation,Builtin,2,26244,0x10f4bf9e0,5840,StringPrototypeTrimEnd
code-creation,Builtin,2,26253,0x10f4c10c0,160,SymbolPrototypeDescriptionGetter
code-creation,Builtin,2,26263,0x10f4c1180,156,SymbolPrototypeToPrimitive
code-creation,Builtin,2,26273,0x10f4c1220,172,SymbolPrototypeToString
code-creation,Builtin,2,26282,0x10f4c12e0,156,SymbolPrototypeValueOf
code-creation,Builtin,2,26291,0x10f4c1380,832,TypedArrayPrototypeAt
code-creation,Builtin,2,26301,0x10f4c16e0,10004,CreateTypedArray
code-creation,Builtin,2,26311,0x10f4c3e00,1000,TypedArrayPrototypeEvery
code-creation,Builtin,2,26321,0x10f4c4200,372,TypedArrayPrototypeEntries
code-creation,Builtin,2,26330,0x10f4c4380,3508,TypedArrayPrototypeFilter
code-creation,Builtin,2,26339,0x10f4c5140,996,TypedArrayPrototypeFind
code-creation,Builtin,2,26349,0x10f4c5540,1004,TypedArrayPrototypeFindIndex
code-creation,Builtin,2,26359,0x10f4c5940,428,FindLastAllElementsDetachedContinuation
code-creation,Builtin,2,26369,0x10f4c5b00,1208,TypedArrayPrototypeFindLast
code-creation,Builtin,2,26378,0x10f4c5fc0,436,FindLastIndexAllElementsDetachedContinuation
code-creation,Builtin,2,26389,0x10f4c6180,1216,TypedArrayPrototypeFindLastIndex
code-creation,Builtin,2,26400,0x10f4c6660,864,TypedArrayPrototypeForEach
code-creation,Builtin,2,26410,0x10f4c69e0,2352,TypedArrayFrom
code-creation,Builtin,2,26419,0x10f4c7320,356,TypedArrayPrototypeKeys
code-creation,Builtin,2,26429,0x10f4c74a0,1028,TypedArrayOf
code-creation,Builtin,2,26439,0x10f4c78c0,952,TypedArrayPrototypeReduce
code-creation,Builtin,2,26448,0x10f4c7c80,944,TypedArrayPrototypeReduceRight
code-creation,Builtin,2,26459,0x10f4c8040,2496,TypedArrayPrototypeSet
code-creation,Builtin,2,26469,0x10f4c8a20,3028,TypedArrayPrototypeSlice
code-creation,Builtin,2,26478,0x10f4c9600,992,TypedArrayPrototypeSome
code-creation,Builtin,2,26487,0x10f4c9a00,1052,TypedArrayMergeSort
code-creation,Builtin,2,26497,0x10f4c9e20,1616,TypedArrayPrototypeSort
code-creation,Builtin,2,26508,0x10f4ca480,2736,TypedArrayPrototypeSubArray
code-creation,Builtin,2,26519,0x10f4caf40,372,TypedArrayPrototypeValues
code-creation,Builtin,2,26529,0x10f4cb0c0,956,WeakRefConstructor
code-creation,Builtin,2,26538,0x10f4cb480,184,WeakRefDeref
code-creation,Builtin,2,26548,0x10f4cb540,680,NewSloppyArgumentsElements
code-creation,Builtin,2,26558,0x10f4cb800,296,NewStrictArgumentsElements
code-creation,Builtin,2,26567,0x10f4cb940,320,NewRestArgumentsElements
code-creation,Builtin,2,26578,0x10f4cbaa0,1388,FastNewSloppyArguments
code-creation,Builtin,2,26588,0x10f4cc020,524,FastNewStrictArguments
code-creation,Builtin,2,26597,0x10f4cc240,556,FastNewRestArguments
code-creation,Builtin,2,26607,0x10f4cc480,676,StringSlowFlatten
code-creation,Builtin,2,26618,0x10f4cc740,2000,StringIndexOf
code-creation,Builtin,2,26628,0x10f4ccf20,4,GenericBuiltinTest_JSAny_0
code-creation,Builtin,2,26637,0x10f4ccf40,20,TestHelperPlus1
code-creation,Builtin,2,26647,0x10f4ccf60,20,TestHelperPlus2
code-creation,Builtin,2,26656,0x10f4ccf80,96,NewSmiBox
code-creation,Builtin,2,26665,0x10f4cd000,24,ReturnTwoValues
code-creation,Builtin,2,26674,0x10f4cd020,32,Load_FastSmiElements_0
code-creation,Builtin,2,26683,0x10f4cd060,32,Load_FastObjectElements_0
code-creation,Builtin,2,26692,0x10f4cd0a0,144,Load_FastDoubleElements_0
code-creation,Builtin,2,26702,0x10f4cd140,32,Store_FastSmiElements_0
code-creation,Builtin,2,26712,0x10f4cd180,92,Store_FastObjectElements_0
code-creation,Builtin,2,26723,0x10f4cd1e0,48,Store_FastDoubleElements_0
code-creation,Builtin,2,26733,0x10f4cd220,36,Delete_FastSmiElements_0
code-creation,Builtin,2,26742,0x10f4cd260,36,Delete_FastObjectElements_0
code-creation,Builtin,2,26752,0x10f4cd2a0,44,Delete_FastDoubleElements_0
code-creation,Builtin,2,26761,0x10f4cd2e0,308,SortCompareDefault
code-creation,Builtin,2,26781,0x10f4cd420,92,SortCompareUserFn
code-creation,Builtin,2,26790,0x10f4cd480,8,CanUseSameAccessor_GenericElementsAccessor_0
code-creation,Builtin,2,26808,0x10f4cd4a0,308,Copy
code-creation,Builtin,2,26816,0x10f4cd5e0,5732,MergeAt
code-creation,Builtin,2,26824,0x10f4cec60,792,GallopLeft
code-creation,Builtin,2,26832,0x10f4cef80,832,GallopRight
code-creation,Builtin,2,26841,0x10f4cf2e0,3820,ArrayTimSort
code-creation,Builtin,2,26850,0x10f4d01e0,2096,ArrayPrototypeSort
code-creation,Builtin,2,26859,0x10f4d0a20,100,WasmInt32ToHeapNumber
code-creation,Builtin,2,26868,0x10f4d0aa0,124,WasmTaggedNonSmiToInt32
code-creation,Builtin,2,26877,0x10f4d0b20,76,WasmTaggedToFloat64
code-creation,Builtin,2,26886,0x10f4d0b80,72,WasmMemoryGrow
code-creation,Builtin,2,26895,0x10f4d0be0,100,WasmTableInit
code-creation,Builtin,2,26904,0x10f4d0c60,100,WasmTableCopy
code-creation,Builtin,2,26912,0x10f4d0ce0,84,WasmTableFill
code-creation,Builtin,2,26921,0x10f4d0d40,72,WasmTableGrow
code-creation,Builtin,2,26929,0x10f4d0da0,144,WasmTableGet
code-creation,Builtin,2,26938,0x10f4d0e40,236,WasmTableSet
code-creation,Builtin,2,26947,0x10f4d0f40,88,WasmRefFunc
code-creation,Builtin,2,26955,0x10f4d0fa0,144,WasmAllocateFixedArray
code-creation,Builtin,2,26964,0x10f4d1040,44,WasmThrow
code-creation,Builtin,2,26972,0x10f4d1080,52,WasmRethrow
code-creation,Builtin,2,26979,0x10f4d10c0,44,WasmTriggerTierUp
code-creation,Builtin,2,26989,0x10f4d1100,32,WasmStackGuard
code-creation,Builtin,2,26997,0x10f4d1140,32,WasmStackOverflow
code-creation,Builtin,2,27006,0x10f4d1180,40,WasmTraceMemory
code-creation,Builtin,2,27015,0x10f4d11c0,32,WasmTraceEnter
code-creation,Builtin,2,27024,0x10f4d1200,40,WasmTraceExit
code-creation,Builtin,2,27033,0x10f4d1240,332,WasmAllocateJSArray
code-creation,Builtin,2,27043,0x10f4d13a0,104,WasmAllocatePair
code-creation,Builtin,2,27051,0x10f4d1420,64,WasmAllocateRtt
code-creation,Builtin,2,27060,0x10f4d1480,72,WasmAllocateFreshRtt
code-creation,Builtin,2,27069,0x10f4d14e0,124,WasmAllocateStructWithRtt
code-creation,Builtin,2,27077,0x10f4d1560,140,WasmAllocateArray_Uninitialized
code-creation,Builtin,2,27087,0x10f4d1600,176,WasmAllocateArray_InitZero
code-creation,Builtin,2,27096,0x10f4d16c0,176,WasmAllocateArray_InitNull
code-creation,Builtin,2,27105,0x10f4d1780,116,WasmArrayCopyWithChecks
code-creation,Builtin,2,27114,0x10f4d1800,60,WasmArrayCopy
code-creation,Builtin,2,27123,0x10f4d1840,240,WasmAllocateObjectWrapper
code-creation,Builtin,2,27133,0x10f4d1940,52,WasmSubtypeCheck
code-creation,Builtin,2,27141,0x10f4d1980,8,WasmInt32ToNumber
code-creation,Builtin,2,27150,0x10f4d19a0,116,WasmUint32ToNumber
code-creation,Builtin,2,27159,0x10f4d1a20,144,UintPtr53ToNumber
code-creation,Builtin,2,27167,0x10f4d1ac0,96,WasmAtomicNotify
code-creation,Builtin,2,27176,0x10f4d1b40,116,WasmI32AtomicWait64
code-creation,Builtin,2,27185,0x10f4d1bc0,116,WasmI64AtomicWait64
code-creation,Builtin,2,27194,0x10f4d1c40,580,WasmGetOwnProperty
code-creation,Builtin,2,27203,0x10f4d1ea0,40,WasmTrap
code-creation,Builtin,2,27211,0x10f4d1ee0,16,ThrowWasmTrapUnreachable
code-creation,Builtin,2,27220,0x10f4d1f00,16,ThrowWasmTrapMemOutOfBounds
code-creation,Builtin,2,27231,0x10f4d1f20,16,ThrowWasmTrapUnalignedAccess
code-creation,Builtin,2,27240,0x10f4d1f40,16,ThrowWasmTrapDivByZero
code-creation,Builtin,2,27248,0x10f4d1f60,16,ThrowWasmTrapDivUnrepresentable
code-creation,Builtin,2,27258,0x10f4d1f80,16,ThrowWasmTrapRemByZero
code-creation,Builtin,2,27267,0x10f4d1fa0,16,ThrowWasmTrapFloatUnrepresentable
code-creation,Builtin,2,27277,0x10f4d1fc0,16,ThrowWasmTrapFuncSigMismatch
code-creation,Builtin,2,27286,0x10f4d1fe0,16,ThrowWasmTrapDataSegmentDropped
code-creation,Builtin,2,27295,0x10f4d2000,16,ThrowWasmTrapElemSegmentDropped
code-creation,Builtin,2,27304,0x10f4d2020,16,ThrowWasmTrapTableOutOfBounds
code-creation,Builtin,2,27314,0x10f4d2040,16,ThrowWasmTrapRethrowNull
code-creation,Builtin,2,27323,0x10f4d2060,16,ThrowWasmTrapNullDereference
code-creation,Builtin,2,27332,0x10f4d2080,16,ThrowWasmTrapIllegalCast
code-creation,Builtin,2,27341,0x10f4d20a0,16,ThrowWasmTrapArrayOutOfBounds
code-creation,Builtin,2,27360,0x10f4d20c0,16,ThrowWasmTrapArrayTooLarge
code-creation,Builtin,2,27370,0x10f4d20e0,172,LoadJoinElement_GenericElementsAccessor_0
code-creation,Builtin,2,27380,0x10f4d21a0,24,LoadJoinTypedElement_Int32Elements_0
code-creation,Builtin,2,27389,0x10f4d21c0,116,LoadJoinTypedElement_Float32Elements_0
code-creation,Builtin,2,27399,0x10f4d2240,112,LoadJoinTypedElement_Float64Elements_0
code-creation,Builtin,2,27409,0x10f4d22c0,24,LoadJoinTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,27419,0x10f4d22e0,220,LoadJoinTypedElement_BigUint64Elements_0
code-creation,Builtin,2,27429,0x10f4d23c0,248,LoadJoinTypedElement_BigInt64Elements_0
code-creation,Builtin,2,27439,0x10f4d24c0,24,LoadJoinTypedElement_Uint8Elements_0
code-creation,Builtin,2,27449,0x10f4d24e0,24,LoadJoinTypedElement_Int8Elements_0
code-creation,Builtin,2,27459,0x10f4d2500,24,LoadJoinTypedElement_Uint16Elements_0
code-creation,Builtin,2,27469,0x10f4d2520,24,LoadJoinTypedElement_Int16Elements_0
code-creation,Builtin,2,27479,0x10f4d2540,132,LoadJoinTypedElement_Uint32Elements_0
code-creation,Builtin,2,27489,0x10f4d25e0,8,GenericBuiltinTest_Smi_0
code-creation,Builtin,2,27498,0x10f4d2600,32,CanUseSameAccessor_FastDoubleElements_0
code-creation,Builtin,2,27508,0x10f4d2640,32,CanUseSameAccessor_FastSmiElements_0
code-creation,Builtin,2,27517,0x10f4d2680,32,CanUseSameAccessor_FastObjectElements_0
code-creation,Builtin,2,27527,0x10f4d26c0,2668,Load_GenericElementsAccessor_0
code-creation,Builtin,2,27537,0x10f4d3140,24,Store_GenericElementsAccessor_0
code-creation,Builtin,2,27546,0x10f4d3160,36,Delete_GenericElementsAccessor_0
code-creation,Builtin,2,27556,0x10f4d31a0,24,LoadTypedElement_Int32Elements_0
code-creation,Builtin,2,27565,0x10f4d31c0,164,StoreTypedElementNumeric_Int32Elements_0
code-creation,Builtin,2,27575,0x10f4d3280,180,StoreTypedElementJSAny_Int32Elements_0
code-creation,Builtin,2,27585,0x10f4d3340,116,LoadTypedElement_Float32Elements_0
code-creation,Builtin,2,27595,0x10f4d33c0,32,StoreTypedElementNumeric_Float32Elements_0
code-creation,Builtin,2,27605,0x10f4d3400,156,StoreTypedElementJSAny_Float32Elements_0
code-creation,Builtin,2,27615,0x10f4d34a0,112,LoadTypedElement_Float64Elements_0
code-creation,Builtin,2,27640,0x10f4d3520,28,StoreTypedElementNumeric_Float64Elements_0
code-creation,Builtin,2,27650,0x10f4d3540,152,StoreTypedElementJSAny_Float64Elements_0
code-creation,Builtin,2,27660,0x10f4d35e0,24,LoadTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,27670,0x10f4d3600,24,StoreTypedElementNumeric_Uint8ClampedElements_0
code-creation,Builtin,2,27680,0x10f4d3620,620,StoreTypedElementJSAny_Uint8ClampedElements_0
code-creation,Builtin,2,27691,0x10f4d38a0,220,LoadTypedElement_BigUint64Elements_0
code-creation,Builtin,2,27701,0x10f4d3980,56,StoreTypedElementNumeric_BigUint64Elements_0
code-creation,Builtin,2,27710,0x10f4d39c0,200,StoreTypedElementJSAny_BigUint64Elements_0
code-creation,Builtin,2,27721,0x10f4d3aa0,248,LoadTypedElement_BigInt64Elements_0
code-creation,Builtin,2,27731,0x10f4d3ba0,56,StoreTypedElementNumeric_BigInt64Elements_0
code-creation,Builtin,2,27741,0x10f4d3be0,200,StoreTypedElementJSAny_BigInt64Elements_0
code-creation,Builtin,2,27753,0x10f4d3cc0,24,LoadTypedElement_Uint8Elements_0
code-creation,Builtin,2,27762,0x10f4d3ce0,24,StoreTypedElementNumeric_Uint8Elements_0
code-creation,Builtin,2,27773,0x10f4d3d00,180,StoreTypedElementJSAny_Uint8Elements_0
code-creation,Builtin,2,27782,0x10f4d3dc0,24,LoadTypedElement_Int8Elements_0
code-creation,Builtin,2,27792,0x10f4d3de0,24,StoreTypedElementNumeric_Int8Elements_0
code-creation,Builtin,2,27801,0x10f4d3e00,180,StoreTypedElementJSAny_Int8Elements_0
code-creation,Builtin,2,27817,0x10f4d3ec0,24,LoadTypedElement_Uint16Elements_0
tick,0x7fff203b72be,27835,0,0x0,6
tick,0x7fff202fa4c9,27859,0,0x0,6
tick,0x7fff203e537c,27869,0,0x0,6
code-creation,Builtin,2,28897,0x10f4d3ee0,24,StoreTypedElementNumeric_Uint16Elements_0
code-creation,Builtin,2,28924,0x10f4d3f00,180,StoreTypedElementJSAny_Uint16Elements_0
code-creation,Builtin,2,28997,0x10f4d3fc0,24,LoadTypedElement_Int16Elements_0
code-creation,Builtin,2,29015,0x10f4d3fe0,24,StoreTypedElementNumeric_Int16Elements_0
code-creation,Builtin,2,29027,0x10f4d4000,180,StoreTypedElementJSAny_Int16Elements_0
code-creation,Builtin,2,29037,0x10f4d40c0,132,LoadTypedElement_Uint32Elements_0
code-creation,Builtin,2,29048,0x10f4d4160,164,StoreTypedElementNumeric_Uint32Elements_0
code-creation,Builtin,2,29058,0x10f4d4220,180,StoreTypedElementJSAny_Uint32Elements_0
code-creation,Builtin,2,29068,0x10f4d42e0,12,CollatorConstructor
code-creation,Builtin,2,29078,0x10f4d4300,12,CollatorInternalCompare
code-creation,Builtin,2,29087,0x10f4d4320,12,CollatorPrototypeCompare
code-creation,Builtin,2,29096,0x10f4d4340,12,CollatorSupportedLocalesOf
code-creation,Builtin,2,29105,0x10f4d4360,12,CollatorPrototypeResolvedOptions
code-creation,Builtin,2,29115,0x10f4d4380,12,DatePrototypeToLocaleDateString
code-creation,Builtin,2,29124,0x10f4d43a0,12,DatePrototypeToLocaleString
code-creation,Builtin,2,29133,0x10f4d43c0,12,DatePrototypeToLocaleTimeString
code-creation,Builtin,2,29144,0x10f4d43e0,12,DateTimeFormatConstructor
code-creation,Builtin,2,29153,0x10f4d4400,12,DateTimeFormatInternalFormat
code-creation,Builtin,2,29163,0x10f4d4420,12,DateTimeFormatPrototypeFormat
code-creation,Builtin,2,29172,0x10f4d4440,12,DateTimeFormatPrototypeFormatRange
code-creation,Builtin,2,29183,0x10f4d4460,12,DateTimeFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,29193,0x10f4d4480,12,DateTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,29203,0x10f4d44a0,12,DateTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,29213,0x10f4d44c0,12,DateTimeFormatSupportedLocalesOf
code-creation,Builtin,2,29224,0x10f4d44e0,12,DisplayNamesConstructor
code-creation,Builtin,2,29233,0x10f4d4500,12,DisplayNamesPrototypeOf
code-creation,Builtin,2,29241,0x10f4d4520,12,DisplayNamesPrototypeResolvedOptions
code-creation,Builtin,2,29251,0x10f4d4540,12,DisplayNamesSupportedLocalesOf
code-creation,Builtin,2,29260,0x10f4d4560,12,IntlGetCanonicalLocales
code-creation,Builtin,2,29269,0x10f4d4580,12,ListFormatConstructor
code-creation,Builtin,2,29278,0x10f4d45a0,224,ListFormatPrototypeFormat
code-creation,Builtin,2,29287,0x10f4d46a0,224,ListFormatPrototypeFormatToParts
code-creation,Builtin,2,29297,0x10f4d47a0,12,ListFormatPrototypeResolvedOptions
code-creation,Builtin,2,29307,0x10f4d47c0,12,ListFormatSupportedLocalesOf
code-creation,Builtin,2,29316,0x10f4d47e0,12,LocaleConstructor
code-creation,Builtin,2,29325,0x10f4d4800,12,LocalePrototypeBaseName
code-creation,Builtin,2,29334,0x10f4d4820,12,LocalePrototypeCalendar
code-creation,Builtin,2,29343,0x10f4d4840,12,LocalePrototypeCalendars
code-creation,Builtin,2,29353,0x10f4d4860,12,LocalePrototypeCaseFirst
code-creation,Builtin,2,29362,0x10f4d4880,12,LocalePrototypeCollation
code-creation,Builtin,2,29372,0x10f4d48a0,12,LocalePrototypeCollations
code-creation,Builtin,2,29381,0x10f4d48c0,12,LocalePrototypeHourCycle
code-creation,Builtin,2,29390,0x10f4d48e0,12,LocalePrototypeHourCycles
code-creation,Builtin,2,29399,0x10f4d4900,12,LocalePrototypeLanguage
code-creation,Builtin,2,29408,0x10f4d4920,12,LocalePrototypeMaximize
code-creation,Builtin,2,29417,0x10f4d4940,12,LocalePrototypeMinimize
code-creation,Builtin,2,29427,0x10f4d4960,12,LocalePrototypeNumeric
code-creation,Builtin,2,29436,0x10f4d4980,12,LocalePrototypeNumberingSystem
code-creation,Builtin,2,29445,0x10f4d49a0,12,LocalePrototypeNumberingSystems
code-creation,Builtin,2,29454,0x10f4d49c0,12,LocalePrototypeRegion
code-creation,Builtin,2,29464,0x10f4d49e0,12,LocalePrototypeScript
code-creation,Builtin,2,29473,0x10f4d4a00,12,LocalePrototypeTextInfo
code-creation,Builtin,2,29482,0x10f4d4a20,12,LocalePrototypeTimeZones
code-creation,Builtin,2,29491,0x10f4d4a40,12,LocalePrototypeToString
code-creation,Builtin,2,29501,0x10f4d4a60,12,LocalePrototypeWeekInfo
code-creation,Builtin,2,29510,0x10f4d4a80,12,NumberFormatConstructor
code-creation,Builtin,2,29519,0x10f4d4aa0,12,NumberFormatInternalFormatNumber
code-creation,Builtin,2,29529,0x10f4d4ac0,12,NumberFormatPrototypeFormatNumber
code-creation,Builtin,2,29550,0x10f4d4ae0,12,NumberFormatPrototypeFormatToParts
code-creation,Builtin,2,29560,0x10f4d4b00,12,NumberFormatPrototypeResolvedOptions
code-creation,Builtin,2,29570,0x10f4d4b20,12,NumberFormatSupportedLocalesOf
code-creation,Builtin,2,29580,0x10f4d4b40,12,PluralRulesConstructor
code-creation,Builtin,2,29589,0x10f4d4b60,12,PluralRulesPrototypeResolvedOptions
code-creation,Builtin,2,29599,0x10f4d4b80,12,PluralRulesPrototypeSelect
code-creation,Builtin,2,29609,0x10f4d4ba0,12,PluralRulesSupportedLocalesOf
code-creation,Builtin,2,29618,0x10f4d4bc0,12,RelativeTimeFormatConstructor
code-creation,Builtin,2,29627,0x10f4d4be0,12,RelativeTimeFormatPrototypeFormat
code-creation,Builtin,2,29637,0x10f4d4c00,12,RelativeTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,29647,0x10f4d4c20,12,RelativeTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,29657,0x10f4d4c40,12,RelativeTimeFormatSupportedLocalesOf
code-creation,Builtin,2,29667,0x10f4d4c60,12,SegmenterConstructor
code-creation,Builtin,2,29676,0x10f4d4c80,12,SegmenterPrototypeResolvedOptions
code-creation,Builtin,2,29686,0x10f4d4ca0,12,SegmenterPrototypeSegment
code-creation,Builtin,2,29695,0x10f4d4cc0,12,SegmenterSupportedLocalesOf
code-creation,Builtin,2,29705,0x10f4d4ce0,12,SegmentIteratorPrototypeNext
code-creation,Builtin,2,29715,0x10f4d4d00,12,SegmentsPrototypeContaining
code-creation,Builtin,2,29724,0x10f4d4d20,12,SegmentsPrototypeIterator
code-creation,Builtin,2,29733,0x10f4d4d40,12,StringPrototypeNormalizeIntl
code-creation,Builtin,2,29743,0x10f4d4d60,12,StringPrototypeToLocaleLowerCase
code-creation,Builtin,2,29753,0x10f4d4d80,12,StringPrototypeToLocaleUpperCase
code-creation,Builtin,2,29763,0x10f4d4da0,200,StringPrototypeToLowerCaseIntl
code-creation,Builtin,2,29773,0x10f4d4e80,12,StringPrototypeToUpperCaseIntl
code-creation,Builtin,2,29782,0x10f4d4ea0,632,StringToLowerCaseIntl
code-creation,Builtin,2,29791,0x10f4d5120,12,V8BreakIteratorConstructor
code-creation,Builtin,2,29801,0x10f4d5140,12,V8BreakIteratorInternalAdoptText
code-creation,Builtin,2,29810,0x10f4d5160,12,V8BreakIteratorInternalBreakType
code-creation,Builtin,2,29820,0x10f4d5180,12,V8BreakIteratorInternalCurrent
code-creation,Builtin,2,29830,0x10f4d51a0,12,V8BreakIteratorInternalFirst
code-creation,Builtin,2,29839,0x10f4d51c0,12,V8BreakIteratorInternalNext
code-creation,Builtin,2,29848,0x10f4d51e0,12,V8BreakIteratorPrototypeAdoptText
code-creation,Builtin,2,29858,0x10f4d5200,12,V8BreakIteratorPrototypeBreakType
code-creation,Builtin,2,29868,0x10f4d5220,12,V8BreakIteratorPrototypeCurrent
code-creation,Builtin,2,29878,0x10f4d5240,12,V8BreakIteratorPrototypeFirst
code-creation,Builtin,2,29887,0x10f4d5260,12,V8BreakIteratorPrototypeNext
code-creation,Builtin,2,29896,0x10f4d5280,12,V8BreakIteratorPrototypeResolvedOptions
code-creation,Builtin,2,29907,0x10f4d52a0,12,V8BreakIteratorSupportedLocalesOf
tick,0x7fff203b72be,29926,0,0x0,6
code-creation,BytecodeHandler,0,29959,0x10f4d52c0,24,Wide
code-creation,BytecodeHandler,0,29967,0x10f4d52e0,24,ExtraWide
code-creation,BytecodeHandler,0,29974,0x10f4d5300,104,DebugBreakWide
code-creation,BytecodeHandler,0,29981,0x10f4d5380,104,DebugBreakExtraWide
code-creation,BytecodeHandler,0,29989,0x10f4d5400,164,DebugBreak0
code-creation,BytecodeHandler,0,29996,0x10f4d54c0,104,DebugBreak1
code-creation,BytecodeHandler,0,30003,0x10f4d5540,104,DebugBreak2
code-creation,BytecodeHandler,0,30011,0x10f4d55c0,104,DebugBreak3
code-creation,BytecodeHandler,0,30017,0x10f4d5640,104,DebugBreak4
code-creation,BytecodeHandler,0,30024,0x10f4d56c0,104,DebugBreak5
code-creation,BytecodeHandler,0,30032,0x10f4d5740,104,DebugBreak6
code-creation,BytecodeHandler,0,30039,0x10f4d57c0,32,Ldar
code-creation,BytecodeHandler,0,30045,0x10f4d5800,68,LdaZero
code-creation,BytecodeHandler,0,30052,0x10f4d5860,76,LdaSmi
code-creation,BytecodeHandler,0,30059,0x10f4d58c0,68,LdaUndefined
code-creation,BytecodeHandler,0,30066,0x10f4d5920,68,LdaNull
code-creation,BytecodeHandler,0,30073,0x10f4d5980,68,LdaTheHole
code-creation,BytecodeHandler,0,30080,0x10f4d59e0,20,LdaTrue
code-creation,BytecodeHandler,0,30096,0x10f4d5a00,20,LdaFalse
code-creation,BytecodeHandler,0,30104,0x10f4d5a20,76,LdaConstant
code-creation,BytecodeHandler,0,30112,0x10f4d5a80,132,LdaContextSlot
code-creation,BytecodeHandler,0,30119,0x10f4d5b20,132,LdaImmutableContextSlot
code-creation,BytecodeHandler,0,30127,0x10f4d5bc0,88,LdaCurrentContextSlot
code-creation,BytecodeHandler,0,30134,0x10f4d5c20,88,LdaImmutableCurrentContextSlot
code-creation,BytecodeHandler,0,30142,0x10f4d5c80,32,Star
code-creation,BytecodeHandler,0,30149,0x10f4d5cc0,40,Mov
code-creation,BytecodeHandler,0,30156,0x10f4d5d00,40,PushContext
code-creation,BytecodeHandler,0,30163,0x10f4d5d40,36,PopContext
code-creation,BytecodeHandler,0,30170,0x10f4d5d80,48,TestReferenceEqual
code-creation,BytecodeHandler,0,30177,0x10f4d5dc0,52,TestUndetectable
code-creation,BytecodeHandler,0,30184,0x10f4d5e00,36,TestNull
code-creation,BytecodeHandler,0,30191,0x10f4d5e40,36,TestUndefined
code-creation,BytecodeHandler,0,30198,0x10f4d5e80,336,TestTypeOf
code-creation,BytecodeHandler,0,30205,0x10f4d5fe0,6036,LdaGlobal
code-creation,BytecodeHandler,0,30212,0x10f4d7780,4536,LdaGlobalInsideTypeof
code-creation,BytecodeHandler,0,30233,0x10f4d8940,168,StaGlobal
code-creation,BytecodeHandler,0,30242,0x10f4d8a00,156,StaContextSlot
code-creation,BytecodeHandler,0,30251,0x10f4d8aa0,112,StaCurrentContextSlot
code-creation,BytecodeHandler,0,30260,0x10f4d8b20,124,LdaLookupSlot
code-creation,BytecodeHandler,0,30269,0x10f4d8ba0,240,LdaLookupContextSlot
code-creation,BytecodeHandler,0,30278,0x10f4d8ca0,4776,LdaLookupGlobalSlot
code-creation,BytecodeHandler,0,30287,0x10f4d9f60,124,LdaLookupSlotInsideTypeof
code-creation,BytecodeHandler,0,30297,0x10f4d9fe0,240,LdaLookupContextSlotInsideTypeof
code-creation,BytecodeHandler,0,30308,0x10f4da0e0,4740,LdaLookupGlobalSlotInsideTypeof
code-creation,BytecodeHandler,0,30318,0x10f4db380,220,StaLookupSlot
code-creation,BytecodeHandler,0,30326,0x10f4db460,5204,LdaNamedProperty
code-creation,BytecodeHandler,0,30336,0x10f4dc8c0,180,LdaNamedPropertyFromSuper
code-creation,BytecodeHandler,0,30347,0x10f4dc980,212,LdaKeyedProperty
code-creation,BytecodeHandler,0,30356,0x10f4dca60,160,LdaModuleVariable
code-creation,BytecodeHandler,0,30365,0x10f4dcb20,292,StaModuleVariable
code-creation,BytecodeHandler,0,30374,0x10f4dcc60,172,StaNamedProperty
code-creation,BytecodeHandler,0,30383,0x10f4dcd20,172,StaNamedOwnProperty
code-creation,BytecodeHandler,0,30393,0x10f4dcde0,164,StaKeyedProperty
code-creation,BytecodeHandler,0,30402,0x10f4dcea0,164,StaInArrayLiteral
code-creation,BytecodeHandler,0,30412,0x10f4dcf60,196,StaDataPropertyInLiteral
code-creation,BytecodeHandler,0,30421,0x10f4dd040,160,CollectTypeProfile
code-creation,BytecodeHandler,0,30431,0x10f4dd100,1028,Add
code-creation,BytecodeHandler,0,30439,0x10f4dd520,1064,Sub
code-creation,BytecodeHandler,0,30447,0x10f4dd960,1024,Mul
code-creation,BytecodeHandler,0,30456,0x10f4ddd80,988,Div
code-creation,BytecodeHandler,0,30464,0x10f4de160,912,Mod
code-creation,BytecodeHandler,0,30472,0x10f4de500,960,Exp
code-creation,BytecodeHandler,0,30481,0x10f4de8e0,876,BitwiseOr
code-creation,BytecodeHandler,0,30491,0x10f4dec60,888,BitwiseXor
code-creation,BytecodeHandler,0,30499,0x10f4defe0,888,BitwiseAnd
code-creation,BytecodeHandler,0,30509,0x10f4df360,900,ShiftLeft
code-creation,BytecodeHandler,0,30517,0x10f4df700,900,ShiftRight
code-creation,BytecodeHandler,0,30527,0x10f4dfaa0,1020,ShiftRightLogical
code-creation,BytecodeHandler,0,30536,0x10f4dfea0,960,AddSmi
code-creation,BytecodeHandler,0,30544,0x10f4e0280,1000,SubSmi
code-creation,BytecodeHandler,0,30553,0x10f4e0680,916,MulSmi
code-creation,BytecodeHandler,0,30562,0x10f4e0a20,920,DivSmi
code-creation,BytecodeHandler,0,30570,0x10f4e0dc0,816,ModSmi
code-creation,BytecodeHandler,0,30579,0x10f4e1100,868,ExpSmi
code-creation,BytecodeHandler,0,30587,0x10f4e1480,488,BitwiseOrSmi
code-creation,BytecodeHandler,0,30596,0x10f4e1680,488,BitwiseXorSmi
code-creation,BytecodeHandler,0,30605,0x10f4e1880,488,BitwiseAndSmi
code-creation,BytecodeHandler,0,30614,0x10f4e1a80,488,ShiftLeftSmi
code-creation,BytecodeHandler,0,30633,0x10f4e1c80,488,ShiftRightSmi
code-creation,BytecodeHandler,0,30643,0x10f4e1e80,640,ShiftRightLogicalSmi
code-creation,BytecodeHandler,0,30652,0x10f4e2120,656,Inc
code-creation,BytecodeHandler,0,30661,0x10f4e23c0,656,Dec
code-creation,BytecodeHandler,0,30669,0x10f4e2660,640,Negate
code-creation,BytecodeHandler,0,30677,0x10f4e2900,480,BitwiseNot
code-creation,BytecodeHandler,0,30686,0x10f4e2b00,108,ToBooleanLogicalNot
code-creation,BytecodeHandler,0,30695,0x10f4e2b80,36,LogicalNot
code-creation,BytecodeHandler,0,30704,0x10f4e2bc0,208,TypeOf
code-creation,BytecodeHandler,0,30713,0x10f4e2ca0,120,DeletePropertyStrict
code-creation,BytecodeHandler,0,30722,0x10f4e2d20,112,DeletePropertySloppy
code-creation,BytecodeHandler,0,30731,0x10f4e2da0,40,GetSuperConstructor
code-creation,BytecodeHandler,0,30741,0x10f4e2de0,1120,CallAnyReceiver
code-creation,BytecodeHandler,0,30750,0x10f4e3260,1120,CallProperty
code-creation,BytecodeHandler,0,30759,0x10f4e36e0,1008,CallProperty0
code-creation,BytecodeHandler,0,30768,0x10f4e3ae0,1024,CallProperty1
code-creation,BytecodeHandler,0,30777,0x10f4e3f00,1036,CallProperty2
code-creation,BytecodeHandler,0,30786,0x10f4e4320,1000,CallUndefinedReceiver
code-creation,BytecodeHandler,0,30796,0x10f4e4720,1040,CallUndefinedReceiver0
code-creation,BytecodeHandler,0,30805,0x10f4e4b40,1016,CallUndefinedReceiver1
code-creation,BytecodeHandler,0,30815,0x10f4e4f40,1032,CallUndefinedReceiver2
code-creation,BytecodeHandler,0,30824,0x10f4e5360,1120,CallWithSpread
code-creation,BytecodeHandler,0,30833,0x10f4e57e0,124,CallRuntime
code-creation,BytecodeHandler,0,30842,0x10f4e5860,156,CallRuntimeForPair
code-creation,BytecodeHandler,0,30851,0x10f4e5900,80,CallJSRuntime
code-creation,BytecodeHandler,0,30860,0x10f4e5960,1236,InvokeIntrinsic
code-creation,BytecodeHandler,0,30869,0x10f4e5e40,1016,Construct
code-creation,BytecodeHandler,0,30878,0x10f4e6240,536,ConstructWithSpread
code-creation,BytecodeHandler,0,30888,0x10f4e6460,1936,TestEqual
code-creation,BytecodeHandler,0,30897,0x10f4e6c00,1064,TestEqualStrict
code-creation,BytecodeHandler,0,30906,0x10f4e7040,1624,TestLessThan
code-creation,BytecodeHandler,0,30915,0x10f4e76a0,1624,TestGreaterThan
code-creation,BytecodeHandler,0,30924,0x10f4e7d00,1624,TestLessThanOrEqual
code-creation,BytecodeHandler,0,30934,0x10f4e8360,1624,TestGreaterThanOrEqual
code-creation,BytecodeHandler,0,30943,0x10f4e89c0,856,TestInstanceOf
code-creation,BytecodeHandler,0,30952,0x10f4e8d20,156,TestIn
code-creation,BytecodeHandler,0,30961,0x10f4e8dc0,112,ToName
code-creation,BytecodeHandler,0,30970,0x10f4e8e40,212,ToNumber
code-creation,BytecodeHandler,0,30979,0x10f4e8f20,232,ToNumeric
code-creation,BytecodeHandler,0,30987,0x10f4e9020,112,ToObject
code-creation,BytecodeHandler,0,30996,0x10f4e90a0,116,ToString
code-creation,BytecodeHandler,0,31005,0x10f4e9120,400,CreateRegExpLiteral
code-creation,BytecodeHandler,0,31014,0x10f4e92c0,1460,CreateArrayLiteral
code-creation,BytecodeHandler,0,31024,0x10f4e9880,92,CreateArrayFromIterable
code-creation,BytecodeHandler,0,31034,0x10f4e98e0,792,CreateEmptyArrayLiteral
code-creation,BytecodeHandler,0,31044,0x10f4e9c00,2160,CreateObjectLiteral
code-creation,BytecodeHandler,0,31053,0x10f4ea480,224,CreateEmptyObjectLiteral
code-creation,BytecodeHandler,0,31063,0x10f4ea580,168,CloneObject
code-creation,BytecodeHandler,0,31072,0x10f4ea640,212,GetTemplateObject
code-creation,BytecodeHandler,0,31081,0x10f4ea720,328,CreateClosure
code-creation,BytecodeHandler,0,31090,0x10f4ea880,120,CreateBlockContext
code-creation,BytecodeHandler,0,31100,0x10f4ea900,132,CreateCatchContext
code-creation,BytecodeHandler,0,31109,0x10f4ea9a0,256,CreateFunctionContext
code-creation,BytecodeHandler,0,31118,0x10f4eaac0,256,CreateEvalContext
code-creation,BytecodeHandler,0,31128,0x10f4eabe0,132,CreateWithContext
code-creation,BytecodeHandler,0,31137,0x10f4eac80,1568,CreateMappedArguments
code-creation,BytecodeHandler,0,31146,0x10f4eb2c0,592,CreateUnmappedArguments
code-creation,BytecodeHandler,0,31156,0x10f4eb520,632,CreateRestParameter
code-creation,BytecodeHandler,0,31174,0x10f4eb7a0,424,JumpLoop
code-creation,BytecodeHandler,0,31184,0x10f4eb960,44,Jump
code-creation,BytecodeHandler,0,31193,0x10f4eb9a0,56,JumpConstant
code-creation,BytecodeHandler,0,31202,0x10f4eb9e0,80,JumpIfNullConstant
code-creation,BytecodeHandler,0,31211,0x10f4eba40,80,JumpIfNotNullConstant
code-creation,BytecodeHandler,0,31221,0x10f4ebaa0,80,JumpIfUndefinedConstant
code-creation,BytecodeHandler,0,31239,0x10f4ebb00,80,JumpIfNotUndefinedConstant
code-creation,BytecodeHandler,0,31249,0x10f4ebb60,84,JumpIfUndefinedOrNullConstant
code-creation,BytecodeHandler,0,31259,0x10f4ebbc0,80,JumpIfTrueConstant
code-creation,BytecodeHandler,0,31269,0x10f4ebc20,80,JumpIfFalseConstant
code-creation,BytecodeHandler,0,31278,0x10f4ebc80,88,JumpIfJSReceiverConstant
code-creation,BytecodeHandler,0,31288,0x10f4ebce0,152,JumpIfToBooleanTrueConstant
code-creation,BytecodeHandler,0,31298,0x10f4ebd80,152,JumpIfToBooleanFalseConstant
code-creation,BytecodeHandler,0,31308,0x10f4ebe20,136,JumpIfToBooleanTrue
code-creation,BytecodeHandler,0,31317,0x10f4ebec0,136,JumpIfToBooleanFalse
code-creation,BytecodeHandler,0,31327,0x10f4ebf60,64,JumpIfTrue
code-creation,BytecodeHandler,0,31336,0x10f4ebfc0,64,JumpIfFalse
code-creation,BytecodeHandler,0,31345,0x10f4ec020,64,JumpIfNull
code-creation,BytecodeHandler,0,31353,0x10f4ec080,64,JumpIfNotNull
code-creation,BytecodeHandler,0,31363,0x10f4ec0e0,64,JumpIfUndefined
code-creation,BytecodeHandler,0,31372,0x10f4ec140,64,JumpIfNotUndefined
tick,0x10e98ec08,31389,0,0x0,6
tick,0x7fff203e5158,31412,0,0x0,6
code-creation,BytecodeHandler,0,31427,0x10f4ec1a0,72,JumpIfUndefinedOrNull
code-creation,BytecodeHandler,0,31439,0x10f4ec200,76,JumpIfJSReceiver
code-creation,BytecodeHandler,0,31447,0x10f4ec260,108,SwitchOnSmiNoFeedback
code-creation,BytecodeHandler,0,31455,0x10f4ec2e0,464,ForInEnumerate
code-creation,BytecodeHandler,0,31462,0x10f4ec4c0,252,ForInPrepare
code-creation,BytecodeHandler,0,31469,0x10f4ec5c0,60,ForInContinue
code-creation,BytecodeHandler,0,31475,0x10f4ec600,256,ForInNext
code-creation,BytecodeHandler,0,31483,0x10f4ec720,48,ForInStep
code-creation,BytecodeHandler,0,31489,0x10f4ec760,36,SetPendingMessage
code-creation,BytecodeHandler,0,31497,0x10f4ec7a0,116,Throw
code-creation,BytecodeHandler,0,31503,0x10f4ec820,116,ReThrow
code-creation,BytecodeHandler,0,31510,0x10f4ec8a0,112,Return
code-creation,BytecodeHandler,0,31516,0x10f4ec920,196,ThrowReferenceErrorIfHole
code-creation,BytecodeHandler,0,31524,0x10f4eca00,132,ThrowSuperNotCalledIfHole
code-creation,BytecodeHandler,0,31532,0x10f4ecaa0,132,ThrowSuperAlreadyCalledIfNotHole
code-creation,BytecodeHandler,0,31540,0x10f4ecb40,156,ThrowIfNotSuperConstructor
code-creation,BytecodeHandler,0,31548,0x10f4ecbe0,120,SwitchOnGeneratorState
code-creation,BytecodeHandler,0,31555,0x10f4ecc60,500,SuspendGenerator
code-creation,BytecodeHandler,0,31562,0x10f4ece60,128,ResumeGenerator
code-creation,BytecodeHandler,0,31569,0x10f4ecf00,152,GetIterator
code-creation,BytecodeHandler,0,31576,0x10f4ecfa0,116,Debugger
code-creation,BytecodeHandler,0,31582,0x10f4ed020,124,IncBlockCounter
code-creation,BytecodeHandler,0,31589,0x10f4ed0a0,56,Abort
code-creation,BytecodeHandler,0,31596,0x10f4ed0e0,32,Star0
code-creation,BytecodeHandler,0,31602,0x10f4ed120,60,Illegal
code-creation,BytecodeHandler,0,31609,0x10f4ed160,108,DebugBreak1.Wide
code-creation,BytecodeHandler,0,31617,0x10f4ed1e0,108,DebugBreak2.Wide
code-creation,BytecodeHandler,0,31624,0x10f4ed260,108,DebugBreak3.Wide
code-creation,BytecodeHandler,0,31631,0x10f4ed2e0,108,DebugBreak4.Wide
code-creation,BytecodeHandler,0,31638,0x10f4ed360,108,DebugBreak5.Wide
code-creation,BytecodeHandler,0,31645,0x10f4ed3e0,108,DebugBreak6.Wide
code-creation,BytecodeHandler,0,31652,0x10f4ed460,32,Ldar.Wide
code-creation,BytecodeHandler,0,31659,0x10f4ed4a0,32,LdaSmi.Wide
code-creation,BytecodeHandler,0,31666,0x10f4ed4e0,32,LdaConstant.Wide
code-creation,BytecodeHandler,0,31673,0x10f4ed520,92,LdaContextSlot.Wide
code-creation,BytecodeHandler,0,31681,0x10f4ed580,92,LdaImmutableContextSlot.Wide
code-creation,BytecodeHandler,0,31699,0x10f4ed5e0,48,LdaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,31708,0x10f4ed620,48,LdaImmutableCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,31716,0x10f4ed660,32,Star.Wide
code-creation,BytecodeHandler,0,31723,0x10f4ed6a0,40,Mov.Wide
code-creation,BytecodeHandler,0,31730,0x10f4ed6e0,40,PushContext.Wide
code-creation,BytecodeHandler,0,31737,0x10f4ed720,36,PopContext.Wide
code-creation,BytecodeHandler,0,31744,0x10f4ed760,48,TestReferenceEqual.Wide
code-creation,BytecodeHandler,0,31752,0x10f4ed7a0,4668,LdaGlobal.Wide
code-creation,BytecodeHandler,0,31759,0x10f4ee9e0,4604,LdaGlobalInsideTypeof.Wide
code-creation,BytecodeHandler,0,31767,0x10f4efbe0,172,StaGlobal.Wide
code-creation,BytecodeHandler,0,31774,0x10f4efca0,156,StaContextSlot.Wide
code-creation,BytecodeHandler,0,31781,0x10f4efd40,112,StaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,31789,0x10f4efdc0,128,LdaLookupSlot.Wide
code-creation,BytecodeHandler,0,31796,0x10f4efe60,244,LdaLookupContextSlot.Wide
code-creation,BytecodeHandler,0,31804,0x10f4eff60,4852,LdaLookupGlobalSlot.Wide
code-creation,BytecodeHandler,0,31812,0x10f4f1260,128,LdaLookupSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,31820,0x10f4f1300,244,LdaLookupContextSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,31829,0x10f4f1400,4812,LdaLookupGlobalSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,31838,0x10f4f26e0,220,StaLookupSlot.Wide
code-creation,BytecodeHandler,0,31845,0x10f4f27c0,5208,LdaNamedProperty.Wide
code-creation,BytecodeHandler,0,31852,0x10f4f3c20,188,LdaNamedPropertyFromSuper.Wide
code-creation,BytecodeHandler,0,31860,0x10f4f3ce0,160,LdaKeyedProperty.Wide
code-creation,BytecodeHandler,0,31868,0x10f4f3da0,160,LdaModuleVariable.Wide
code-creation,BytecodeHandler,0,31875,0x10f4f3e60,296,StaModuleVariable.Wide
code-creation,BytecodeHandler,0,31882,0x10f4f3fa0,176,StaNamedProperty.Wide
code-creation,BytecodeHandler,0,31889,0x10f4f4060,176,StaNamedOwnProperty.Wide
code-creation,BytecodeHandler,0,31897,0x10f4f4120,168,StaKeyedProperty.Wide
code-creation,BytecodeHandler,0,31904,0x10f4f41e0,168,StaInArrayLiteral.Wide
code-creation,BytecodeHandler,0,31912,0x10f4f42a0,200,StaDataPropertyInLiteral.Wide
code-creation,BytecodeHandler,0,31920,0x10f4f4380,164,CollectTypeProfile.Wide
code-creation,BytecodeHandler,0,31927,0x10f4f4440,984,Add.Wide
code-creation,BytecodeHandler,0,31934,0x10f4f4820,1020,Sub.Wide
code-creation,BytecodeHandler,0,31941,0x10f4f4c20,972,Mul.Wide
code-creation,BytecodeHandler,0,31948,0x10f4f5000,988,Div.Wide
code-creation,BytecodeHandler,0,31954,0x10f4f53e0,916,Mod.Wide
code-creation,BytecodeHandler,0,31961,0x10f4f5780,984,Exp.Wide
code-creation,BytecodeHandler,0,31968,0x10f4f5b60,904,BitwiseOr.Wide
code-creation,BytecodeHandler,0,31975,0x10f4f5f00,920,BitwiseXor.Wide
code-creation,BytecodeHandler,0,31982,0x10f4f62a0,920,BitwiseAnd.Wide
code-creation,BytecodeHandler,0,31989,0x10f4f6640,932,ShiftLeft.Wide
code-creation,BytecodeHandler,0,31996,0x10f4f6a00,932,ShiftRight.Wide
code-creation,BytecodeHandler,0,32003,0x10f4f6dc0,1052,ShiftRightLogical.Wide
code-creation,BytecodeHandler,0,32010,0x10f4f71e0,916,AddSmi.Wide
code-creation,BytecodeHandler,0,32017,0x10f4f7580,960,SubSmi.Wide
code-creation,BytecodeHandler,0,32024,0x10f4f7960,912,MulSmi.Wide
code-creation,BytecodeHandler,0,32031,0x10f4f7d00,920,DivSmi.Wide
code-creation,BytecodeHandler,0,32037,0x10f4f80a0,816,ModSmi.Wide
code-creation,BytecodeHandler,0,32044,0x10f4f83e0,868,ExpSmi.Wide
code-creation,BytecodeHandler,0,32051,0x10f4f8760,496,BitwiseOrSmi.Wide
code-creation,BytecodeHandler,0,32058,0x10f4f8960,496,BitwiseXorSmi.Wide
code-creation,BytecodeHandler,0,32066,0x10f4f8b60,496,BitwiseAndSmi.Wide
code-creation,BytecodeHandler,0,32073,0x10f4f8d60,496,ShiftLeftSmi.Wide
code-creation,BytecodeHandler,0,32080,0x10f4f8f60,496,ShiftRightSmi.Wide
code-creation,BytecodeHandler,0,32087,0x10f4f9160,648,ShiftRightLogicalSmi.Wide
code-creation,BytecodeHandler,0,32095,0x10f4f9400,616,Inc.Wide
code-creation,BytecodeHandler,0,32102,0x10f4f9680,616,Dec.Wide
code-creation,BytecodeHandler,0,32117,0x10f4f9900,648,Negate.Wide
code-creation,BytecodeHandler,0,32124,0x10f4f9ba0,492,BitwiseNot.Wide
code-creation,BytecodeHandler,0,32132,0x10f4f9da0,124,DeletePropertyStrict.Wide
code-creation,BytecodeHandler,0,32140,0x10f4f9e20,116,DeletePropertySloppy.Wide
code-creation,BytecodeHandler,0,32148,0x10f4f9ea0,40,GetSuperConstructor.Wide
code-creation,BytecodeHandler,0,32155,0x10f4f9ee0,1124,CallAnyReceiver.Wide
code-creation,BytecodeHandler,0,32163,0x10f4fa360,1124,CallProperty.Wide
code-creation,BytecodeHandler,0,32170,0x10f4fa7e0,1012,CallProperty0.Wide
code-creation,BytecodeHandler,0,32177,0x10f4fabe0,1024,CallProperty1.Wide
code-creation,BytecodeHandler,0,32184,0x10f4fb000,1036,CallProperty2.Wide
code-creation,BytecodeHandler,0,32191,0x10f4fb420,1004,CallUndefinedReceiver.Wide
code-creation,BytecodeHandler,0,32199,0x10f4fb820,1044,CallUndefinedReceiver0.Wide
code-creation,BytecodeHandler,0,32208,0x10f4fbc40,1020,CallUndefinedReceiver1.Wide
code-creation,BytecodeHandler,0,32216,0x10f4fc040,1036,CallUndefinedReceiver2.Wide
code-creation,BytecodeHandler,0,32223,0x10f4fc460,1124,CallWithSpread.Wide
code-creation,BytecodeHandler,0,32231,0x10f4fc8e0,128,CallRuntime.Wide
code-creation,BytecodeHandler,0,32238,0x10f4fc980,168,CallRuntimeForPair.Wide
code-creation,BytecodeHandler,0,32246,0x10f4fca40,84,CallJSRuntime.Wide
code-creation,BytecodeHandler,0,32253,0x10f4fcaa0,1240,InvokeIntrinsic.Wide
code-creation,BytecodeHandler,0,32260,0x10f4fcf80,960,Construct.Wide
code-creation,BytecodeHandler,0,32277,0x10f4fd360,472,ConstructWithSpread.Wide
code-creation,BytecodeHandler,0,32288,0x10f4fd540,1964,TestEqual.Wide
code-creation,BytecodeHandler,0,32297,0x10f4fdd00,1068,TestEqualStrict.Wide
code-creation,BytecodeHandler,0,32306,0x10f4fe140,1512,TestLessThan.Wide
code-creation,BytecodeHandler,0,32316,0x10f4fe740,1512,TestGreaterThan.Wide
code-creation,BytecodeHandler,0,32325,0x10f4fed40,1512,TestLessThanOrEqual.Wide
code-creation,BytecodeHandler,0,32335,0x10f4ff340,1512,TestGreaterThanOrEqual.Wide
code-creation,BytecodeHandler,0,32345,0x10f4ff940,864,TestInstanceOf.Wide
code-creation,BytecodeHandler,0,32355,0x10f4ffcc0,160,TestIn.Wide
code-creation,BytecodeHandler,0,32364,0x10f4ffd80,116,ToName.Wide
code-creation,BytecodeHandler,0,32373,0x10f4ffe00,216,ToNumber.Wide
code-creation,BytecodeHandler,0,32382,0x10f4ffee0,236,ToNumeric.Wide
code-creation,BytecodeHandler,0,32391,0x10f4fffe0,116,ToObject.Wide
code-creation,BytecodeHandler,0,32400,0x10f500060,404,CreateRegExpLiteral.Wide
code-creation,BytecodeHandler,0,32410,0x10f500200,1372,CreateArrayLiteral.Wide
code-creation,BytecodeHandler,0,32420,0x10f500760,792,CreateEmptyArrayLiteral.Wide
code-creation,BytecodeHandler,0,32430,0x10f500a80,2060,CreateObjectLiteral.Wide
code-creation,BytecodeHandler,0,32440,0x10f5012a0,172,CloneObject.Wide
code-creation,BytecodeHandler,0,32450,0x10f501360,164,GetTemplateObject.Wide
code-creation,BytecodeHandler,0,32459,0x10f501420,320,CreateClosure.Wide
code-creation,BytecodeHandler,0,32468,0x10f501580,124,CreateBlockContext.Wide
code-creation,BytecodeHandler,0,32478,0x10f501600,136,CreateCatchContext.Wide
code-creation,BytecodeHandler,0,32488,0x10f5016a0,256,CreateFunctionContext.Wide
code-creation,BytecodeHandler,0,32497,0x10f5017c0,256,CreateEvalContext.Wide
code-creation,BytecodeHandler,0,32507,0x10f5018e0,136,CreateWithContext.Wide
code-creation,BytecodeHandler,0,32516,0x10f501980,440,JumpLoop.Wide
code-creation,BytecodeHandler,0,32524,0x10f501b40,44,Jump.Wide
code-creation,BytecodeHandler,0,32533,0x10f501b80,56,JumpConstant.Wide
code-creation,BytecodeHandler,0,32542,0x10f501bc0,80,JumpIfNullConstant.Wide
code-creation,BytecodeHandler,0,32552,0x10f501c20,80,JumpIfNotNullConstant.Wide
code-creation,BytecodeHandler,0,32562,0x10f501c80,80,JumpIfUndefinedConstant.Wide
code-creation,BytecodeHandler,0,32572,0x10f501ce0,80,JumpIfNotUndefinedConstant.Wide
code-creation,BytecodeHandler,0,32582,0x10f501d40,84,JumpIfUndefinedOrNullConstant.Wide
code-creation,BytecodeHandler,0,32593,0x10f501da0,80,JumpIfTrueConstant.Wide
code-creation,BytecodeHandler,0,32613,0x10f501e00,80,JumpIfFalseConstant.Wide
code-creation,BytecodeHandler,0,32623,0x10f501e60,88,JumpIfJSReceiverConstant.Wide
code-creation,BytecodeHandler,0,32633,0x10f501ec0,152,JumpIfToBooleanTrueConstant.Wide
code-creation,BytecodeHandler,0,32644,0x10f501f60,152,JumpIfToBooleanFalseConstant.Wide
code-creation,BytecodeHandler,0,32654,0x10f502000,136,JumpIfToBooleanTrue.Wide
code-creation,BytecodeHandler,0,32664,0x10f5020a0,136,JumpIfToBooleanFalse.Wide
code-creation,BytecodeHandler,0,32674,0x10f502140,64,JumpIfTrue.Wide
code-creation,BytecodeHandler,0,32684,0x10f5021a0,64,JumpIfFalse.Wide
code-creation,BytecodeHandler,0,32694,0x10f502200,64,JumpIfNull.Wide
code-creation,BytecodeHandler,0,32703,0x10f502260,64,JumpIfNotNull.Wide
code-creation,BytecodeHandler,0,32712,0x10f5022c0,64,JumpIfUndefined.Wide
code-creation,BytecodeHandler,0,32722,0x10f502320,64,JumpIfNotUndefined.Wide
code-creation,BytecodeHandler,0,32731,0x10f502380,72,JumpIfUndefinedOrNull.Wide
code-creation,BytecodeHandler,0,32741,0x10f5023e0,76,JumpIfJSReceiver.Wide
code-creation,BytecodeHandler,0,32751,0x10f502440,108,SwitchOnSmiNoFeedback.Wide
code-creation,BytecodeHandler,0,32760,0x10f5024c0,468,ForInEnumerate.Wide
code-creation,BytecodeHandler,0,32770,0x10f5026a0,252,ForInPrepare.Wide
code-creation,BytecodeHandler,0,32779,0x10f5027a0,60,ForInContinue.Wide
code-creation,BytecodeHandler,0,32788,0x10f5027e0,260,ForInNext.Wide
code-creation,BytecodeHandler,0,32797,0x10f502900,48,ForInStep.Wide
code-creation,BytecodeHandler,0,32806,0x10f502940,156,ThrowReferenceErrorIfHole.Wide
code-creation,BytecodeHandler,0,32816,0x10f5029e0,160,ThrowIfNotSuperConstructor.Wide
code-creation,BytecodeHandler,0,32827,0x10f502aa0,120,SwitchOnGeneratorState.Wide
code-creation,BytecodeHandler,0,32836,0x10f502b20,516,SuspendGenerator.Wide
code-creation,BytecodeHandler,0,32846,0x10f502d40,128,ResumeGenerator.Wide
code-creation,BytecodeHandler,0,32855,0x10f502de0,156,GetIterator.Wide
code-creation,BytecodeHandler,0,32865,0x10f502e80,128,IncBlockCounter.Wide
code-creation,BytecodeHandler,0,32874,0x10f502f20,56,Abort.Wide
code-creation,BytecodeHandler,0,32883,0x10f502f60,108,DebugBreak1.ExtraWide
code-creation,BytecodeHandler,0,32892,0x10f502fe0,108,DebugBreak2.ExtraWide
code-creation,BytecodeHandler,0,32901,0x10f503060,108,DebugBreak3.ExtraWide
code-creation,BytecodeHandler,0,32911,0x10f5030e0,108,DebugBreak4.ExtraWide
code-creation,BytecodeHandler,0,32920,0x10f503160,108,DebugBreak5.ExtraWide
code-creation,BytecodeHandler,0,32929,0x10f5031e0,108,DebugBreak6.ExtraWide
code-creation,BytecodeHandler,0,32939,0x10f503260,32,Ldar.ExtraWide
code-creation,BytecodeHandler,0,32948,0x10f5032a0,28,LdaSmi.ExtraWide
code-creation,BytecodeHandler,0,32957,0x10f5032c0,32,LdaConstant.ExtraWide
code-creation,BytecodeHandler,0,32967,0x10f503300,88,LdaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,32976,0x10f503360,88,LdaImmutableContextSlot.ExtraWide
code-creation,BytecodeHandler,0,32987,0x10f5033c0,48,LdaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,32998,0x10f503400,48,LdaImmutableCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,33008,0x10f503440,28,Star.ExtraWide
code-creation,BytecodeHandler,0,33017,0x10f503460,40,Mov.ExtraWide
code-creation,BytecodeHandler,0,33026,0x10f5034a0,36,PushContext.ExtraWide
code-creation,BytecodeHandler,0,33036,0x10f5034e0,32,PopContext.ExtraWide
code-creation,BytecodeHandler,0,33045,0x10f503520,48,TestReferenceEqual.ExtraWide
code-creation,BytecodeHandler,0,33055,0x10f503560,4656,LdaGlobal.ExtraWide
code-creation,BytecodeHandler,0,33064,0x10f5047a0,4592,LdaGlobalInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,33074,0x10f5059a0,168,StaGlobal.ExtraWide
code-creation,BytecodeHandler,0,33083,0x10f505a60,152,StaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,33093,0x10f505b00,108,StaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,33103,0x10f505b80,128,LdaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,33114,0x10f505c20,240,LdaLookupContextSlot.ExtraWide
code-creation,BytecodeHandler,0,33132,0x10f505d20,4836,LdaLookupGlobalSlot.ExtraWide
code-creation,BytecodeHandler,0,33143,0x10f507020,128,LdaLookupSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,33154,0x10f5070c0,240,LdaLookupContextSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,33165,0x10f5071c0,4800,LdaLookupGlobalSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,33176,0x10f5084a0,220,StaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,33185,0x10f508580,5188,LdaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,33195,0x10f5099e0,184,LdaNamedPropertyFromSuper.ExtraWide
code-creation,BytecodeHandler,0,33206,0x10f509aa0,156,LdaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,33216,0x10f509b40,160,LdaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,33226,0x10f509c00,292,StaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,33236,0x10f509d40,172,StaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,33245,0x10f509e00,172,StaNamedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,33255,0x10f509ec0,168,StaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,33265,0x10f509f80,168,StaInArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,33275,0x10f50a040,196,StaDataPropertyInLiteral.ExtraWide
tick,0x7fff203b72be,33301,0,0x0,6
tick,0x7fff20215370,33312,0,0x0,6
code-creation,BytecodeHandler,0,33320,0x10f50a120,164,CollectTypeProfile.ExtraWide
code-creation,BytecodeHandler,0,33330,0x10f50a1e0,980,Add.ExtraWide
code-creation,BytecodeHandler,0,33337,0x10f50a5c0,1016,Sub.ExtraWide
code-creation,BytecodeHandler,0,33345,0x10f50a9c0,972,Mul.ExtraWide
code-creation,BytecodeHandler,0,33351,0x10f50ada0,988,Div.ExtraWide
code-creation,BytecodeHandler,0,33358,0x10f50b180,916,Mod.ExtraWide
code-creation,BytecodeHandler,0,33365,0x10f50b520,980,Exp.ExtraWide
code-creation,BytecodeHandler,0,33372,0x10f50b900,904,BitwiseOr.ExtraWide
code-creation,BytecodeHandler,0,33379,0x10f50bca0,916,BitwiseXor.ExtraWide
code-creation,BytecodeHandler,0,33387,0x10f50c040,916,BitwiseAnd.ExtraWide
code-creation,BytecodeHandler,0,33394,0x10f50c3e0,928,ShiftLeft.ExtraWide
code-creation,BytecodeHandler,0,33401,0x10f50c7a0,928,ShiftRight.ExtraWide
code-creation,BytecodeHandler,0,33408,0x10f50cb60,1048,ShiftRightLogical.ExtraWide
code-creation,BytecodeHandler,0,33416,0x10f50cf80,916,AddSmi.ExtraWide
code-creation,BytecodeHandler,0,33424,0x10f50d320,960,SubSmi.ExtraWide
code-creation,BytecodeHandler,0,33431,0x10f50d700,912,MulSmi.ExtraWide
code-creation,BytecodeHandler,0,33437,0x10f50daa0,916,DivSmi.ExtraWide
code-creation,BytecodeHandler,0,33444,0x10f50de40,816,ModSmi.ExtraWide
code-creation,BytecodeHandler,0,33451,0x10f50e180,868,ExpSmi.ExtraWide
code-creation,BytecodeHandler,0,33459,0x10f50e500,492,BitwiseOrSmi.ExtraWide
code-creation,BytecodeHandler,0,33466,0x10f50e700,492,BitwiseXorSmi.ExtraWide
code-creation,BytecodeHandler,0,33474,0x10f50e900,492,BitwiseAndSmi.ExtraWide
code-creation,BytecodeHandler,0,33482,0x10f50eb00,492,ShiftLeftSmi.ExtraWide
code-creation,BytecodeHandler,0,33489,0x10f50ed00,492,ShiftRightSmi.ExtraWide
code-creation,BytecodeHandler,0,33497,0x10f50ef00,644,ShiftRightLogicalSmi.ExtraWide
code-creation,BytecodeHandler,0,33505,0x10f50f1a0,616,Inc.ExtraWide
code-creation,BytecodeHandler,0,33512,0x10f50f420,616,Dec.ExtraWide
code-creation,BytecodeHandler,0,33519,0x10f50f6a0,644,Negate.ExtraWide
code-creation,BytecodeHandler,0,33526,0x10f50f940,488,BitwiseNot.ExtraWide
code-creation,BytecodeHandler,0,33534,0x10f50fb40,124,DeletePropertyStrict.ExtraWide
code-creation,BytecodeHandler,0,33542,0x10f50fbc0,116,DeletePropertySloppy.ExtraWide
code-creation,BytecodeHandler,0,33550,0x10f50fc40,36,GetSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,33559,0x10f50fc80,1120,CallAnyReceiver.ExtraWide
code-creation,BytecodeHandler,0,33566,0x10f510100,1120,CallProperty.ExtraWide
code-creation,BytecodeHandler,0,33574,0x10f510580,1004,CallProperty0.ExtraWide
code-creation,BytecodeHandler,0,33581,0x10f510980,1020,CallProperty1.ExtraWide
code-creation,BytecodeHandler,0,33590,0x10f510d80,1032,CallProperty2.ExtraWide
code-creation,BytecodeHandler,0,33607,0x10f5111a0,1000,CallUndefinedReceiver.ExtraWide
code-creation,BytecodeHandler,0,33616,0x10f5115a0,1044,CallUndefinedReceiver0.ExtraWide
code-creation,BytecodeHandler,0,33624,0x10f5119c0,1016,CallUndefinedReceiver1.ExtraWide
code-creation,BytecodeHandler,0,33632,0x10f511dc0,1028,CallUndefinedReceiver2.ExtraWide
code-creation,BytecodeHandler,0,33641,0x10f5121e0,1120,CallWithSpread.ExtraWide
code-creation,BytecodeHandler,0,33648,0x10f512660,128,CallRuntime.ExtraWide
code-creation,BytecodeHandler,0,33656,0x10f512700,164,CallRuntimeForPair.ExtraWide
code-creation,BytecodeHandler,0,33664,0x10f5127c0,80,CallJSRuntime.ExtraWide
code-creation,BytecodeHandler,0,33676,0x10f512820,1240,InvokeIntrinsic.ExtraWide
code-creation,BytecodeHandler,0,33684,0x10f512d00,956,Construct.ExtraWide
code-creation,BytecodeHandler,0,33692,0x10f5130c0,468,ConstructWithSpread.ExtraWide
code-creation,BytecodeHandler,0,33700,0x10f5132a0,1964,TestEqual.ExtraWide
code-creation,BytecodeHandler,0,33708,0x10f513a60,1068,TestEqualStrict.ExtraWide
code-creation,BytecodeHandler,0,33715,0x10f513ea0,1508,TestLessThan.ExtraWide
code-creation,BytecodeHandler,0,33723,0x10f5144a0,1508,TestGreaterThan.ExtraWide
code-creation,BytecodeHandler,0,33731,0x10f514aa0,1508,TestLessThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,33739,0x10f5150a0,1508,TestGreaterThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,33748,0x10f5156a0,860,TestInstanceOf.ExtraWide
code-creation,BytecodeHandler,0,33755,0x10f515a00,156,TestIn.ExtraWide
code-creation,BytecodeHandler,0,33762,0x10f515aa0,116,ToName.ExtraWide
code-creation,BytecodeHandler,0,33769,0x10f515b20,216,ToNumber.ExtraWide
code-creation,BytecodeHandler,0,33776,0x10f515c00,236,ToNumeric.ExtraWide
code-creation,BytecodeHandler,0,33784,0x10f515d00,116,ToObject.ExtraWide
code-creation,BytecodeHandler,0,33791,0x10f515d80,400,CreateRegExpLiteral.ExtraWide
code-creation,BytecodeHandler,0,33799,0x10f515f20,1368,CreateArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,33807,0x10f516480,792,CreateEmptyArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,33816,0x10f5167a0,2060,CreateObjectLiteral.ExtraWide
code-creation,BytecodeHandler,0,33824,0x10f516fc0,168,CloneObject.ExtraWide
code-creation,BytecodeHandler,0,33831,0x10f517080,160,GetTemplateObject.ExtraWide
code-creation,BytecodeHandler,0,33839,0x10f517140,320,CreateClosure.ExtraWide
code-creation,BytecodeHandler,0,33847,0x10f5172a0,124,CreateBlockContext.ExtraWide
code-creation,BytecodeHandler,0,33855,0x10f517320,132,CreateCatchContext.ExtraWide
code-creation,BytecodeHandler,0,33863,0x10f5173c0,256,CreateFunctionContext.ExtraWide
code-creation,BytecodeHandler,0,33871,0x10f5174e0,256,CreateEvalContext.ExtraWide
code-creation,BytecodeHandler,0,33879,0x10f517600,132,CreateWithContext.ExtraWide
code-creation,BytecodeHandler,0,33887,0x10f5176a0,436,JumpLoop.ExtraWide
code-creation,BytecodeHandler,0,33894,0x10f517860,44,Jump.ExtraWide
code-creation,BytecodeHandler,0,33901,0x10f5178a0,56,JumpConstant.ExtraWide
code-creation,BytecodeHandler,0,33909,0x10f5178e0,76,JumpIfNullConstant.ExtraWide
code-creation,BytecodeHandler,0,33917,0x10f517940,76,JumpIfNotNullConstant.ExtraWide
code-creation,BytecodeHandler,0,33925,0x10f5179a0,76,JumpIfUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,33934,0x10f517a00,76,JumpIfNotUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,33942,0x10f517a60,84,JumpIfUndefinedOrNullConstant.ExtraWide
code-creation,BytecodeHandler,0,33951,0x10f517ac0,76,JumpIfTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,33959,0x10f517b20,76,JumpIfFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,33979,0x10f517b80,88,JumpIfJSReceiverConstant.ExtraWide
code-creation,BytecodeHandler,0,34005,0x10f517be0,148,JumpIfToBooleanTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,34015,0x10f517c80,148,JumpIfToBooleanFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,34025,0x10f517d20,136,JumpIfToBooleanTrue.ExtraWide
code-creation,BytecodeHandler,0,34033,0x10f517dc0,136,JumpIfToBooleanFalse.ExtraWide
code-creation,BytecodeHandler,0,34054,0x10f517e60,64,JumpIfTrue.ExtraWide
code-creation,BytecodeHandler,0,34063,0x10f517ec0,64,JumpIfFalse.ExtraWide
code-creation,BytecodeHandler,0,34071,0x10f517f20,64,JumpIfNull.ExtraWide
code-creation,BytecodeHandler,0,34079,0x10f517f80,64,JumpIfNotNull.ExtraWide
code-creation,BytecodeHandler,0,34087,0x10f517fe0,64,JumpIfUndefined.ExtraWide
code-creation,BytecodeHandler,0,34095,0x10f518040,64,JumpIfNotUndefined.ExtraWide
code-creation,BytecodeHandler,0,34103,0x10f5180a0,68,JumpIfUndefinedOrNull.ExtraWide
code-creation,BytecodeHandler,0,34111,0x10f518100,72,JumpIfJSReceiver.ExtraWide
code-creation,BytecodeHandler,0,34193,0x10f518160,108,SwitchOnSmiNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,34205,0x10f5181e0,464,ForInEnumerate.ExtraWide
code-creation,BytecodeHandler,0,34213,0x10f5183c0,252,ForInPrepare.ExtraWide
code-creation,BytecodeHandler,0,34221,0x10f5184c0,56,ForInContinue.ExtraWide
code-creation,BytecodeHandler,0,34236,0x10f518500,256,ForInNext.ExtraWide
code-creation,BytecodeHandler,0,34246,0x10f518620,44,ForInStep.ExtraWide
code-creation,BytecodeHandler,0,34259,0x10f518660,156,ThrowReferenceErrorIfHole.ExtraWide
code-creation,BytecodeHandler,0,34269,0x10f518700,160,ThrowIfNotSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,34277,0x10f5187c0,120,SwitchOnGeneratorState.ExtraWide
code-creation,BytecodeHandler,0,34294,0x10f518840,512,SuspendGenerator.ExtraWide
code-creation,BytecodeHandler,0,34303,0x10f518a60,124,ResumeGenerator.ExtraWide
code-creation,BytecodeHandler,0,34311,0x10f518ae0,152,GetIterator.ExtraWide
code-creation,BytecodeHandler,0,34318,0x10f518b80,124,IncBlockCounter.ExtraWide
code-creation,BytecodeHandler,0,34326,0x10f518c00,56,Abort.ExtraWide
tick,0x10e9be5b0,35832,0,0x0,6
new,MemoryChunk,0x1eeafbf00000,262144
tick,0x10ef78b80,36930,0,0x0,5
new,MemoryChunk,0x1eea11d80000,262144
tick,0x10fa344e5,38174,0,0x0,5
tick,0x10f0e065c,39185,0,0x0,5
new,MemoryChunk,0x1eea3b180000,262144
new,MemoryChunk,0x1eea47840000,262144
tick,0x10f0df37e,40263,0,0x0,5
tick,0x10efb36e9,41525,0,0x0,5
tick,0x10ef6e840,42559,0,0x0,5
tick,0x10ef38a50,43822,0,0x0,5
tick,0x10e957a50,45077,0,0x0,6
tick,0x10ec5d6f0,46343,0,0x0,6
tick,0x10f127620,47389,0,0x0,6
tick,0x7fff203b6cde,48662,0,0x0,6
tick,0x10ecafac0,49787,0,0x0,5
tick,0x10efecfe0,51145,0,0x0,3
tick,0x10f9e8d86,52155,0,0x0,2
tick,0x10f0114a0,53365,0,0x0,2
tick,0x10f9e9133,54656,0,0x0,2
tick,0x10ee2ce0e,55769,0,0x0,3
code-creation,LazyCompile,10,56638,0x1eea4787bb46,380,emit node:events:340:44,0x1eeab58f2b80,~
script-source,13,node:events,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  Boolean\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  MathMin\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  PromiseResolve\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolAsyncIterator\x2C\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\nconst { inspect } = require('internal/util/inspect');\n\nlet spliceOne;\n\nconst {\n  AbortError\x2C\n  kEnhanceStackBeforeInspector\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNHANDLED_ERROR\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @returns {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this\x2C opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter\x2C 'captureRejections'\x2C {\n  get() {\n    return EventEmitter.prototype[kCapture];\n  }\x2C\n  set(value) {\n    validateBoolean(value\x2C 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  }\x2C\n  enumerable: true\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype\x2C kCapture\x2C {\n  value: false\x2C\n  writable: true\x2C\n  enumerable: false\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\nlet isEventTarget;\n\nfunction checkListener(listener) {\n  validateFunction(listener\x2C 'listener');\n}\n\nObjectDefineProperty(EventEmitter\x2C 'defaultMaxListeners'\x2C {\n  enumerable: true\x2C\n  get: function() {\n    return defaultMaxListeners;\n  }\x2C\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners'\x2C\n                                 'a non-negative number'\x2C\n                                 arg);\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nObjectDefineProperties(EventEmitter\x2C {\n  kMaxEventTargetListeners: {\n    value: kMaxEventTargetListeners\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\x2C\n  kMaxEventTargetListenersWarned: {\n    value: kMaxEventTargetListenersWarned\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners\x2C ...eventTargets) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n))\n      throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      if (isEventTarget === undefined)\n        isEventTarget = require('internal/event_target').isEventTarget;\n\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets'\x2C\n            ['EventEmitter'\x2C 'EventTarget']\x2C\n            target);\n        }\n      }\n    }\n  };\n\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections\x2C 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that\x2C promise\x2C type\x2C args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec\x2C then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise\x2C undefined\x2C function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr\x2C that\x2C err\x2C type\x2C args);\n      });\n    }\n  } catch (err) {\n    that.emit('error'\x2C err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee\x2C err\x2C type\x2C args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err\x2C type\x2C ...args);\n  } else {\n    // We have to disable the capture rejections mechanism\x2C otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws\x2C it is not catcheable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error'\x2C err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\n// Returns the length and line number of the first sequence of `a` that fully\n// appears in `b` with a length of at least 4.\nfunction identicalSequenceRange(a\x2C b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = ArrayPrototypeIndexOf(b\x2C a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i\x2C rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return [len\x2C i];\n        }\n      }\n    }\n  }\n\n  return [0\x2C 0];\n}\n\nfunction enhanceStackTrace(err\x2C own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {}\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(err.stack\x2C '\\n')\x2C 1);\n  const ownStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(own.stack\x2C '\\n')\x2C 1);\n\n  const { 0: len\x2C 1: off } = identicalSequenceRange(ownStack\x2C errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack\x2C off + 1\x2C len - 2\x2C\n                         '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ArrayPrototypeJoin(ownStack\x2C '\\n');\n}\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type\x2C ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor\x2C ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture\x2C EventEmitter.prototype.emit);\n        ObjectDefineProperty(er\x2C kEnhanceStackBeforeInspector\x2C {\n          value: FunctionPrototypeBind(enhanceStackTrace\x2C this\x2C er\x2C capture)\x2C\n          configurable: true\n        });\n      } catch {}\n\n      // Note: The comments on the `throw` lines are intentional\x2C they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this\x2C args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this\x2C result\x2C type\x2C args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this\x2C args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this\x2C result\x2C type\x2C args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target\x2C type\x2C listener\x2C prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === "newListener"! Before\n    // adding it to the listeners\x2C first emit "newListener".\n    if (events.newListener !== undefined) {\n      target.emit('newListener'\x2C type\x2C\n                  listener.listener ?? listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element\x2C need to change to array.\n      existing = events[type] =\n        prepend ? [listener\x2C existing] : [existing\x2C listener];\n      // If we've already got an array\x2C just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventEmitter memory leak detected. ' +\n                          `${existing.length} ${String(type)} listeners ` +\n                          `added to ${inspect(target\x2C { depth: -1 })}. Use ` +\n                          'emitter.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type\x2C listener) {\n  return _addListener(this\x2C type\x2C listener\x2C false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type\x2C listener) {\n      return _addListener(this\x2C type\x2C listener\x2C true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type\x2C this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target\x2C arguments);\n  }\n}\n\nfunction _onceWrap(target\x2C type\x2C listener) {\n  const state = { fired: false\x2C wrapFn: undefined\x2C target\x2C type\x2C listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type\x2C listener) {\n  checkListener(listener);\n\n  this.on(type\x2C _onceWrap(this\x2C type\x2C listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type\x2C listener) {\n      checkListener(listener);\n\n      this.prependListener(type\x2C _onceWrap(this\x2C type\x2C listener));\n      return this;\n    };\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type\x2C listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = ObjectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener'\x2C type\x2C list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list\x2C position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener'\x2C type\x2C listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener\x2C no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = ObjectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = ObjectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = ObjectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type\x2C listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type\x2C listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target\x2C type\x2C unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this\x2C type\x2C true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this\x2C type\x2C false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter\x2C type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount\x2C emitter\x2C type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {number}\n */\nfunction listenerCount(type) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3\x2C this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0]\x2C arr[1]];\n    case 3: return [arr[0]\x2C arr[1]\x2C arr[2]];\n    case 4: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]];\n    case 5: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]];\n    case 6: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]\x2C arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nfunction getEventListeners(emitterOrTarget\x2C type) {\n  // First check if EventEmitter\n  if (typeof emitterOrTarget.listeners === 'function') {\n    return emitterOrTarget.listeners(type);\n  }\n  // Require event target lazily to avoid always loading it\n  const { isEventTarget\x2C kEvents } = require('internal/event_target');\n  if (isEventTarget(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners = [];\n    let handler = root?.next;\n    while (handler?.listener !== undefined) {\n      const listener = handler.listener?.deref ?\n        handler.listener.deref() : handler.listener;\n      listeners.push(listener);\n      handler = handler.next;\n    }\n    return listeners;\n  }\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\n                                 emitterOrTarget);\n}\n\n/**\n * Creates a `Promise` that is fulfilled when the emitter\n * emits the given event.\n * @param {EventEmitter} emitter\n * @param {string} name\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {Promise}\n */\nasync function once(emitter\x2C name\x2C options = {}) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError();\n  return new Promise((resolve\x2C reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name\x2C resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error'\x2C errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      resolve(args);\n    };\n    eventTargetAgnosticAddListener(emitter\x2C name\x2C resolver\x2C { once: true });\n    if (name !== 'error' && typeof emitter.once === 'function') {\n      emitter.once('error'\x2C errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter\x2C name\x2C resolver);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorListener);\n      reject(new AbortError());\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(\n        signal\x2C 'abort'\x2C abortListener\x2C { once: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value\x2C done) {\n  return { value\x2C done };\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name\x2C listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags?.once) {\n      emitter.once(name\x2C listener);\n    } else {\n      emitter.on(name\x2C listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters\x2C we do not listen to `error` events here.\n    emitter.addEventListener(name\x2C (arg) => { listener(arg); }\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\n/**\n * Returns an `AsyncIterator` that iterates `event` events.\n * @param {EventEmitter} emitter\n * @param {string | symbol} event\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {AsyncIterator}\n */\nfunction on(emitter\x2C event\x2C options) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError();\n\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  let error = null;\n  let finished = false;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First\x2C we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value) {\n        return PromiseResolve(createIterResult(value\x2C false));\n      }\n\n      // Then we error\x2C if an error happened\n      // This happens one time if at all\x2C because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished\x2C resolve to done\n      if (finished) {\n        return PromiseResolve(createIterResult(undefined\x2C true));\n      }\n\n      // Wait until an event happens\n      return new Promise(function(resolve\x2C reject) {\n        unconsumedPromises.push({ resolve\x2C reject });\n      });\n    }\x2C\n\n    return() {\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n\n      if (signal) {\n        eventTargetAgnosticRemoveListener(\n          signal\x2C\n          'abort'\x2C\n          abortListener\x2C\n          { once: true });\n      }\n\n      finished = true;\n\n      for (const promise of unconsumedPromises) {\n        promise.resolve(createIterResult(undefined\x2C true));\n      }\n\n      return PromiseResolve(createIterResult(undefined\x2C true));\n    }\x2C\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator'\x2C\n                                       'Error'\x2C err);\n      }\n      error = err;\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n    }\x2C\n\n    [SymbolAsyncIterator]() {\n      return this;\n    }\n  }\x2C AsyncIteratorPrototype);\n\n  eventTargetAgnosticAddListener(emitter\x2C event\x2C eventHandler);\n  if (event !== 'error' && typeof emitter.on === 'function') {\n    emitter.on('error'\x2C errorHandler);\n  }\n\n  if (signal) {\n    eventTargetAgnosticAddListener(\n      signal\x2C\n      'abort'\x2C\n      abortListener\x2C\n      { once: true });\n  }\n\n  return iterator;\n\n  function abortListener() {\n    errorHandler(new AbortError());\n  }\n\n  function eventHandler(...args) {\n    const promise = ArrayPrototypeShift(unconsumedPromises);\n    if (promise) {\n      promise.resolve(createIterResult(args\x2C false));\n    } else {\n      unconsumedEvents.push(args);\n    }\n  }\n\n  function errorHandler(err) {\n    finished = true;\n\n    const toError = ArrayPrototypeShift(unconsumedPromises);\n\n    if (toError) {\n      toError.reject(err);\n    } else {\n      // The next time we call next()\n      error = err;\n    }\n\n    iterator.return();\n  }\n}\n
code-source-info,0x1eea4787bb46,13,9741,11955,C0O9741C8O9775C10O9781C14O9818C19O9829C21O9861C27O9883C29O9882C34O9924C41O9929C51O9924C56O9958C60O9987C68O10018C72O10036C73O10049C74O10108C78O10131C80O10148C86O10155C91O10166C92O10175C96O10184C98O10202C100O10191C108O10247C110O10259C120O10304C126O10314C132O10259C137O10329C145O10354C157O10403C174O10403C186O10329C197O10677C199O10677C200O10729C205O10760C211O10776C219O10774C220O10809C225O10906C232O10906C238O10950C240O10962C244O10972C246O10972C247O11033C249O11039C253O11050C255O11081C256O11094C257O11098C263O11162C268O11162C275O11316C281O11369C296O11369C303O11446C308O11476C311O11476C316O11514C318O11519C320O11519C325O11554C327O11563C332O11567C337O11567C344O11829C350O11884C365O11884C370O11528C375O11501C378O11941C379O11953,,
tick,0x7fff202f9f68,58707,0,0x0,3
tick,0x7fff2035a79a,58728,0,0x0,3
tick,0x10f4d5cc0,59471,0,0x0,0,0x1eea4787bb46
tick,0x10ebc7296,60747,0,0x0,2
code-creation,Eval,10,61681,0x1eea4787e186,5, node:internal/main/run_main_module:1:1,0x1eea4787e040,~
script-source,91,node:internal/main/run_main_module,'use strict';\n\nconst {\n  prepareMainThreadExecution\n} = require('internal/bootstrap/pre_execution');\n\nprepareMainThreadExecution(true);\n\nmarkBootstrapComplete();\n\n// Note: this loads the module through the ESM loader if the module is\n// determined to be an ES module. This hangs from the CJS module loader\n// because we currently allow monkey-patching of the module loaders\n// in the preloaded scripts through require('module').\n// runMain here might be monkey-patched by users in --require.\n// XXX: the monkey-patchability here should probably be deprecated.\nrequire('internal/modules/cjs/loader').Module.runMain(process.argv[1]);\n
code-source-info,0x1eea4787e186,91,0,632,C0O0C4O632,,
code-creation,Function,10,61782,0x1eea4787e22e,58, node:internal/main/run_main_module:1:1,0x1eea4787e100,~
code-source-info,0x1eea4787e22e,91,0,632,C0O56C3O56C8O25C13O102C15O102C19O137C22O560C25O560C30O598C35O605C40O622C47O626C51O606C57O631,,
tick,0x10e98eb40,61816,0,0x0,3
code-creation,LazyCompile,10,62179,0x1eea4787e46e,76,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x1eeab58cf8f8,~
script-source,9,node:internal/bootstrap/loaders,// This file creates the internal module & binding loaders used by built-in\n// modules. In contrast\x2C user land modules are loaded using\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\n// lib/internal/modules/esm/* (ES Modules).\n//\n// This file is compiled and run by node.cc before bootstrap/node.js\n// was called\x2C therefore the loaders are bootstrapped before we start to\n// actually bootstrap Node.js. It creates the following objects:\n//\n// C++ binding loaders:\n// - process.binding(): the legacy C++ binding loader\x2C accessible from user land\n//   because it is an object attached to the global process object.\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\n//   about the stability of these bindings\x2C but still have to take care of\n//   compatibility issues caused by them from time to time.\n// - process._linkedBinding(): intended to be used by embedders to add\n//   additional C++ bindings in their applications. These C++ bindings\n//   can be created using NODE_MODULE_CONTEXT_AWARE_CPP() with the flag\n//   NM_F_LINKED.\n// - internalBinding(): the private internal C++ binding loader\x2C inaccessible\n//   from user land unless through `require('internal/test/binding')`.\n//   These C++ bindings are created using NODE_MODULE_CONTEXT_AWARE_INTERNAL()\n//   and have their nm_flags set to NM_F_INTERNAL.\n//\n// Internal JavaScript module loader:\n// - NativeModule: a minimal module system used to load the JavaScript core\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\x2C\n//   so they can be loaded faster without the cost of I/O. This class makes the\n//   lib/internal/*\x2C deps/internal/* modules and internalBinding() available by\n//   default to core modules\x2C and lets the core modules require itself via\n//   require('internal/bootstrap/loaders') even when this file is not written in\n//   CommonJS style.\n//\n// Other objects:\n// - process.moduleLoadList: an array recording the bindings and the modules\n//   loaded in the process and the order in which they are loaded.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C getLinkedBinding\x2C getInternalBinding\x2C primordials */\n\nconst {\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ReflectGet\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeStartsWith\x2C\n  TypeError\x2C\n} = primordials;\n\n// Set up process.moduleLoadList.\nconst moduleLoadList = [];\nObjectDefineProperty(process\x2C 'moduleLoadList'\x2C {\n  value: moduleLoadList\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  writable: false\n});\n\n\n// internalBindingAllowlist contains the name of internalBinding modules\n// that are allowed for access via process.binding()... This is used\n// to provide a transition path for modules that are being moved over to\n// internalBinding.\nconst internalBindingAllowlist = new SafeSet([\n  'async_wrap'\x2C\n  'buffer'\x2C\n  'cares_wrap'\x2C\n  'config'\x2C\n  'constants'\x2C\n  'contextify'\x2C\n  'crypto'\x2C\n  'fs'\x2C\n  'fs_event_wrap'\x2C\n  'http_parser'\x2C\n  'icu'\x2C\n  'inspector'\x2C\n  'js_stream'\x2C\n  'natives'\x2C\n  'os'\x2C\n  'pipe_wrap'\x2C\n  'process_wrap'\x2C\n  'signal_wrap'\x2C\n  'spawn_sync'\x2C\n  'stream_wrap'\x2C\n  'tcp_wrap'\x2C\n  'tls_wrap'\x2C\n  'tty_wrap'\x2C\n  'udp_wrap'\x2C\n  'url'\x2C\n  'util'\x2C\n  'uv'\x2C\n  'v8'\x2C\n  'zlib'\x2C\n]);\n\nconst runtimeDeprecatedList = new SafeSet([\n  'async_wrap'\x2C\n  'crypto'\x2C\n  'http_parser'\x2C\n  'signal_wrap'\x2C\n  'url'\x2C\n  'v8'\x2C\n]);\n\nconst legacyWrapperList = new SafeSet([\n  'util'\x2C\n]);\n\n// Set up process.binding() and process._linkedBinding().\n{\n  const bindingObj = ObjectCreate(null);\n\n  process.binding = function binding(module) {\n    module = String(module);\n    // Deprecated specific process.binding() modules\x2C but not all\x2C allow\n    // selective fallback to internalBinding for the deprecated ones.\n    if (internalBindingAllowlist.has(module)) {\n      if (runtimeDeprecatedList.has(module)) {\n        runtimeDeprecatedList.delete(module);\n        process.emitWarning(\n          `Access to process.binding('${module}') is deprecated.`\x2C\n          'DeprecationWarning'\x2C\n          'DEP0111');\n      }\n      if (legacyWrapperList.has(module)) {\n        return nativeModuleRequire('internal/legacy/processbinding')[module]();\n      }\n      return internalBinding(module);\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`No such module: ${module}`);\n  };\n\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object')\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\n\n// Set up internalBinding() in the closure.\n/**\n * @type {InternalBinding}\n */\nlet internalBinding;\n{\n  const bindingObj = ObjectCreate(null);\n  // eslint-disable-next-line no-global-assign\n  internalBinding = function internalBinding(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object') {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList\x2C `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\n\nconst loaderId = 'internal/bootstrap/loaders';\nconst {\n  moduleIds\x2C\n  compileFunction\n} = internalBinding('native_module');\n\nconst getOwn = (target\x2C property\x2C receiver) => {\n  return ObjectPrototypeHasOwnProperty(target\x2C property) ?\n    ReflectGet(target\x2C property\x2C receiver) :\n    undefined;\n};\n\n/**\n * An internal abstraction for the built-in JavaScript modules of Node.js.\n * Be careful not to expose this to user land unless --expose-internals is\n * used\x2C in which case there is no compatibility guarantee about this class.\n */\nclass NativeModule {\n  /**\n   * A map from the module IDs to the module instances.\n   * @type {Map<string\x2C NativeModule>}\n  */\n  static map = new SafeMap(\n    ArrayPrototypeMap(moduleIds\x2C (id) => [id\x2C new NativeModule(id)])\n  );\n\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.canBeRequiredByUsers = !StringPrototypeStartsWith(id\x2C 'internal/');\n\n    // The CJS exports object of the module.\n    this.exports = {};\n    // States used to work around circular dependencies.\n    this.loaded = false;\n    this.loading = false;\n\n    // The following properties are used by the ESM implementation and only\n    // initialized when the native module is loaded by users.\n    /**\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\n     * @type {ModuleWrap|undefined}\n     */\n    this.module = undefined;\n    /**\n     * Exported names for the ESM imports.\n     * @type {string[]|undefined}\n     */\n    this.exportKeys = undefined;\n  }\n\n  // To be called during pre-execution when --expose-internals is on.\n  // Enables the user-land module loader to access internal modules.\n  static exposeInternals() {\n    for (const { 0: id\x2C 1: mod } of NativeModule.map) {\n      // Do not expose this to user land even with --expose-internals.\n      if (id !== loaderId) {\n        mod.canBeRequiredByUsers = true;\n      }\n    }\n  }\n\n  static exists(id) {\n    return NativeModule.map.has(id);\n  }\n\n  static canBeRequiredByUsers(id) {\n    const mod = NativeModule.map.get(id);\n    return mod && mod.canBeRequiredByUsers;\n  }\n\n  // Used by user-land module loaders to compile and load builtins.\n  compileForPublicLoader() {\n    if (!this.canBeRequiredByUsers) {\n      // No code because this is an assertion against bugs\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      // When using --expose-internals\x2C we do not want to reflect the named\n      // exports from core modules as this can trigger unnecessary getters.\n      const internal = StringPrototypeStartsWith(this.id\x2C 'internal/');\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n\n  getESMFacade() {\n    if (this.module) return this.module;\n    const { ModuleWrap } = internalBinding('module_wrap');\n    const url = `node:${this.id}`;\n    const nativeModule = this;\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\n    ArrayPrototypePush(exportsKeys\x2C 'default');\n    this.module = new ModuleWrap(\n      url\x2C undefined\x2C exportsKeys\x2C\n      function() {\n        nativeModule.syncExports();\n        this.setExport('default'\x2C nativeModule.exports);\n      });\n    // Ensure immediate sync execution to capture exports now\n    this.module.instantiate();\n    this.module.evaluate(-1\x2C false);\n    return this.module;\n  }\n\n  // Provide named exports for all builtin libraries so that the libraries\n  // may be imported in a nicer way for ESM users. The default export is left\n  // as the entire namespace (module.exports) and updates when this function is\n  // called so that APMs and other behavior are supported.\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === 'default') continue;\n        this.module.setExport(exportName\x2C\n                              getOwn(this.exports\x2C exportName\x2C this.exports));\n      }\n    }\n  }\n\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n\n    const id = this.id;\n    this.loading = true;\n\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id\x2C 'internal/deps/') ?\n        requireWithFallbackInDeps : nativeModuleRequire;\n\n      const fn = compileFunction(id);\n      fn(this.exports\x2C requireFn\x2C this\x2C process\x2C internalBinding\x2C primordials);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n\n    ArrayPrototypePush(moduleLoadList\x2C `NativeModule ${id}`);\n    return this.exports;\n  }\n}\n\n// Think of this as module.exports in this file even though it is not\n// written in CommonJS style.\nconst loaderExports = {\n  internalBinding\x2C\n  NativeModule\x2C\n  require: nativeModuleRequire\n};\n\nfunction nativeModuleRequire(id) {\n  if (id === loaderId) {\n    return loaderExports;\n  }\n\n  const mod = NativeModule.map.get(id);\n  // Can't load the internal errors module from here\x2C have to use a raw error.\n  // eslint-disable-next-line no-restricted-syntax\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\n\n// Allow internal modules from dependencies to require\n// other modules from dependencies by providing fallbacks.\nfunction requireWithFallbackInDeps(request) {\n  if (!NativeModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return nativeModuleRequire(request);\n}\n\n// Pass the exports back to C++ land for C++ internals to use.\nreturn loaderExports;\n
code-source-info,0x1eea4787e46e,9,10315,10658,C0O10324C2O10335C4O10331C9O10351C13O10372C14O10392C19O10405C24O10409C29O10409C35O10550C37O10560C47O10608C60O10566C65O10560C66O10629C71O10629C75O10656,,
tick,0x7fff202fa4b6,62979,0,0x0,3,0x10f0ac650,0x1eea4787e231
code-creation,LazyCompile,10,63425,0x1eea4787f17e,175,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x1eeab58cf828,~
code-source-info,0x1eea4787f17e,9,9528,10089,C0O9546C6O9561C12O9590C16O9598C17O9626C22O9634C23O9647C30O9690C37O9721C45O9690C63O9820C70O9820C75O9855C89O9890C103O9847C108O9928C109O9940C124O9970C126O9983C141O10003C152O10022C160O10054C165O10003C170O10077C174O10085,,
tick,0x10ebc7296,64266,1,0x10ea6ba00,2,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea4787e231
new,MemoryChunk,0x1eea2da80000,262144
code-creation,Eval,10,65166,0x1eea2da81486,5, node:internal/bootstrap/pre_execution:1:1,0x1eea4787fd60,~
script-source,92,node:internal/bootstrap/pre_execution,'use strict';\n\nconst {\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  StringPrototypeStartsWith\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  getOptionValue\x2C\n  noGlobalSearchPaths\x2C\n  shouldNotRegisterESMLoader\x2C\n} = require('internal/options');\nconst { reconnectZeroFillToggle } = require('internal/buffer');\n\nconst { Buffer } = require('buffer');\nconst { ERR_MANIFEST_ASSERT_INTEGRITY } = require('internal/errors').codes;\nconst assert = require('internal/assert');\n\nfunction prepareMainThreadExecution(expandArgv1 = false) {\n  // TODO(joyeecheung): this is also necessary for workers when they deserialize\n  // this toggle from the snapshot.\n  reconnectZeroFillToggle();\n\n  // Patch the process object with legacy properties and normalizations\n  patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupPerfHooks();\n  setupInspectorHooks();\n  setupWarningHandler();\n\n  // Resolve the coverage directory to an absolute path\x2C and\n  // overwrite process.env so that the original path gets passed\n  // to child processes even when they switch cwd.\n  if (process.env.NODE_V8_COVERAGE) {\n    process.env.NODE_V8_COVERAGE =\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n\n\n  setupDebugEnv();\n\n  // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\n  setupStacktracePrinterOnSigint();\n\n  // Process initial diagnostic reporting configuration\x2C if present.\n  initializeReport();\n  initializeReportSignalHandlers();  // Main-thread-only.\n\n  initializeHeapSnapshotSignalHandlers();\n\n  // If the process is spawned with env NODE_CHANNEL_FD\x2C it's probably\n  // spawned by our child_process module\x2C then initialize IPC.\n  // This attaches some internal event listeners and creates:\n  // process.send()\x2C process.channel\x2C process.connected\x2C\n  // process.disconnect().\n  setupChildProcessIpcChannel();\n\n  // Load policy from disk and parse it.\n  initializePolicy();\n\n  // If this is a worker in cluster mode\x2C start up the communication\n  // channel. This needs to be done before any user code gets executed\n  // (including preload modules).\n  initializeClusterIPC();\n\n  initializeSourceMapsHandlers();\n  initializeDeprecations();\n  initializeWASI();\n  initializeCJSLoader();\n  initializeESMLoader();\n\n  const CJSLoader = require('internal/modules/cjs/loader');\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  loadPreloadModules();\n  initializeFrozenIntrinsics();\n}\n\nfunction patchProcessObject(expandArgv1) {\n  const binding = internalBinding('process_methods');\n  binding.patchProcessObject(process);\n\n  // TODO(joyeecheung): snapshot fast APIs (which need to work with\n  // array buffers\x2C whose connection with C++ needs to be rebuilt after\n  // deserialization).\n  const {\n    hrtime\x2C\n    hrtimeBigInt\n  } = require('internal/process/per_thread').getFastAPIs(binding);\n\n  process.hrtime = hrtime;\n  process.hrtime.bigint = hrtimeBigInt;\n\n  ObjectDefineProperty(process\x2C 'argv0'\x2C {\n    enumerable: true\x2C\n    configurable: false\x2C\n    value: process.argv[0]\n  });\n  process.argv[0] = process.execPath;\n\n  if (expandArgv1 && process.argv[1] &&\n      !StringPrototypeStartsWith(process.argv[1]\x2C '-')) {\n    // Expand process.argv[1] into a full path.\n    const path = require('path');\n    try {\n      process.argv[1] = path.resolve(process.argv[1]);\n    } catch {}\n  }\n\n  // TODO(joyeecheung): most of these should be deprecated and removed\x2C\n  // except some that we need to be able to mutate during run time.\n  addReadOnlyProcessAlias('_eval'\x2C '--eval');\n  addReadOnlyProcessAlias('_print_eval'\x2C '--print');\n  addReadOnlyProcessAlias('_syntax_check_only'\x2C '--check');\n  addReadOnlyProcessAlias('_forceRepl'\x2C '--interactive');\n  addReadOnlyProcessAlias('_preload_modules'\x2C '--require');\n  addReadOnlyProcessAlias('noDeprecation'\x2C '--no-deprecation');\n  addReadOnlyProcessAlias('noProcessWarnings'\x2C '--no-warnings');\n  addReadOnlyProcessAlias('traceProcessWarnings'\x2C '--trace-warnings');\n  addReadOnlyProcessAlias('throwDeprecation'\x2C '--throw-deprecation');\n  addReadOnlyProcessAlias('profProcess'\x2C '--prof-process');\n  addReadOnlyProcessAlias('traceDeprecation'\x2C '--trace-deprecation');\n  addReadOnlyProcessAlias('_breakFirstLine'\x2C '--inspect-brk'\x2C false);\n  addReadOnlyProcessAlias('_breakNodeFirstLine'\x2C '--inspect-brk-node'\x2C false);\n}\n\nfunction addReadOnlyProcessAlias(name\x2C option\x2C enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process\x2C name\x2C {\n      writable: false\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      value\n    });\n  }\n}\n\nfunction setupWarningHandler() {\n  const {\n    onWarning\n  } = require('internal/process/warning');\n  if (getOptionValue('--warnings') &&\n    process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning'\x2C onWarning);\n  }\n}\n\n// Setup User-facing NODE_V8_COVERAGE environment variable that writes\n// ScriptCoverage to a specified file.\nfunction setupCoverageHooks(dir) {\n  const cwd = require('internal/process/execution').tryGetCwd();\n  const { resolve } = require('path');\n  const coverageDirectory = resolve(cwd\x2C dir);\n  const { sourceMapCacheToObject } =\n    require('internal/source_map/source_map_cache');\n\n  if (process.features.inspector) {\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning('The inspector is disabled\x2C ' +\n                        'coverage could not be collected'\x2C\n                        'Warning');\n    return '';\n  }\n  return coverageDirectory;\n}\n\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue('--trace-sigint')) {\n    return;\n  }\n  const { SigintWatchdog } = require('internal/watchdog');\n\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\n\nfunction initializeReport() {\n  const { report } = require('internal/process/report');\n  ObjectDefineProperty(process\x2C 'report'\x2C {\n    enumerable: false\x2C\n    configurable: true\x2C\n    get() {\n      return report;\n    }\n  });\n}\n\nfunction setupDebugEnv() {\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue('--expose-internals')) {\n    require('internal/bootstrap/loaders').NativeModule.exposeInternals();\n  }\n}\n\n// This has to be called after initializeReport() is called\nfunction initializeReportSignalHandlers() {\n  const { addSignalHandler } = require('internal/process/report');\n\n  addSignalHandler();\n}\n\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue('--heapsnapshot-signal');\n\n  if (!signal)\n    return;\n\n  require('internal/validators').validateSignalName(signal);\n  const { writeHeapSnapshot } = require('v8');\n\n  process.on(signal\x2C () => {\n    writeHeapSnapshot();\n  });\n}\n\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\n}\n\nfunction setupPerfHooks() {\n  require('internal/perf/performance').refreshTimeOrigin();\n  require('internal/perf/utils').refreshTimeOrigin();\n}\n\nfunction setupInspectorHooks() {\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap\x2C\n  // we cannot immediately call into JS to enable the hooks\x2C which could\n  // interrupt the JS execution of bootstrap. So instead we save the\n  // notification in the inspector agent if it's sent in the middle of\n  // bootstrap\x2C and process the notification later here.\n  if (internalBinding('config').hasInspector) {\n    const {\n      enable\x2C\n      disable\n    } = require('internal/inspector_async_hook');\n    internalBinding('inspector').registerAsyncHook(enable\x2C disable);\n  }\n}\n\n// In general deprecations are initialized wherever the APIs are implemented\x2C\n// this is used to deprecate APIs implemented in C++ where the deprecation\n// utilities are not easily accessible.\nfunction initializeDeprecations() {\n  const { deprecate } = require('internal/util');\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n  // DEP0103: access to `process.binding('util').isX` type checkers\n  // TODO(addaleax): Turn into a full runtime deprecation.\n  const utilBinding = internalBinding('util');\n  const types = require('internal/util/types');\n  for (const name of [\n    'isArrayBuffer'\x2C\n    'isArrayBufferView'\x2C\n    'isAsyncFunction'\x2C\n    'isDataView'\x2C\n    'isDate'\x2C\n    'isExternal'\x2C\n    'isMap'\x2C\n    'isMapIterator'\x2C\n    'isNativeError'\x2C\n    'isPromise'\x2C\n    'isRegExp'\x2C\n    'isSet'\x2C\n    'isSetIterator'\x2C\n    'isTypedArray'\x2C\n    'isUint8Array'\x2C\n    'isAnyArrayBuffer'\x2C\n  ]) {\n    utilBinding[name] = pendingDeprecation ?\n      deprecate(types[name]\x2C\n                'Accessing native typechecking bindings of Node ' +\n                'directly is deprecated. ' +\n                `Please use \\`util.types.${name}\\` instead.`\x2C\n                'DEP0103') :\n      types[name];\n  }\n\n  // TODO(joyeecheung): this is a legacy property exposed to process.\n  // Now that we use the config binding to carry this information\x2C remove\n  // it from the process. We may consider exposing it properly in\n  // process.features.\n  const { noBrowserGlobals } = internalBinding('config');\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process\x2C '_noBrowserGlobals'\x2C {\n      writable: false\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: noBrowserGlobals\n    });\n  }\n\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding\x2C\n                                'process.binding() is deprecated. ' +\n                                'Please use public APIs instead.'\x2C 'DEP0111');\n\n    process._tickCallback = deprecate(process._tickCallback\x2C\n                                      'process._tickCallback() is deprecated'\x2C\n                                      'DEP0134');\n  }\n\n  // Create global.process and global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    get() {\n      return _process;\n    }\x2C\n    set(value) {\n      _process = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis\x2C 'Buffer'\x2C {\n    get() {\n      return _Buffer;\n    }\x2C\n    set(value) {\n      _Buffer = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n}\n\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert = require('internal/assert');\n\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD\x2C 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const serializationMode =\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n\n    require('child_process')._forkChild(fd\x2C serializationMode);\n    assert(process.send);\n  }\n}\n\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require('cluster');\n    cluster._setupWorker();\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\n\nfunction initializePolicy() {\n  const experimentalPolicy = getOptionValue('--experimental-policy');\n  if (experimentalPolicy) {\n    process.emitWarning('Policies are experimental.'\x2C\n                        'ExperimentalWarning');\n    const { pathToFileURL\x2C URL } = require('internal/url');\n    // URL here as it is slightly different parsing\n    // no bare specifiers for now\n    let manifestURL;\n    if (require('path').isAbsolute(experimentalPolicy)) {\n      manifestURL = new URL(`file://${experimentalPolicy}`);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += '/';\n      manifestURL = new URL(experimentalPolicy\x2C cwdURL);\n    }\n    const fs = require('fs');\n    const src = fs.readFileSync(manifestURL\x2C 'utf8');\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\n    if (experimentalPolicyIntegrity) {\n      const SRI = require('internal/policy/sri');\n      const { createHash\x2C timingSafeEqual } = require('crypto');\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm\x2C\n          value: expected\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length &&\n          timingSafeEqual(digest\x2C expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm\x2C digest.toString('base64'));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL\x2C realIntegrities);\n      }\n    }\n    require('internal/process/policy')\n      .setup(src\x2C manifestURL.href);\n  }\n}\n\nfunction initializeWASI() {\n  const { NativeModule } = require('internal/bootstrap/loaders');\n  const mod = NativeModule.map.get('wasi');\n  mod.canBeRequiredByUsers =\n    getOptionValue('--experimental-wasi-unstable-preview1');\n}\n\nfunction initializeCJSLoader() {\n  const CJSLoader = require('internal/modules/cjs/loader');\n  if (!noGlobalSearchPaths) {\n    CJSLoader.Module._initPaths();\n  }\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\n  CJSLoader.Module.runMain =\n    require('internal/modules/run_main').executeUserEntryPoint;\n}\n\nfunction initializeESMLoader() {\n  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\n  internalBinding('module_wrap').callbackMap = new SafeWeakMap();\n\n  if (shouldNotRegisterESMLoader) return;\n\n  const {\n    setImportModuleDynamicallyCallback\x2C\n    setInitializeImportMetaObjectCallback\n  } = internalBinding('module_wrap');\n  const esm = require('internal/process/esm_loader');\n  // Setup per-isolate callbacks that locate data or callbacks that we keep\n  // track of for different ESM modules.\n  setInitializeImportMetaObjectCallback(esm.initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(esm.importModuleDynamicallyCallback);\n\n  // Patch the vm module when --experimental-vm-modules is on.\n  // Please update the comments in vm.js when this block changes.\n  if (getOptionValue('--experimental-vm-modules')) {\n    const {\n      Module\x2C SourceTextModule\x2C SyntheticModule\x2C\n    } = require('internal/vm/module');\n    const vm = require('vm');\n    vm.Module = Module;\n    vm.SourceTextModule = SourceTextModule;\n    vm.SyntheticModule = SyntheticModule;\n  }\n}\n\nfunction initializeSourceMapsHandlers() {\n  const { setSourceMapsEnabled } =\n    require('internal/source_map/source_map_cache');\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\n}\n\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue('--frozen-intrinsics')) {\n    process.emitWarning('The --frozen-intrinsics flag is experimental'\x2C\n                        'ExperimentalWarning');\n    require('internal/freeze_intrinsics')();\n  }\n}\n\nfunction loadPreloadModules() {\n  // For user code\x2C we preload modules if `-r` is passed\n  const preloadModules = getOptionValue('--require');\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\n      }\x2C\n    } = require('internal/modules/cjs/loader');\n    _preloadModules(preloadModules);\n  }\n}\n\nmodule.exports = {\n  patchProcessObject\x2C\n  setupCoverageHooks\x2C\n  setupWarningHandler\x2C\n  setupDebugEnv\x2C\n  setupPerfHooks\x2C\n  prepareMainThreadExecution\x2C\n  initializeDeprecations\x2C\n  initializeESMLoader\x2C\n  initializeFrozenIntrinsics\x2C\n  initializeSourceMapsHandlers\x2C\n  loadPreloadModules\x2C\n  setupTraceCategoryState\x2C\n  setupInspectorHooks\x2C\n  initializeReport\x2C\n  initializeCJSLoader\x2C\n  initializeWASI\n};\n
code-source-info,0x1eea2da81486,92,0,15975,C0O0C4O15975,,
code-creation,Function,10,66281,0x1eea2da81f8e,435, node:internal/bootstrap/pre_execution:1:1,0x1eea2da81400,~
code-source-info,0x1eea2da81f8e,92,0,15975,C0O0C193O25C199O43C205O67C211O78C217O93C223O122C229O235C235O235C240O162C246O180C252O203C258O300C264O300C269O272C275O348C281O348C286O337C292O409C298O409C303O435C308O375C314O458C320O458C324O458C326O15578C333O15599C339O15621C345O15643C351O15666C357O15683C363O15701C369O15731C375O15757C381O15780C387O15810C393O15842C399O15864C405O15891C411O15914C417O15934C423O15957C429O15593C434O15974,,
tick,0x7fff202fa4fd,66341,1,0x10ea6ba00,3,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea4787e231
tick,0x10f0fa068,66382,1,0x10ea6ba00,6,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea4787e231
code-creation,Eval,10,67278,0x1eea2da83896,5, node:internal/options:1:1,0x1eea2da836e0,~
script-source,93,node:internal/options,'use strict';\n\nconst {\n  getOptions\x2C\n  noGlobalSearchPaths\x2C\n  shouldNotRegisterESMLoader\x2C\n} = internalBinding('options');\n\nlet warnOnAllowUnauthorized = true;\n\nlet optionsMap;\nlet aliasesMap;\n\n// getOptions() would serialize the option values from C++ land.\n// It would error if the values are queried before bootstrap is\n// complete so that we don't accidentally include runtime-dependent\n// states into a runtime-independent snapshot.\nfunction getOptionsFromBinding() {\n  if (!optionsMap) {\n    ({ options: optionsMap } = getOptions());\n  }\n  return optionsMap;\n}\n\nfunction getAliasesFromBinding() {\n  if (!aliasesMap) {\n    ({ aliases: aliasesMap } = getOptions());\n  }\n  return aliasesMap;\n}\n\nfunction getOptionValue(optionName) {\n  const options = getOptionsFromBinding();\n  if (optionName.startsWith('--no-')) {\n    const option = options.get('--' + optionName.slice(5));\n    return option && !option.value;\n  }\n  return options.get(optionName)?.value;\n}\n\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\n\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\n      'environment variable to \\'0\\' makes TLS connections ' +\n      'and HTTPS requests insecure by disabling ' +\n      'certificate verification.');\n  }\n  return allowUnauthorized;\n}\n\nmodule.exports = {\n  get options() {\n    return getOptionsFromBinding();\n  }\x2C\n  get aliases() {\n    return getAliasesFromBinding();\n  }\x2C\n  getOptionValue\x2C\n  getAllowUnauthorized\x2C\n  noGlobalSearchPaths\x2C\n  shouldNotRegisterESMLoader\x2C\n};\n
code-source-info,0x1eea2da83896,93,0,1664,C0O0C4O1664,,
code-creation,Function,10,67437,0x1eea2da83c26,150, node:internal/options:1:1,0x1eea2da83810,~
code-source-info,0x1eea2da83c26,93,0,1664,C0O0C43O94C46O94C51O25C57O39C62O62C67O153C68O153C70O164C71O164C73O180C74O180C76O1429C83O1568C89O1586C95O1610C101O1633C144O1444C149O1663,,
code-creation,LazyCompile,10,67539,0x1eea2da840e6,69,internalBinding node:internal/bootstrap/loaders:164:45,0x1eeab58cf378,~
code-source-info,0x1eea2da840e6,9,5115,5353,C0O5140C7O5150C11O5164C15O5201C25O5228C30O5226C37O5262C48O5281C56O5317C61O5262C66O5338C68O5349,,
tick,0x7fff2042bf13,67671,1,0x10e9ee4a0,6,0x10ebf8f80,0x1eea2da840ff,0x1eea2da83c54,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da82079,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea4787e231
tick,0x10ef57000,68941,0,0x0,0,0x10f0b63a0,0x1eea2da83c72,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da82079,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea4787e231
code-creation,LazyCompile,10,69339,0x1eea2da8484e,213,prepareMainThreadExecution node:internal/bootstrap/pre_execution:23:36,0x1eea2da814b8,~
code-source-info,0x1eea2da8484e,92,522,2411,C10O665C15O665C18O767C21O767C25O802C28O802C31O831C34O831C37O851C40O851C43O876C46O876C49O1079C52O1091C57O1095C63O1119C66O1127C77O1183C82O1187C87O1156C91O1148C95O1214C98O1214C101O1306C104O1306C107O1412C110O1412C113O1434C116O1434C119O1493C122O1493C125O1816C128O1816C131O1891C134O1891C137O2088C140O2088C143O2115C146O2115C149O2149C152O2149C155O2177C158O2177C161O2197C164O2197C167O2222C170O2222C173O2266C179O2266C184O2308C189O2326C195O2308C199O2356C202O2356C205O2380C208O2380C212O2410,,
code-creation,LazyCompile,10,69445,0x1eea2da85a7e,19,reconnectZeroFillToggle node:internal/buffer:1072:33,0x1eea1f7f1cd0,~
script-source,19,node:internal/buffer,'use strict';\n\nconst {\n  BigInt\x2C\n  Float32Array\x2C\n  Float64Array\x2C\n  MathFloor\x2C\n  Number\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\nconst {\n  asciiSlice\x2C\n  base64Slice\x2C\n  base64urlSlice\x2C\n  latin1Slice\x2C\n  hexSlice\x2C\n  ucs2Slice\x2C\n  utf8Slice\x2C\n  asciiWrite\x2C\n  base64Write\x2C\n  base64urlWrite\x2C\n  latin1Write\x2C\n  hexWrite\x2C\n  ucs2Write\x2C\n  utf8Write\x2C\n  getZeroFillToggle\n} = internalBinding('buffer');\nconst {\n  untransferable_object_private_symbol\x2C\n  setHiddenValue\x2C\n} = internalBinding('util');\n\n// Temporary buffers to convert numbers.\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\n\n// Check endianness.\nfloat32Array[0] = -1; // 0xBF800000\n// Either it is [0\x2C 0\x2C 128\x2C 191] or [191\x2C 128\x2C 0\x2C 0]. It is not possible to\n// check this with `os.endianness()` because that is determined at compile time.\nconst bigEndian = uInt8Float32Array[3] === 0;\n\nfunction checkBounds(buf\x2C offset\x2C byteLength) {\n  validateNumber(offset\x2C 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n    boundsError(offset\x2C buf.length - (byteLength + 1));\n}\n\nfunction checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` +\n                `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE('value'\x2C range\x2C value);\n  }\n  checkBounds(buf\x2C offset\x2C byteLength);\n}\n\nfunction boundsError(value\x2C length\x2C type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value\x2C type);\n    throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C 'an integer'\x2C value);\n  }\n\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n  throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C\n                             `>= ${type ? 1 : 0} and <= ${length}`\x2C\n                             value);\n}\n\n// Read integers.\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\n\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\n\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n  return (BigInt(val) << 32n) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24);\n}\n\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n  return (BigInt(val) << 32n) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last);\n}\n\nfunction readUIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\n\nfunction readUInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    last * 2 ** 32;\n}\n\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n}\n\nfunction readUInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\n\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first + last * 2 ** 8;\n}\n\nfunction readUInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val;\n}\n\nfunction readUIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\n\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first * 2 ** 8 + last;\n}\n\nfunction readIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    (last << 24); // Overflow\n}\n\nfunction readInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\nfunction readInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val | (val & 2 ** 7) * 0x1fffffe;\n}\n\nfunction readIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\n// Read floats\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\n\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\n\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\n\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\n\n// Write integers.\nfunction writeBigU_Int64LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction writeBigUInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigU_Int64BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nfunction writeBigUInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeBigInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeUIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = (newVal >>> 8);\n  return offset;\n}\n\nfunction writeU_Int40LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\n\nfunction writeU_Int32LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeU_Int16LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = value;\n  buf[offset++] = (value >>> 8);\n  return offset;\n}\n\nfunction writeUInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeU_Int8(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset\x2C 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value'\x2C `>= ${min} and <= ${max}`\x2C value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset\x2C buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n}\n\nfunction writeUIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = (newVal >>> 8);\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int40BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int32BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeUInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\n\nfunction writeU_Int16BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\nfunction writeInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n}\n\nfunction writeIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\n// Write floats.\nfunction writeDoubleForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\n\nfunction writeDoubleBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\n\nfunction writeFloatForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\n\nfunction writeFloatBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\n\nclass FastBuffer extends Uint8Array {\n  // Using an explicit constructor here is necessary to avoid relying on\n  // `Array.prototype[Symbol.iterator]`\x2C which can be mutated by users.\n  // eslint-disable-next-line no-useless-constructor\n  constructor(bufferOrLength\x2C byteOffset\x2C length) {\n    super(bufferOrLength\x2C byteOffset\x2C length);\n  }\n}\n\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE;\n  proto.readBigUInt64BE = readBigUInt64BE;\n  proto.readBigUint64LE = readBigUInt64LE;\n  proto.readBigUint64BE = readBigUInt64BE;\n  proto.readBigInt64LE = readBigInt64LE;\n  proto.readBigInt64BE = readBigInt64BE;\n  proto.writeBigUInt64LE = writeBigUInt64LE;\n  proto.writeBigUInt64BE = writeBigUInt64BE;\n  proto.writeBigUint64LE = writeBigUInt64LE;\n  proto.writeBigUint64BE = writeBigUInt64BE;\n  proto.writeBigInt64LE = writeBigInt64LE;\n  proto.writeBigInt64BE = writeBigInt64BE;\n\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.base64urlSlice = base64urlSlice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.base64urlWrite = base64urlWrite;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\n\n// This would better be placed in internal/worker/io.js\x2C but that doesn't work\n// because Buffer needs this and that would introduce a cyclic dependency.\nfunction markAsUntransferable(obj) {\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\n    return;  // This object is a primitive and therefore already untransferable.\n  setHiddenValue(obj\x2C untransferable_object_private_symbol\x2C true);\n}\n\n// A toggle used to access the zero fill setting of the array buffer allocator\n// in C++.\n// |zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nlet zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\n// The connection between the JS land zero fill toggle and the\n// C++ one in the NodeArrayBufferAllocator gets lost if the toggle\n// is deserialized from the snapshot\x2C because V8 owns the underlying\n// memory of this toggle. This resets the connection.\nfunction reconnectZeroFillToggle() {\n  zeroFill = getZeroFillToggle();\n}\n\nmodule.exports = {\n  FastBuffer\x2C\n  addBufferPrototypeMethods\x2C\n  markAsUntransferable\x2C\n  createUnsafeBuffer\x2C\n  readUInt16BE\x2C\n  readUInt32BE\x2C\n  reconnectZeroFillToggle\n};\n
code-source-info,0x1eea2da85a7e,19,30717,30757,C0O30724C5O30735C11O30733C18O30756,,
tick,0x7fff203e5398,71581,0,0x0,3,0x10f0ac650,0x1eea2da8485d,0x1eea4787e23d
tick,0x7fff203e51ca,71601,0,0x0,3,0x10f0ac650,0x1eea2da8485d,0x1eea4787e23d
code-creation,LazyCompile,10,71681,0x1eea2da882ce,432,patchProcessObject node:internal/bootstrap/pre_execution:82:28,0x1eea2da81508,~
code-source-info,0x1eea2da882ce,92,2440,4282,C0O2474C6O2474C11O2520C19O2520C24O2758C30O2758C35O2796C40O2797C46O2727C51O2739C56O2822C61O2837C65O2849C68O2857C75O2871C79O2890C90O2911C98O2997C104O3001C111O2890C116O3013C119O3021C129O3039C133O3029C137O3052C144O3079C151O3083C158O3097C164O3131C171O3135C178O3097C185O3213C191O3213C199O3246C202O3254C210O3269C218O3285C225O3289C229O3269C234O3262C244O3457C253O3457C258O3503C267O3503C272O3556C281O3556C286O3616C295O3616C300O3674C309O3674C314O3734C323O3734C328O3798C337O3798C342O3863C351O3863C356O3934C365O3934C370O4004C379O4004C384O4064C393O4064C398O4134C409O4134C414O4204C425O4204C431O4281,,
code-creation,LazyCompile,10,71888,0x1eea2da8895e,113,getFastAPIs node:internal/process/per_thread:57:21,0x1eea1f7fde80,~
script-source,23,node:internal/process/per_thread,'use strict';\n\n// This files contains process bootstrappers that can be\n// run when setting up each thread\x2C including the main\n// thread and the worker threads.\n\nconst {\n  ArrayPrototypeEvery\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  BigUint64Array\x2C\n  Float64Array\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  ObjectFreeze\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  Set\x2C\n  SetPrototypeEntries\x2C\n  SetPrototypeValues\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  Uint32Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_ASSERTION\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\n} = require('internal/errors');\nconst format = require('internal/util/inspect').format;\nconst {\n  validateArray\x2C\n  validateNumber\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst constants = internalBinding('constants').os.signals;\n\nconst kInternal = Symbol('internal properties');\n\nfunction assert(x\x2C msg) {\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\n}\n\nfunction getFastAPIs(binding) {\n  const {\n    hrtime: _hrtime\n  } = binding.getFastAPIs();\n\n  // The 3 entries filled in by the original process.hrtime contains\n  // the upper/lower 32 bits of the second part of the value\x2C\n  // and the remaining nanoseconds of the value.\n  const hrValues = new Uint32Array(_hrtime.buffer);\n\n  function hrtime(time) {\n    _hrtime.hrtime();\n\n    if (time !== undefined) {\n      validateArray(time\x2C 'time');\n      if (time.length !== 2) {\n        throw new ERR_OUT_OF_RANGE('time'\x2C 2\x2C time.length);\n      }\n\n      const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n      const nsec = hrValues[2] - time[1];\n      const needsBorrow = nsec < 0;\n      return [needsBorrow ? sec - 1 : sec\x2C needsBorrow ? nsec + 1e9 : nsec];\n    }\n\n    return [\n      hrValues[0] * 0x100000000 + hrValues[1]\x2C\n      hrValues[2]\x2C\n    ];\n  }\n\n  // Use a BigUint64Array in the closure because this is actually a bit\n  // faster than simply returning a BigInt from C++ in V8 7.1.\n  const hrBigintValues = new BigUint64Array(_hrtime.buffer\x2C 0\x2C 1);\n  function hrtimeBigInt() {\n    _hrtime.hrtimeBigInt();\n    return hrBigintValues[0];\n  }\n\n  return {\n    hrtime\x2C\n    hrtimeBigInt\x2C\n  };\n}\n\n// The execution of this function itself should not cause any side effects.\nfunction wrapProcessMethods(binding) {\n  const {\n    cpuUsage: _cpuUsage\x2C\n    memoryUsage: _memoryUsage\x2C\n    rss\x2C\n    resourceUsage: _resourceUsage\n  } = binding;\n\n  function _rawDebug(...args) {\n    binding._rawDebug(ReflectApply(format\x2C null\x2C args));\n  }\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  function cpuUsage(prevValue) {\n    // If a previous value was passed in\x2C ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        validateObject(prevValue\x2C 'prevValue');\n\n        validateNumber(prevValue.user\x2C 'prevValue.user');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.user'\x2C\n                                                   prevValue.user);\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        validateNumber(prevValue.system\x2C 'prevValue.system');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.system'\x2C\n                                                   prevValue.system);\n      }\n    }\n\n    // Call the native function to get the current values.\n    _cpuUsage(cpuValues);\n\n    // If a previous value was passed in\x2C return diff of current from previous.\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user\x2C\n        system: cpuValues[1] - prevValue.system\n      };\n    }\n\n    // If no previous value passed in\x2C return current value.\n    return {\n      user: cpuValues[0]\x2C\n      system: cpuValues[1]\n    };\n  }\n\n  // Ensure that a previously passed in value is valid. Currently\x2C the native\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n  function previousValueIsValid(num) {\n    return typeof num === 'number' &&\n        num <= NumberMAX_SAFE_INTEGER &&\n        num >= 0;\n  }\n\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0]\x2C\n      heapTotal: memValues[1]\x2C\n      heapUsed: memValues[2]\x2C\n      external: memValues[3]\x2C\n      arrayBuffers: memValues[4]\n    };\n  }\n\n  memoryUsage.rss = rss;\n\n  function exit(code) {\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit'\x2C process.exitCode || 0);\n    }\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\n    // in the user land. Either document it\x2C or deprecate it in favor of a\n    // better public alternative.\n    process.reallyExit(process.exitCode || 0);\n  }\n\n  function kill(pid\x2C sig) {\n    let err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE('pid'\x2C 'number'\x2C pid);\n    }\n\n    // Preserve null signal\n    if (sig === (sig | 0)) {\n      // XXX(joyeecheung): we have to use process._kill here because\n      // it's monkey-patched by tests.\n      err = process._kill(pid\x2C sig);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (constants[sig]) {\n        err = process._kill(pid\x2C constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n\n    if (err)\n      throw errnoException(err\x2C 'kill');\n\n    return true;\n  }\n\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0]\x2C\n      systemCPUTime: resourceValues[1]\x2C\n      maxRSS: resourceValues[2]\x2C\n      sharedMemorySize: resourceValues[3]\x2C\n      unsharedDataSize: resourceValues[4]\x2C\n      unsharedStackSize: resourceValues[5]\x2C\n      minorPageFault: resourceValues[6]\x2C\n      majorPageFault: resourceValues[7]\x2C\n      swappedOut: resourceValues[8]\x2C\n      fsRead: resourceValues[9]\x2C\n      fsWrite: resourceValues[10]\x2C\n      ipcSent: resourceValues[11]\x2C\n      ipcReceived: resourceValues[12]\x2C\n      signalsCount: resourceValues[13]\x2C\n      voluntaryContextSwitches: resourceValues[14]\x2C\n      involuntaryContextSwitches: resourceValues[15]\n    };\n  }\n\n\n  return {\n    _rawDebug\x2C\n    cpuUsage\x2C\n    resourceUsage\x2C\n    memoryUsage\x2C\n    kill\x2C\n    exit\n  };\n}\n\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\n\n// This builds the initial process.allowedNodeEnvironmentFlags\n// from data in the config binding.\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvironment }\x2C\n    types: { kBoolean }\x2C\n  } = internalBinding('options');\n  const { options\x2C aliases } = require('internal/options');\n\n  const allowedNodeEnvironmentFlags = [];\n  for (const { 0: name\x2C 1: info } of options) {\n    if (info.envVarSettings === kAllowedInEnvironment) {\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C name);\n      if (info.type === kBoolean) {\n        const negatedName = `--no-${name.slice(2)}`;\n        ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C negatedName);\n      }\n    }\n  }\n\n  function isAccepted(to) {\n    if (!StringPrototypeStartsWith(to\x2C '-') || to === '--') return true;\n    const recursiveExpansion = aliases.get(to);\n    if (recursiveExpansion) {\n      if (recursiveExpansion[0] === to)\n        ArrayPrototypeSplice(recursiveExpansion\x2C 0\x2C 1);\n      return ArrayPrototypeEvery(recursiveExpansion\x2C isAccepted);\n    }\n    return options.get(to).envVarSettings === kAllowedInEnvironment;\n  }\n  for (const { 0: from\x2C 1: expansion } of aliases) {\n    if (ArrayPrototypeEvery(expansion\x2C isAccepted)) {\n      let canonical = from;\n      if (StringPrototypeEndsWith(canonical\x2C '='))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 1);\n      if (StringPrototypeEndsWith(canonical\x2C ' <arg>'))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 4);\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C canonical);\n    }\n  }\n\n  const trimLeadingDashes =\n    (flag) => StringPrototypeReplace(flag\x2C leadingDashesRegex\x2C '');\n\n  // Save these for comparison against flags provided to\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags\x2C\n                                      trimLeadingDashes);\n\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(array) {\n      super();\n      this[kInternal] = { array };\n    }\n\n    add() {\n      // No-op\x2C `Set` API compatible\n      return this;\n    }\n\n    delete() {\n      // No-op\x2C `Set` API compatible\n      return false;\n    }\n\n    clear() {\n      // No-op\x2C `Set` API compatible\n    }\n\n    has(key) {\n      // This will return `true` based on various possible\n      // permutations of a flag\x2C including present/missing leading\n      // dash(es) and/or underscores-for-dashes.\n      // Strips any values after `=`\x2C inclusive.\n      // TODO(addaleax): It might be more flexible to run the option parser\n      // on a dummy option set and see whether it rejects the argument or\n      // not.\n      if (typeof key === 'string') {\n        key = StringPrototypeReplace(key\x2C replaceUnderscoresRegex\x2C '-');\n        if (RegExpPrototypeTest(leadingDashesRegex\x2C key)) {\n          key = StringPrototypeReplace(key\x2C trailingValuesRegex\x2C '');\n          return ArrayPrototypeIncludes(this[kInternal].array\x2C key);\n        }\n        return ArrayPrototypeIncludes(nodeFlags\x2C key);\n      }\n      return false;\n    }\n\n    entries() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeEntries(this[kInternal].set);\n    }\n\n    forEach(callback\x2C thisArg = undefined) {\n      ArrayPrototypeForEach(\n        this[kInternal].array\x2C\n        (v) => ReflectApply(callback\x2C thisArg\x2C [v\x2C v\x2C this])\n      );\n    }\n\n    get size() {\n      return this[kInternal].array.length;\n    }\n\n    values() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeValues(this[kInternal].set);\n    }\n  }\n  NodeEnvironmentFlagsSet.prototype.keys =\n  NodeEnvironmentFlagsSet.prototype[SymbolIterator] =\n    NodeEnvironmentFlagsSet.prototype.values;\n\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\n    allowedNodeEnvironmentFlags\n  ));\n}\n\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\n// trace event category is enabled.\nlet traceEventsAsyncHook;\n// Dynamically enable/disable the traceEventsAsyncHook\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook =\n        require('internal/trace_events_async_hooks').createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\n\nmodule.exports = {\n  toggleTraceCategoryState\x2C\n  getFastAPIs\x2C\n  assert\x2C\n  buildAllowedFlags\x2C\n  wrapProcessMethods\n};\n
code-source-info,0x1eea2da8895e,23,1229,2412,C0O1229C24O1285C29O1285C34O1263C40O1500C50O1524C57O1500C62O1500C64O2232C74O2259C86O2232C91O2232C93O2367C100O2380C106O2392C112O2410,,
tick,0x7fff203e5398,72715,0,0x0,3,0x10f0ac650,0x1eea2da882f6,0x1eea2da84863,0x1eea4787e23d
tick,0x10ef9ab90,73533,0,0x0,0,0x10ec1a050,0x1eea2da8833d,0x1eea2da84863,0x1eea4787e23d
code-creation,LazyCompile,10,73685,0x1eea2da8a01e,175,resolve node:path:1091:10,0x1eeac2068450,~
script-source,35,node:path,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_UPPERCASE_Z\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_QUESTION_MARK\x2C\n} = require('internal/constants');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path\x2C allowAboveRoot\x2C separator\x2C isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path\x2C i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res\x2C separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res\x2C 0\x2C lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res\x2C separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path\x2C lastSlash + 1\x2C i)}`;\n        else\n          res = StringPrototypeSlice(path\x2C lastSlash + 1\x2C i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep\x2C pathObject) {\n  validateObject(pathObject\x2C 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path\x2C 'path');\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path\x2C get cwd for that drive\x2C or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points\x2C because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not\x2C default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path\x2C 0\x2C 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path\x2C 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator\x2C we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path\x2C 0\x2C 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path\x2C rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail\x2C !resolvedAbsolute\x2C '\\\\'\x2C\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char\x2C exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator\x2C we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path\x2C 0\x2C 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path\x2C rootEnd)\x2C\n                      !isAbsolute\x2C '\\\\'\x2C isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path\x2C len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)));\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes\x2C because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components\x2C so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server'\x2C 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined\x2C slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined\x2C slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  }\x2C\n\n  /**\n   * It will solve the relative path from `from` to `to`\x2C for instancee\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from\x2C fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from\x2C fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to\x2C toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to\x2C toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen\x2C so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig\x2C toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig\x2C toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig\x2C toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath\x2C 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath\x2C 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root\x2C convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath\x2C 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath\x2C 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root\x2C convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator\x2C exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a "normal root" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0)) &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '\\\\')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root\x2C exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path\x2C 0\x2C rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C startPart\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C startPart\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C startPart\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    // If the directory is the root\x2C use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise\x2C strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  }\x2C\n\n  sep: '\\\\'\x2C\n  delimiter: ';'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd()\x2C regexp\x2C '/');\n      return StringPrototypeSlice(cwd\x2C StringPrototypeIndexOf(cwd\x2C '/'));\n    };\n  }\n\n  // We're already on POSIX\x2C no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n\n      validateString(path\x2C 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath\x2C !resolvedAbsolute\x2C '/'\x2C\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path\x2C path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path\x2C !isAbsolute\x2C '/'\x2C isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  }\x2C\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to\x2C toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to\x2C toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to\x2C toStart + lastCommonSep)}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '/')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C start\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C start\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C start\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  }\x2C\n\n  sep: '/'\x2C\n  delimiter: ':'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API\x2C docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n
code-source-info,0x1eea2da8a01e,35,33782,34692,C0O33782C3O33817C6O33848C8O33878C12O33885C16O33898C18O33892C25O33902C27O33946C28O33948C35O33959C42O33965C45O33965C49O33984C57O33984C62O34058C68O34065C73O34082C75O34107C87O34133C92O34155C99O34182C107O34221C109O34217C113O33921C118O33860C121O34437C126O34483C137O34452C143O34569C147O34599C152O34610C156O34625C157O34656C163O34663C174O34688,,
tick,0x7fff203e538d,77665,0,0x0,3,0x10f0ac650,0x1eea2da883b3,0x1eea2da84863,0x1eea4787e23d
tick,0x7fff202f7260,77686,0,0x0,3,0x10f0ac650,0x1eea2da883b3,0x1eea2da84863,0x1eea4787e23d
tick,0x7fff202fa27a,77698,0,0x0,3,0x10f0ac650,0x1eea2da883b3,0x1eea2da84863,0x1eea4787e23d
code-creation,LazyCompile,10,78025,0x1eea2da8d256,30,validateString node:internal/validators:117:24,0x1eea1f7d9ef8,~
script-source,17,node:internal/validators,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  NumberIsInteger\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  NumberParseInt\x2C\n  RegExpPrototypeTest\x2C\n  String\x2C\n  StringPrototypeToUpperCase\x2C\n  StringPrototypeTrim\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_SOCKET_BAD_PORT\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n    ERR_INVALID_CALLBACK\x2C\n  }\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isArrayBufferView\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land\x2C but any value higher than 0o777 will result in platform-specific\n * behaviors.\n *\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified\x2C will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value\x2C name\x2C def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (!RegExpPrototypeTest(octalReg\x2C value)) {\n      throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C modeDesc);\n    }\n    value = NumberParseInt(value\x2C 8);\n  }\n\n  validateInt32(value\x2C name\x2C 0\x2C 2 ** 32 - 1);\n  return value;\n}\n\nconst validateInteger = hideStackFrames(\n  (value\x2C name\x2C min = NumberMIN_SAFE_INTEGER\x2C max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\n);\n\nconst validateInt32 = hideStackFrames(\n  (value\x2C name\x2C min = -2147483648\x2C max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (!isInt32(value)) {\n      if (typeof value !== 'number') {\n        throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n      }\n      if (!NumberIsInteger(value)) {\n        throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n      }\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n  }\n);\n\nconst validateUint32 = hideStackFrames((value\x2C name\x2C positive) => {\n  if (!isUint32(value)) {\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    }\n    const min = positive ? 1 : 0;\n    // 2 ** 32 === 4294967296\n    throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && < 4294967296`\x2C value);\n  }\n  if (positive && value === 0) {\n    throw new ERR_OUT_OF_RANGE(name\x2C '>= 1 && < 4294967296'\x2C value);\n  }\n});\n\nfunction validateString(value\x2C name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C value);\n}\n\nfunction validateNumber(value\x2C name) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n}\n\nconst validateOneOf = hideStackFrames((value\x2C name\x2C oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf\x2C value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf\x2C (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v)))\x2C\n      '\x2C ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateBoolean(value\x2C name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'boolean'\x2C value);\n}\n\n/**\n * @param {unknown} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean\x2C\n *   allowFunction?: boolean\x2C\n *   nullable?: boolean\n * }} [options]\n */\nconst validateObject = hideStackFrames(\n  (value\x2C name\x2C options) => {\n    const useDefaultOptions = options == null;\n    const allowArray = useDefaultOptions ? false : options.allowArray;\n    const allowFunction = useDefaultOptions ? false : options.allowFunction;\n    const nullable = useDefaultOptions ? false : options.nullable;\n    if ((!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== 'object' && (\n          !allowFunction || typeof value !== 'function'\n        ))) {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n    }\n  });\n\nconst validateArray = hideStackFrames((value\x2C name\x2C minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Array'\x2C value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateSignalName(signal\x2C name = 'signal') {\n  validateString(signal\x2C name);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\nconst validateBuffer = hideStackFrames((buffer\x2C name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buffer);\n  }\n});\n\nfunction validateEncoding(data\x2C encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding'\x2C encoding\x2C\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n// Check that the port number is not NaN when coerced to a number\x2C\n// is an integer and that it falls within the legal range of port numbers.\nfunction validatePort(port\x2C name = 'Port'\x2C allowZero = true) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name\x2C port\x2C allowZero);\n  }\n  return port | 0;\n}\n\nconst validateCallback = hideStackFrames((callback) => {\n  if (typeof callback !== 'function')\n    throw new ERR_INVALID_CALLBACK(callback);\n});\n\nconst validateAbortSignal = hideStackFrames((signal\x2C name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n});\n\nconst validateFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\nconst validateUndefined = hideStackFrames((value\x2C name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'undefined'\x2C value);\n});\n\nmodule.exports = {\n  isInt32\x2C\n  isUint32\x2C\n  parseFileMode\x2C\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateNumber\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validatePort\x2C\n  validateSignalName\x2C\n  validateString\x2C\n  validateUint32\x2C\n  validateUndefined\x2C\n  validateCallback\x2C\n  validateAbortSignal\x2C\n};\n
code-source-info,0x1eea2da8d256,17,3398,3507,C0O3416C6O3451C22O3457C27O3451C29O3506,,
tick,0x7fff203e4e78,78623,0,0x0,3,0x10f0ac650,0x1eea2da8a057,0x1eea2da883b3,0x1eea2da84863,0x1eea4787e23d
code-creation,LazyCompile,10,79172,0x1eea2da8dcfe,442,normalizeString node:path:66:25,0x1eeac2067f68,~
code-source-info,0x1eea2da8dcfe,35,2161,4085,C0O2226C3O2256C5O2277C8O2294C10O2310C12O2328C14O2341C18O2333C23O2373C27O2366C32O2387C37O2394C45O2443C51O2472C53O2494C58O2530C64O2561C66O2581C69O2575C76O2593C83O2631C85O2640C90O2665C97O2672C104O2697C111O2718C114O2753C118O2760C122O2718C130O2769C132O2765C139O2793C142O2828C146O2835C150O2793C158O2844C160O2840C165O2874C172O2881C177O2923C182O2923C188O2979C190O2998C195O3022C198O3046C202O3104C215O3110C221O3210C225O3217C231O3223C234O3223C239O3221C243O3293C246O3320C248O3342C250O3377C256O3384C261O3405C264O3427C266O3462C269O3489C271O3511C273O3551C277O3594C283O3601C293O3610C308O3642C313O3706C319O3713C324O3728C326O3738C330O3750C335O3787C345O3750C363O3821C370O3864C380O3827C386O3881C388O3903C391O3915C395O3934C398O3955C402O3976C404O3989C406O3985C413O4006C418O4022C425O4049C428O2351C433O2315C439O4072C441O4083,,
code-creation,LazyCompile,10,79300,0x1eea2da8e07e,8,isPosixPathSeparator node:path:56:30,0x1eeac2067ec8,~
code-source-info,0x1eea2da8e07e,35,1854,1902,C0O1865C2O1881C4O1877C7O1900,,
tick,0x10f501980,79488,0,0x0,0,0x1eea2da8dd38,0x1eea2da8a0a7,0x1eea2da883b3,0x1eea2da84863,0x1eea4787e23d
code-creation,LazyCompile,10,79850,0x1eea2da8e31e,63,addReadOnlyProcessAlias node:internal/bootstrap/pre_execution:130:33,0x1eea2da81558,~
code-source-info,0x1eea2da8e31e,92,4316,4541,C16O4368C21O4368C26O4394C28O4411C36O4441C43O4504C49O4522C56O4411C62O4540,,
code-creation,LazyCompile,10,79918,0x1eea2da8e49e,82,getOptionValue node:internal/options:32:24,0x1eea2da83968,~
code-source-info,0x1eea2da8e49e,93,720,960,C0O753C3O753C7O795C15O795C22O845C30O867C38O867C43O854C47O845C53O882C55O907C60O913C61O935C66O935C74O950C81O958,,
code-creation,LazyCompile,10,79962,0x1eea2da8e81e,33,getOptionsFromBinding node:internal/options:18:31,0x1eea2da838c8,~
code-source-info,0x1eea2da8e81e,93,467,565,C0O474C6O497C11O524C15O509C28O545C32O563,,
code-creation,LazyCompile,10,80308,0x1eea2da8ebfe,46,setupTraceCategoryState node:internal/bootstrap/pre_execution:222:33,0x1eea2da81800,~
code-source-info,0x1eea2da8ebfe,92,6784,7011,C0O6826C6O6826C11O6799C16O6898C22O6898C27O6869C32O6940C35O6965C40O6940C45O7010,,
tick,0x10f460c60,80496,0,0x0,0,0x1eea2da8486a,0x1eea4787e23d
code-creation,LazyCompile,10,80753,0x1eea2da8ed96,77,toggleTraceCategoryState node:internal/process/per_thread:385:34,0x1eea1f7fe470,~
code-source-info,0x1eea2da8ed96,23,11040,11337,C0O11064C4O11093C10O11128C16O11159C21O11203C26O11204C33O11149C39O11228C44O11249C49O11249C55O11268C61O11300C66O11321C71O11321C76O11336,,
code-creation,LazyCompile,10,80807,0x1eea2da8ef46,42,setupPerfHooks node:internal/bootstrap/pre_execution:228:24,0x1eea2da81850,~
code-source-info,0x1eea2da8ef46,92,7036,7156,C0O7043C6O7043C11O7079C16O7080C20O7103C26O7103C31O7133C36O7134C41O7155,,
code-creation,LazyCompile,10,80866,0x1eea2da8f0c6,42,refreshTimeOrigin node:internal/perf/performance:178:27,0x1eeaaa6426d0,~
script-source,70,node:internal/perf/performance,'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  EventTarget\x2C\n} = require('internal/event_target');\n\nconst { now } = require('internal/perf/utils');\n\nconst {\n  mark\x2C\n  measure\x2C\n  clearMarkTimings\x2C\n} = require('internal/perf/usertiming');\nconst {\n  clearEntriesFromBuffer\x2C\n  filterBufferMapByNameAndType\x2C\n} = require('internal/perf/observe');\n\nconst eventLoopUtilization = require('internal/perf/event_loop_utilization');\nconst nodeTiming = require('internal/perf/nodetiming');\nconst timerify = require('internal/perf/timerify');\nconst { customInspectSymbol: kInspect } = require('internal/util');\nconst { inspect } = require('util');\n\nconst {\n  getTimeOriginTimestamp\n} = internalBinding('performance');\n\nclass Performance extends EventTarget {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0) return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `Performance ${inspect({\n      nodeTiming: this.nodeTiming\x2C\n      timeOrigin: this.timeOrigin\x2C\n    }\x2C opts)}`;\n  }\n}\n\nfunction toJSON() {\n  return {\n    nodeTiming: this.nodeTiming\x2C\n    timeOrigin: this.timeOrigin\x2C\n    eventLoopUtilization: this.eventLoopUtilization()\n  };\n}\n\nfunction clearMarks(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearMarkTimings(name);\n  clearEntriesFromBuffer('mark'\x2C name);\n}\n\nfunction clearMeasures(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearEntriesFromBuffer('measure'\x2C name);\n}\n\nfunction getEntries() {\n  return filterBufferMapByNameAndType();\n}\n\nfunction getEntriesByName(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  return filterBufferMapByNameAndType(name\x2C undefined);\n}\n\nfunction getEntriesByType(type) {\n  if (type !== undefined) {\n    type = `${type}`;\n  }\n  return filterBufferMapByNameAndType(undefined\x2C type);\n}\n\nclass InternalPerformance extends EventTarget {}\nInternalPerformance.prototype.constructor = Performance.prototype.constructor;\nObjectSetPrototypeOf(InternalPerformance.prototype\x2C Performance.prototype);\n\nObjectDefineProperties(Performance.prototype\x2C {\n  clearMarks: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMarks\x2C\n  }\x2C\n  clearMeasures: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMeasures\x2C\n  }\x2C\n  eventLoopUtilization: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: eventLoopUtilization\x2C\n  }\x2C\n  getEntries: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntries\x2C\n  }\x2C\n  getEntriesByName: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByName\x2C\n  }\x2C\n  getEntriesByType: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByType\x2C\n  }\x2C\n  mark: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: mark\x2C\n  }\x2C\n  measure: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: measure\x2C\n  }\x2C\n  nodeTiming: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: nodeTiming\x2C\n  }\x2C\n  now: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: now\x2C\n  }\x2C\n  timerify: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: timerify\x2C\n  }\x2C\n  // This would be updated during pre-execution in case\n  // the process is launched from a snapshot.\n  // TODO(joyeecheung): we may want to warn about access to\n  // this during snapshot building.\n  timeOrigin: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  }\x2C\n  toJSON: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: toJSON\x2C\n  }\n});\n\nfunction refreshTimeOrigin() {\n  ObjectDefineProperty(Performance.prototype\x2C 'timeOrigin'\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  });\n}\n\nmodule.exports = {\n  InternalPerformance\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x1eea2da8f0c6,70,3755,3912,C0O3762C7O3783C10O3795C25O3879C28O3879C35O3762C41O3911,,
code-creation,LazyCompile,10,81253,0x1eea2da8f7d6,19,refreshTimeOrigin node:internal/perf/utils:25:27,0x1eeac207b3e8,~
script-source,41,node:internal/perf/utils,'use strict';\n\nconst binding = internalBinding('performance');\nconst {\n  milestones\x2C\n  getTimeOrigin\x2C\n} = binding;\n\n// TODO(joyeecheung): we may want to warn about access to\n// this during snapshot building.\nlet timeOrigin = getTimeOrigin();\n\nfunction now() {\n  const hr = process.hrtime();\n  return (hr[0] * 1000 + hr[1] / 1e6) - timeOrigin;\n}\n\nfunction getMilestoneTimestamp(milestoneIdx) {\n  const ns = milestones[milestoneIdx];\n  if (ns === -1)\n    return ns;\n  return ns / 1e6 - timeOrigin;\n}\n\nfunction refreshTimeOrigin() {\n  timeOrigin = getTimeOrigin();\n}\n\nmodule.exports = {\n  now\x2C\n  getMilestoneTimestamp\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x1eea2da8f7d6,41,525,563,C0O532C5O545C11O543C18O562,,
code-creation,LazyCompile,10,81346,0x1eea2da8fa46,62,setupInspectorHooks node:internal/bootstrap/pre_execution:233:29,0x1eea2da818a0,~
code-source-info,0x1eea2da8fa46,92,7186,7739,C0O7529C6O7533C11O7558C17O7623C23O7623C28O7593C33O7607C38O7669C44O7669C49O7697C54O7698C61O7738,,
tick,0x10f0dc1bc,81743,1,0x10ea6ba00,5,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea2da8fa5d,0x1eea2da84876,0x1eea4787e23d
code-creation,Eval,10,82177,0x1eea2da8fdf6,5, node:internal/inspector_async_hook:1:1,0x1eea2da8fc40,~
script-source,94,node:internal/inspector_async_hook,'use strict';\n\nlet hook;\nlet config;\n\nconst {\n  SafeSet\x2C\n} = primordials;\n\nfunction lazyHookCreation() {\n  const inspector = internalBinding('inspector');\n  const { createHook } = require('async_hooks');\n  config = internalBinding('config');\n\n  hook = createHook({\n    init(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n    // It's difficult to tell which tasks will be recurring and which won't\x2C\n    // therefore we mark all tasks as recurring. Based on the discussion\n    // in https://github.com/nodejs/node/pull/13870#discussion_r124515293\x2C\n    // this should be fine as long as we call asyncTaskCanceled() too.\n      const recurring = true;\n      if (type === 'PROMISE')\n        this.promiseIds.add(asyncId);\n      else\n        inspector.asyncTaskScheduled(type\x2C asyncId\x2C recurring);\n    }\x2C\n\n    before(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskStarted(asyncId);\n    }\x2C\n\n    after(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskFinished(asyncId);\n    }\x2C\n\n    destroy(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return this.promiseIds.delete(asyncId);\n      inspector.asyncTaskCanceled(asyncId);\n    }\x2C\n  });\n\n  hook.promiseIds = new SafeSet();\n}\n\nfunction enable() {\n  if (hook === undefined) lazyHookCreation();\n  if (config.bits < 64) {\n    // V8 Inspector stores task ids as (void*) pointers.\n    // async_hooks store ids as 64bit numbers.\n    // As a result\x2C we cannot reliably translate async_hook ids to V8 async_task\n    // ids on 32bit platforms.\n    process.emitWarning(\n      'Warning: Async stack traces in debugger are not available ' +\n      `on ${config.bits}bit platforms. The feature is disabled.`\x2C\n      {\n        code: 'INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE'\x2C\n      });\n  } else {\n    hook.enable();\n  }\n}\n\nfunction disable() {\n  if (hook === undefined) lazyHookCreation();\n  hook.disable();\n}\n\nmodule.exports = {\n  enable\x2C\n  disable\n};\n
code-source-info,0x1eea2da8fdf6,94,0,1972,C0O0C4O1972,,
code-creation,Function,10,82338,0x1eea2da90016,79, node:internal/inspector_async_hook:1:1,0x1eea2da8fd70,~
code-source-info,0x1eea2da90016,94,0,1972,C0O0C42O19C43O19C45O29C46O29C48O48C54O1930C61O1951C67O1961C73O1945C78O1971,,
code-creation,LazyCompile,10,82454,0x1eea2da9050e,69,setupWarningHandler node:internal/bootstrap/pre_execution:142:29,0x1eea2da815a8,~
code-source-info,0x1eea2da9050e,92,4571,4768,C0O4606C6O4606C11O4590C16O4645C24O4649C33O4693C38O4697C45O4714C50O4729C53O4737C61O4737C68O4767,,
code-creation,LazyCompile,10,82529,0x1eea2da9066e,20,addListener node:events:486:58,0x1eeab58f2ce0,~
code-source-info,0x1eea2da9066e,13,14192,14264,C0O14213C14O14220C19O14262,,
code-creation,LazyCompile,10,82630,0x1eea2da90936,387,_addListener node:events:418:22,0x1eeab58f2c40,~
code-source-info,0x1eea2da90936,13,11979,13994,C0O12021C2O12030C4O12044C6O12057C9O12057C13O12101C18O12112C20O12144C22O12170C27O12170C32O12168C39O12194C40O12214C46O12380C52O12422C60O12475C77O12422C82O12654C87O12673C89O12690C93O12705C97O12816C99O12829C103O12845C109O12854C115O12883C121O12988C129O13022C140O13033C149O13043C166O13056C175O13066C182O13012C193O13141C197O13171C202O13171C209O13218C214O13218C219O13276C222O13280C227O13310C228O13316C233O13332C240O13339C245O13356C251O13372C252O13388C256O13521C264O13618C278O13628C281O13628C295O13578C304O13694C307O13702C312O13694C327O13654C333O13733C339O13521C345O13815C347O13822C351O13861C353O13871C357O13887C359O13894C363O13927C367O13916C371O13941C374O13949C379O13949C384O13978C386O13992,,
code-creation,LazyCompile,10,82710,0x1eea2da90c6e,15,checkListener node:events:127:23,0x1eeab58f25a0,~
code-source-info,0x1eea2da90c6e,13,3670,3726,C0O3685C8O3685C14O3725,,
code-creation,LazyCompile,10,82758,0x1eea2da90d5e,30, node:internal/validators:235:42,0x1eea1f7da390,~
code-source-info,0x1eea2da90d5e,17,7207,7323,C0O7228C6O7265C22O7271C27O7265C29O7322,,
code-creation,LazyCompile,10,82847,0x1eea2da90ed6,172,startListeningIfSignal node:internal/process/signal:22:32,0x1eea35d0be98,~
script-source,89,node:internal/process/signal,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n} = require('internal/errors');\n\nconst { signals } = internalBinding('constants').os;\n\nlet Signal;\nconst signalWraps = new SafeMap();\n\nfunction isSignal(event) {\n  return typeof event === 'string' && signals[event] !== undefined;\n}\n\n// Detect presence of a listener for the special signal types\nfunction startListeningIfSignal(type) {\n  if (isSignal(type) && !signalWraps.has(type)) {\n    if (Signal === undefined)\n      Signal = internalBinding('signal_wrap').Signal;\n    const wrap = new Signal();\n\n    wrap.unref();\n\n    wrap.onsignal = FunctionPrototypeBind(process.emit\x2C process\x2C type\x2C type);\n\n    const signum = signals[type];\n    const err = wrap.start(signum);\n    if (err) {\n      wrap.close();\n      throw errnoException(err\x2C 'uv_signal_start');\n    }\n\n    signalWraps.set(type\x2C wrap);\n  }\n}\n\nfunction stopListeningIfSignal(type) {\n  const wrap = signalWraps.get(type);\n  if (wrap !== undefined && process.listenerCount(type) === 0) {\n    wrap.close();\n    signalWraps.delete(type);\n  }\n}\n\nmodule.exports = {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\n};\n
code-source-info,0x1eea2da90ed6,89,429,904,C0O440C3O444C11O463C14O475C19O475C26O492C32O524C38O533C43O563C50O531C56O589C61O589C67O613C72O613C76O627C78O643C84O673C98O643C103O641C107O721C114O728C118O757C123O757C129O776C131O798C136O798C140O813C148O819C153O813C154O870C159O882C164O882C171O903,,
code-creation,LazyCompile,10,82977,0x1eea2da91296,19,isSignal node:internal/process/signal:17:18,0x1eea35d0bce0,~
code-source-info,0x1eea2da91296,89,255,334,C0O267C8O303C13O310C17O318C18O332,,
tick,0x7fff202f9f3f,83030,0,0x0,3,0x10f0ac650,0x1eea2da90ed9,0x1eea4787bc52,0x1eea2da90983,0x1eea2da9067c,0x1eea2da9054b,0x1eea2da8487c,0x1eea4787e23d
code-creation,LazyCompile,10,83052,0x1eea2da91436,75,setupDebugEnv node:internal/bootstrap/pre_execution:194:23,0x1eea2da81710,~
code-source-info,0x1eea2da91436,92,6034,6244,C0O6041C6O6041C11O6074C19O6102C24O6106C29O6075C34O6121C42O6125C48O6169C54O6169C59O6206C64O6219C69O6220C74O6243,,
code-creation,LazyCompile,10,83135,0x1eea2da917ce,159,initializeDebugEnv node:internal/util/debuglog:22:28,0x1eeac207a790,~
script-source,40,node:internal/util/debuglog,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst { inspect\x2C format\x2C formatWithOptions } = require('internal/util/inspect');\n\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\nlet debugImpls;\nlet testEnabled;\n\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = ObjectCreate(null);\n  if (debugEnv) {\n    // This is run before any user code\x2C it's OK not to use primordials.\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g\x2C '\\\\$&')\n      .replaceAll('*'\x2C '.*')\n      .replaceAll('\x2C'\x2C '$|^');\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`\x2C 'i');\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex\x2C str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\n      'data (such as passwords\x2C tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nconst noop = () => {};\n\nfunction debuglogImpl(enabled\x2C set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = process.stderr.hasColors && process.stderr.hasColors();\n        const msg = formatWithOptions({ colors }\x2C ...args);\n        const coloredPID = inspect(pid\x2C { colors });\n        process.stderr.write(format('%s %s: %s\\n'\x2C set\x2C coloredPID\x2C msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG\x2C\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set\x2C cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled\x2C set);\n    if (typeof cb === 'function')\n      cb(debug);\n    switch (args.length) {\n      case 0: return debug();\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 0: return debug();\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger\x2C 'enabled'\x2C {\n    get() {\n      return test();\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog\x2C\n  initializeDebugEnv\n};\n
code-source-info,0x1eea2da917ce,40,546,991,C0O561C7O574C14O572C20O596C31O709C44O709C51O753C62O754C69O782C80O783C88O833C100O848C116O833C121O833C123O871C132O883C144O959C151O971C158O990,,
code-creation,LazyCompile,10,83423,0x1eea2da91ebe,49,setupStacktracePrinterOnSigint node:internal/bootstrap/pre_execution:173:40,0x1eea2da81648,~
code-source-info,0x1eea2da91ebe,92,5598,5784,C0O5605C8O5610C14O5650C15O5657C16O5691C22O5691C27O5672C32O5741C38O5774C43O5774C48O5783,,
code-creation,LazyCompile,10,83610,0x1eea2da9212e,62,initializeReport node:internal/bootstrap/pre_execution:183:26,0x1eea2da81698,~
code-source-info,0x1eea2da9212e,92,5811,6010,C0O5811C8O5837C16O5837C21O5826C27O5875C42O5896C47O5968C55O5875C61O6009,,
tick,0x10ebc7296,84272,1,0x10ea6ba00,2,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea2da9213e,0x1eea2da848bc,0x1eea4787e23d
code-creation,Eval,10,84488,0x1eea2da926ae,5, node:internal/process/report:1:1,0x1eea2da924a8,~
script-source,95,node:internal/process/report,'use strict';\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_SYNTHETIC\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n  validateSignalName\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst nr = internalBinding('report');\nconst {\n  JSONParse\x2C\n} = primordials;\nconst report = {\n  writeReport(file\x2C err) {\n    if (typeof file === 'object' && file !== null) {\n      err = file;\n      file = undefined;\n    } else if (file !== undefined && typeof file !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('file'\x2C 'String'\x2C file);\n    } else if (err === undefined) {\n      err = new ERR_SYNTHETIC();\n    } else {\n      validateObject(err\x2C 'err');\n    }\n\n    return nr.writeReport('JavaScript API'\x2C 'API'\x2C file\x2C err);\n  }\x2C\n  getReport(err) {\n    if (err === undefined)\n      err = new ERR_SYNTHETIC();\n    else\n      validateObject(err\x2C 'err');\n\n    return JSONParse(nr.getReport(err));\n  }\x2C\n  get directory() {\n    return nr.getDirectory();\n  }\x2C\n  set directory(dir) {\n    validateString(dir\x2C 'directory');\n    nr.setDirectory(dir);\n  }\x2C\n  get filename() {\n    return nr.getFilename();\n  }\x2C\n  set filename(name) {\n    validateString(name\x2C 'filename');\n    nr.setFilename(name);\n  }\x2C\n  get compact() {\n    return nr.getCompact();\n  }\x2C\n  set compact(b) {\n    validateBoolean(b\x2C 'compact');\n    nr.setCompact(b);\n  }\x2C\n  get signal() {\n    return nr.getSignal();\n  }\x2C\n  set signal(sig) {\n    validateSignalName(sig\x2C 'signal');\n    removeSignalHandler();\n    addSignalHandler(sig);\n    nr.setSignal(sig);\n  }\x2C\n  get reportOnFatalError() {\n    return nr.shouldReportOnFatalError();\n  }\x2C\n  set reportOnFatalError(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnFatalError(trigger);\n  }\x2C\n  get reportOnSignal() {\n    return nr.shouldReportOnSignal();\n  }\x2C\n  set reportOnSignal(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnSignal(trigger);\n    removeSignalHandler();\n    addSignalHandler();\n  }\x2C\n  get reportOnUncaughtException() {\n    return nr.shouldReportOnUncaughtException();\n  }\x2C\n  set reportOnUncaughtException(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnUncaughtException(trigger);\n  }\n};\n\nfunction addSignalHandler(sig) {\n  if (nr.shouldReportOnSignal()) {\n    if (typeof sig !== 'string')\n      sig = nr.getSignal();\n\n    process.on(sig\x2C signalHandler);\n  }\n}\n\nfunction removeSignalHandler() {\n  const sig = nr.getSignal();\n\n  if (sig)\n    process.removeListener(sig\x2C signalHandler);\n}\n\nfunction signalHandler(sig) {\n  nr.writeReport(sig\x2C 'Signal'\x2C null\x2C '');\n}\n\nmodule.exports = {\n  addSignalHandler\x2C\n  report\n};\n
code-source-info,0x1eea2da926ae,95,0,2623,C0O0C4O2623,,
code-creation,Function,10,84716,0x1eea2da931c6,315, node:internal/process/report:1:1,0x1eea2da92628,~
code-source-info,0x1eea2da931c6,95,0,2623,C0O0C51O66C54O66C59O92C64O24C70O48C76O189C79O189C84O110C90O129C96O147C102O169C108O232C111O232C115O232C117O269C123O312C128O316C136O756C290O2572C297O2593C303O2613C309O2587C314O2622,,
code-creation,LazyCompile,10,84926,0x1eea2da94f06,21,initializeReportSignalHandlers node:internal/bootstrap/pre_execution:202:40,0x1eea2da81760,~
code-source-info,0x1eea2da94f06,92,6345,6441,C0O6381C6O6381C11O6360C16O6420C20O6440,,
code-creation,LazyCompile,10,84987,0x1eea2da9504e,57,addSignalHandler node:internal/process/report:97:26,0x1eea2da926e0,~
code-source-info,0x1eea2da9504e,95,2222,2368,C0O2232C5O2239C10O2239C16O2269C22O2304C27O2313C32O2313C38O2331C41O2339C49O2339C56O2367,,
code-creation,LazyCompile,10,85040,0x1eea2da9560e,92,initializeHeapSnapshotSignalHandlers node:internal/bootstrap/pre_execution:208:46,0x1eea2da817b0,~
code-source-info,0x1eea2da9560e,92,6488,6750,C0O6488C8O6510C18O6510C23O6554C25O6571C26O6578C27O6582C35O6582C40O6612C45O6613C50O6673C58O6673C63O6651C69O6691C74O6699C79O6702C84O6699C91O6749,,
code-creation,LazyCompile,10,85102,0x1eea2da9589e,138,setupChildProcessIpcChannel node:internal/bootstrap/pre_execution:338:37,0x1eea2da81980,~
code-source-info,0x1eea2da9589e,92,10502,11031,C0O10509C3O10521C8O10525C14O10563C20O10563C25O10607C33O10630C38O10634C46O10607C52O10660C53O10670C57O10660C61O10751C64O10766C73O10824C76O10832C81O10836C90O10883C93O10898C102O10940C108O10940C113O10964C118O10965C124O11004C127O11019C132O11004C137O11030,,
code-creation,LazyCompile,10,85219,0x1eea2da95c96,455,initializePolicy node:internal/bootstrap/pre_execution:366:26,0x1eea2da81a20,~
code-source-info,0x1eea2da95c96,92,11330,13128,C0O11364C10O11364C15O11407C17O11437C21O11445C35O11445C41O11570C49O11570C55O11547C60O11562C65O11689C67O11706C75O11710C81O11725C87O11726C94O11766C100O11798C108O11780C116O11855C120O11877C126O11877C132O11855C138O11891C149O11907C153O11921C161O11935C167O11993C175O11993C180O12027C190O12027C197O12102C207O12102C212O12144C214O12197C222O12197C227O12275C235O12275C241O12243C246O12255C251O12324C257O12324C263O12374C269O12374C275O12433C277O12459C279O12483C283O12464C288O12573C290O12589C295O12524C300O12552C305O12615C311O12651C317O12651C322O12692C328O12692C334O12721C340O12741C344O12728C349O12761C356O12808C358O12837C360O12878C366O12900C376O12900C383O12878C389O12492C394O12446C397O12935C401O12962C415O12968C420O12962C421O13051C429O13051C435O13092C441O13116C447O13093C454O13127,,
code-creation,LazyCompile,10,85314,0x1eea2da96086,63,initializeClusterIPC node:internal/bootstrap/pre_execution:357:30,0x1eea2da819d0,~
code-source-info,0x1eea2da96086,92,11062,11303,C0O11069C3O11081C10O11085C18O11100C23O11104C29O11142C35O11142C40O11174C45O11174C49O11263C52O11278C62O11302,,
code-creation,LazyCompile,10,85358,0x1eea2da961f6,27,initializeSourceMapsHandlers node:internal/bootstrap/pre_execution:461:38,0x1eea2da81b60,~
code-source-info,0x1eea2da961f6,92,14819,14968,C0O14863C6O14863C11O14834C16O14914C21O14943C26O14967,,
tick,0x10f0dc1bc,85465,1,0x10ea6ba00,5,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea2da961fc,0x1eea2da848e0,0x1eea4787e23d
code-creation,Eval,10,86264,0x1eea2da96b76,5, node:internal/source_map/source_map_cache:1:1,0x1eea2da96810,~
script-source,96,node:internal/source_map/source_map_cache,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeSplit\x2C\n} = primordials;\n\nfunction ObjectGetValueSafe(obj\x2C key) {\n  const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'value') ? desc.value : undefined;\n}\n\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('source_map'\x2C (fn) => {\n  debug = fn;\n});\nconst fs = require('fs');\nconst { getOptionValue } = require('internal/options');\nconst { IterableWeakMap } = require('internal/util/iterable_weak_map');\nconst {\n  normalizeReferrerURL\x2C\n} = require('internal/modules/cjs/helpers');\nconst { validateBoolean } = require('internal/validators');\n// Since the CJS module cache is mutable\x2C which leads to memory leaks when\n// modules are deleted\x2C we use a WeakMap so that the source map cache will\n// be purged automatically:\nconst cjsSourceMapCache = new IterableWeakMap();\n// The esm cache is not mutable\x2C so we can use a Map without memory concerns:\nconst esmSourceMapCache = new SafeMap();\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\nlet SourceMap;\n\nlet sourceMapsEnabled;\nfunction getSourceMapsEnabled() {\n  if (sourceMapsEnabled === undefined) {\n    setSourceMapsEnabled(getOptionValue('--enable-source-maps'));\n  }\n  return sourceMapsEnabled;\n}\n\nfunction setSourceMapsEnabled(val) {\n  validateBoolean(val\x2C 'val');\n\n  const {\n    setSourceMapsEnabled\x2C\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  setSourceMapsEnabled(val);\n  if (val) {\n    const {\n      prepareStackTrace\n    } = require('internal/source_map/prepare_stack_trace');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  } else if (sourceMapsEnabled !== undefined) {\n    // Reset prepare stack trace callback only when disabling source maps.\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/errors');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n\n  sourceMapsEnabled = val;\n}\n\nfunction maybeCacheSourceMap(filename\x2C content\x2C cjsModuleInstance) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n  try {\n    filename = normalizeReferrerURL(filename);\n  } catch (err) {\n    // This is most likely an [eval]-wrapper\x2C which is currently not\n    // supported.\n    debug(err.stack);\n    return;\n  }\n  const match = StringPrototypeMatch(\n    content\x2C\n    /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/\n  );\n  if (match) {\n    const data = dataFromUrl(filename\x2C match.groups.sourceMappingURL);\n    const url = data ? null : match.groups.sourceMappingURL;\n    if (cjsModuleInstance) {\n      cjsSourceMapCache.set(cjsModuleInstance\x2C {\n        filename\x2C\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    } else {\n      // If there is no cjsModuleInstance assume we are in a\n      // "modules/esm" context.\n      esmSourceMapCache.set(filename\x2C {\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    }\n  }\n}\n\nfunction dataFromUrl(sourceURL\x2C sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case 'data:':\n        return sourceMapFromDataUrl(sourceURL\x2C url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err.stack);\n    // If no scheme is present\x2C we assume we are dealing with a file path.\n    const mapURL = new URL(sourceMappingURL\x2C sourceURL).href;\n    return sourceMapFromFile(mapURL);\n  }\n}\n\n// Cache the length of each line in the file that a source map was extracted\n// from. This allows translation from byte offset V8 coverage reports\x2C\n// to line/column offset Source Map V3.\nfunction lineLengths(content) {\n  // We purposefully keep \\r as part of the line-length calculation\x2C in\n  // cases where there is a \\r\\n separator\x2C so that this can be taken into\n  // account in coverage calculations.\n  return ArrayPrototypeMap(StringPrototypeSplit(content\x2C /\\n|\\u2028|\\u2029/)\x2C (line) => {\n    return line.length;\n  });\n}\n\nfunction sourceMapFromFile(mapURL) {\n  try {\n    const content = fs.readFileSync(fileURLToPath(mapURL)\x2C 'utf8');\n    const data = JSONParse(content);\n    return sourcesToAbsolute(mapURL\x2C data);\n  } catch (err) {\n    debug(err.stack);\n    return null;\n  }\n}\n\n// data:[<mediatype>][;base64]\x2C<data> see:\n// https://tools.ietf.org/html/rfc2397#section-2\nfunction sourceMapFromDataUrl(sourceURL\x2C url) {\n  const { 0: format\x2C 1: data } = StringPrototypeSplit(url\x2C '\x2C');\n  const splitFormat = StringPrototypeSplit(format\x2C ';');\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\n  if (contentType === 'application/json') {\n    const decodedData = base64 ?\n      Buffer.from(data\x2C 'base64').toString('utf8') : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(sourceURL\x2C parsedData);\n    } catch (err) {\n      debug(err.stack);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\n\n// If the sources are not absolute URLs after prepending of the "sourceRoot"\x2C\n// the sources are resolved relative to the SourceMap (like resolving script\n// src in a html document).\nfunction sourcesToAbsolute(baseURL\x2C data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || '') + source;\n    return new URL(source\x2C baseURL).href;\n  });\n  // The sources array is now resolved to absolute URLs\x2C sourceRoot should\n  // be updated to noop.\n  data.sourceRoot = '';\n  return data;\n}\n\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\n// shutdown. In particular\x2C they also run when Workers are terminated\x2C making\n// it important that they do not call out to any user-provided code\x2C including\n// built-in prototypes that might have been tampered with.\n\n// Get serialized representation of source-map cache\x2C this is used\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\nfunction sourceMapCacheToObject() {\n  const obj = ObjectCreate(null);\n\n  for (const { 0: k\x2C 1: v } of esmSourceMapCache) {\n    obj[k] = v;\n  }\n\n  appendCJSCache(obj);\n\n  if (ObjectKeys(obj).length === 0) {\n    return undefined;\n  }\n  return obj;\n}\n\nfunction appendCJSCache(obj) {\n  for (const value of cjsSourceMapCache) {\n    obj[ObjectGetValueSafe(value\x2C 'filename')] = {\n      lineLengths: ObjectGetValueSafe(value\x2C 'lineLengths')\x2C\n      data: ObjectGetValueSafe(value\x2C 'data')\x2C\n      url: ObjectGetValueSafe(value\x2C 'url')\n    };\n  }\n}\n\nfunction findSourceMap(sourceURL) {\n  if (!RegExpPrototypeTest(/^\\w+:\\/\\//\x2C sourceURL)) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  if (!SourceMap) {\n    SourceMap = require('internal/source_map/source_map').SourceMap;\n  }\n  let sourceMap = esmSourceMapCache.get(sourceURL);\n  if (sourceMap === undefined) {\n    for (const value of cjsSourceMapCache) {\n      const filename = ObjectGetValueSafe(value\x2C 'filename');\n      if (sourceURL === filename) {\n        sourceMap = {\n          data: ObjectGetValueSafe(value\x2C 'data')\n        };\n      }\n    }\n  }\n  if (sourceMap && sourceMap.data) {\n    return new SourceMap(sourceMap.data);\n  }\n  return undefined;\n}\n\nmodule.exports = {\n  findSourceMap\x2C\n  getSourceMapsEnabled\x2C\n  setSourceMapsEnabled\x2C\n  maybeCacheSourceMap\x2C\n  sourceMapCacheToObject\x2C\n};\n
code-source-info,0x1eea2da96b76,96,0,7654,C0O0C4O7654,,
code-creation,Function,10,86844,0x1eea2da971ee,435, node:internal/source_map/source_map_cache:1:1,0x1eea2da96af0,~
code-source-info,0x1eea2da971ee,96,0,7654,C0O0C152O25C158O46C164O59C170O75C176O89C182O123C188O156C194O179C199O190C205O214C211O526C217O526C222O515C228O557C234O557C239O590C252O591C258O557C260O653C266O653C270O653C272O695C278O695C283O676C289O752C295O752C300O732C305O832C311O832C316O806C322O901C328O901C333O881C339O1137C341O1137C346O1137C348O1264C350O1264C355O1264C357O1325C363O1325C368O1287C374O1302C380O1317C386O1354C387O1354C389O1370C390O1370C392O7518C399O7539C405O7556C411O7580C417O7604C423O7627C429O7533C434O7653,,
tick,0x7fff203e5355,86900,1,0x10ea6ba00,3,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea2da961fc,0x1eea2da848e0,0x1eea4787e23d
code-creation,LazyCompile,10,87013,0x1eea2da97fd6,82,debuglog node:internal/util/debuglog:71:18,0x1eeac207aac8,~
code-source-info,0x1eea2da97fd6,40,2232,3279,C0O2232C28O2357C32O2357C34O2789C35O2789C37O2811C41O2811C43O2899C48O3128C58O3149C63O3174C74O3128C79O3263C81O3277,,
code-creation,Eval,10,87844,0x1eea2da98556,5, node:internal/util/iterable_weak_map:1:1,0x1eea2da98308,~
script-source,97,node:internal/util/iterable_weak_map,'use strict';\n\nconst {\n  ObjectFreeze\x2C\n  SafeFinalizationRegistry\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SymbolIterator\x2C\n} = primordials;\n\n// This class is modified from the example code in the WeakRefs specification:\n// https://github.com/tc39/proposal-weakrefs\n// Licensed under ECMA's MIT-style license\x2C see:\n// https://github.com/tc39/ecma262/blob/HEAD/LICENSE.md\nclass IterableWeakMap {\n  #weakMap = new SafeWeakMap();\n  #refSet = new SafeSet();\n  #finalizationGroup = new SafeFinalizationRegistry(cleanup);\n\n  set(key\x2C value) {\n    const entry = this.#weakMap.get(key);\n    if (entry) {\n      // If there's already an entry for the object represented by "key"\x2C\n      // the value can be updated without creating a new WeakRef:\n      this.#weakMap.set(key\x2C { value\x2C ref: entry.ref });\n    } else {\n      const ref = new SafeWeakRef(key);\n      this.#weakMap.set(key\x2C { value\x2C ref });\n      this.#refSet.add(ref);\n      this.#finalizationGroup.register(key\x2C {\n        set: this.#refSet\x2C\n        ref\n      }\x2C ref);\n    }\n  }\n\n  get(key) {\n    return this.#weakMap.get(key)?.value;\n  }\n\n  has(key) {\n    return this.#weakMap.has(key);\n  }\n\n  delete(key) {\n    const entry = this.#weakMap.get(key);\n    if (!entry) {\n      return false;\n    }\n    this.#weakMap.delete(key);\n    this.#refSet.delete(entry.ref);\n    this.#finalizationGroup.unregister(entry.ref);\n    return true;\n  }\n\n  [SymbolIterator]() {\n    const iterator = this.#refSet[SymbolIterator]();\n\n    const next = () => {\n      const result = iterator.next();\n      if (result.done) return result;\n      const key = result.value.deref();\n      if (key == null) return next();\n      const { value } = this.#weakMap.get(key);\n      return { done: false\x2C value };\n    };\n\n    return {\n      [SymbolIterator]() { return this; }\x2C\n      next\x2C\n    };\n  }\n}\n\nfunction cleanup({ set\x2C ref }) {\n  set.delete(ref);\n}\n\nObjectFreeze(IterableWeakMap.prototype);\n\nmodule.exports = {\n  IterableWeakMap\x2C\n};\n
code-source-info,0x1eea2da98556,97,0,1958,C0O0C4O1958,,
code-creation,Function,10,88050,0x1eea2da98cb6,196, node:internal/util/iterable_weak_map:1:1,0x1eea2da984d0,~
code-source-info,0x1eea2da98cb6,97,0,1958,C0O0C26O25C31O41C37O69C43O80C49O95C55O110C134O1392C168O1904C173O1875C177O1917C184O1938C190O1932C195O1957,,
code-creation,Function,10,88079,0x1eea2da98e36,75,<instance_members_initializer> node:internal/util/iterable_weak_map:17:3,0x1eea2da987e0,~
code-source-info,0x1eea2da98e36,97,399,516,C3O410C10O410C27O441C34O441C48O479C62O479C74O516,,
tick,0x10ee51c41,88109,1,0x10ea6ba00,3,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea2da97315,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da961fc,0x1eea2da848e0,0x1eea4787e23d
tick,0x10ebc7296,89009,1,0x10ea6ba00,2,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea2da97325,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da961fc,0x1eea2da848e0,0x1eea4787e23d
code-creation,Eval,10,89214,0x1eea2da99afe,5, node:internal/modules/cjs/helpers:1:1,0x1eea2da99848,~
script-source,98,node:internal/modules/cjs/helpers,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeSome\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_UNKNOWN_BUILTIN_MODULE\n} = require('internal/errors').codes;\nconst { NativeModule } = require('internal/bootstrap/loaders');\n\nconst { validateString } = require('internal/validators');\nconst path = require('path');\nconst { pathToFileURL\x2C fileURLToPath\x2C URL } = require('internal/url');\n\nconst { getOptionValue } = require('internal/options');\nconst userConditions = getOptionValue('--conditions');\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\n// TODO: Use this set when resolving pkg#exports conditions in loader.js.\nconst cjsConditions = new SafeSet([\n  'require'\x2C\n  'node'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nfunction loadNativeModule(filename\x2C request) {\n  const mod = NativeModule.map.get(filename);\n  if (mod?.canBeRequiredByUsers) {\n    debug('load native module %s'\x2C request);\n    // compileForPublicLoader() throws if mod.canBeRequiredByUsers is false:\n    mod.compileForPublicLoader();\n    return mod;\n  }\n}\n\n// Invoke with makeRequireFunction(module) where |module| is the Module object\n// to use as the context for the require() function.\n// Use redirects to set up a mapping from a policy and restrict dependencies\nconst urlToFileCache = new SafeMap();\nfunction makeRequireFunction(mod\x2C redirects) {\n  const Module = mod.constructor;\n\n  let require;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = cjsConditions;\n    const { resolve\x2C reaction } = redirects;\n    require = function require(specifier) {\n      let missing = true;\n      const destination = resolve(specifier\x2C conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        if (destination.protocol === 'node:') {\n          const specifier = destination.pathname;\n          const mod = loadNativeModule(specifier\x2C href);\n          if (mod && mod.canBeRequiredByUsers) {\n            return mod.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\n        } else if (destination.protocol === 'file:') {\n          let filepath;\n          if (urlToFileCache.has(href)) {\n            filepath = urlToFileCache.get(href);\n          } else {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href\x2C filepath);\n          }\n          return mod.require(filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          id\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C ')\n        ));\n      }\n      return mod.require(specifier);\n    };\n  } else {\n    require = function require(path) {\n      return mod.require(path);\n    };\n  }\n\n  function resolve(request\x2C options) {\n    validateString(request\x2C 'request');\n    return Module._resolveFilename(request\x2C mod\x2C false\x2C options);\n  }\n\n  require.resolve = resolve;\n\n  function paths(request) {\n    validateString(request\x2C 'request');\n    return Module._resolveLookupPaths(request\x2C mod);\n  }\n\n  resolve.paths = paths;\n\n  require.main = process.mainModule;\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF\x2C the UTF-16 BOM.\n */\nfunction stripBOM(content) {\n  if (StringPrototypeCharCodeAt(content) === 0xFEFF) {\n    content = StringPrototypeSlice(content\x2C 1);\n  }\n  return content;\n}\n\nfunction addBuiltinLibsToObject(object\x2C dummyModuleName) {\n  // Make built-in modules available directly (loaded lazily).\n  const Module = require('internal/modules/cjs/loader').Module;\n  const { builtinModules } = Module;\n\n  // To require built-in modules in user-land and ignore modules whose\n  // `canBeRequiredByUsers` is false. So we create a dummy module object and not\n  // use `require()` directly.\n  const dummyModule = new Module(dummyModuleName);\n\n  ArrayPrototypeForEach(builtinModules\x2C (name) => {\n    // Neither add underscored modules\x2C nor ones that contain slashes (e.g.\x2C\n    // 'fs/promises') or ones that are already defined.\n    if (StringPrototypeStartsWith(name\x2C '_') ||\n        StringPrototypeIncludes(name\x2C '/') ||\n        ObjectPrototypeHasOwnProperty(object\x2C name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object\x2C name\x2C {\n      get: () => {\n        const lib = dummyModule.require(name);\n\n        // Disable the current getter/setter and set up a new\n        // non-enumerable property.\n        delete object[name];\n        ObjectDefineProperty(object\x2C name\x2C {\n          get: () => lib\x2C\n          set: setReal\x2C\n          configurable: true\x2C\n          enumerable: false\n        });\n\n        return lib;\n      }\x2C\n      set: setReal\x2C\n      configurable: true\x2C\n      enumerable: false\n    });\n  });\n}\n\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\n\n// For error messages only - used to check if ESM syntax is in use.\nfunction hasEsmSyntax(code) {\n  debug('Checking for ESM syntax');\n  const parser = require('internal/deps/acorn/acorn/dist/acorn').Parser;\n  let root;\n  try {\n    root = parser.parse(code\x2C { sourceType: 'module'\x2C ecmaVersion: 'latest' });\n  } catch {\n    return false;\n  }\n\n  return ArrayPrototypeSome(root.body\x2C (stmt) =>\n    stmt.type === 'ExportDefaultDeclaration' ||\n    stmt.type === 'ExportNamedDeclaration' ||\n    stmt.type === 'ImportDeclaration' ||\n    stmt.type === 'ExportAllDeclaration');\n}\n\nmodule.exports = {\n  addBuiltinLibsToObject\x2C\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n};\n
code-source-info,0x1eea2da99afe,98,0,6746,C0O0C4O6746,,
code-creation,Function,10,89712,0x1eea2da9a07e,536, node:internal/modules/cjs/helpers:1:1,0x1eea2da99a78,~
code-source-info,0x1eea2da9a07e,98,0,6746,C0O0C104O25C110O50C116O72C122O94C128O118C134O151C139O162C144O173C150O202C156O229C162O253C168O373C174O373C179O399C184O307C190O342C196O432C202O432C207O415C213O499C219O499C224O480C230O544C236O544C240O544C242O607C248O607C253O569C259O584C265O599C271O660C277O660C282O641C287O712C290O712C295O757C301O757C306O790C319O791C325O757C327O856C330O856C335O911C346O1041C353O1083C354O1083C410O1105C465O1041C470O1041C472O1665C474O1665C479O1665C481O6586C488O6607C494O6633C500O6650C506O6666C512O6686C518O6709C524O6733C530O6601C535O6745,,
tick,0x10f48e5c0,90174,0,0x0,0,0x1eea2da9a1e0,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da97325,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da961fc,0x1eea2da848e0,0x1eea4787e23d
code-creation,LazyCompile,10,90641,0x1eea2da9acbe,27,SafeSet node:internal/per_context/primordials:364:16,0x1eeab58c9fc0,~
script-source,6,node:internal/per_context/primordials,'use strict';\n\n/* eslint-disable node-core/prefer-primordials */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy\x2C which can be mutated by users.\n\n// Use of primordials have sometimes a dramatic impact on performance\x2C please\n// benchmark all changes made in performance-sensitive areas of the codebase.\n// See: https://github.com/nodejs/node/pull/38248\n\nconst {\n  defineProperty: ReflectDefineProperty\x2C\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor\x2C\n  ownKeys: ReflectOwnKeys\x2C\n} = Reflect;\n\n// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.\n// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.call` after it may have been mutated by users.\nconst { apply\x2C bind\x2C call } = Function.prototype;\nconst uncurryThis = bind.bind(call);\nprimordials.uncurryThis = uncurryThis;\n\n// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.\n// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.apply` after it may have been mutated by users.\nconst applyBind = bind.bind(apply);\nprimordials.applyBind = applyBind;\n\n// Methods that accept a variable number of arguments\x2C and thus it's useful to\n// also create `${prefix}${key}Apply`\x2C which uses `Function.prototype.apply`\x2C\n// instead of `Function.prototype.call`\x2C and thus doesn't require iterator\n// destructuring.\nconst varargsMethods = [\n  // 'ArrayPrototypeConcat' is omitted\x2C because it performs the spread\n  // on its own for arrays and array-likes with a truthy\n  // @@isConcatSpreadable symbol property.\n  'ArrayOf'\x2C\n  'ArrayPrototypePush'\x2C\n  'ArrayPrototypeUnshift'\x2C\n  // 'FunctionPrototypeCall' is omitted\x2C since there's 'ReflectApply'\n  // and 'FunctionPrototypeApply'.\n  'MathHypot'\x2C\n  'MathMax'\x2C\n  'MathMin'\x2C\n  'StringPrototypeConcat'\x2C\n  'TypedArrayOf'\x2C\n];\n\nfunction getNewKey(key) {\n  return typeof key === 'symbol' ?\n    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :\n    `${key[0].toUpperCase()}${key.slice(1)}`;\n}\n\nfunction copyAccessor(dest\x2C prefix\x2C key\x2C { enumerable\x2C get\x2C set }) {\n  ReflectDefineProperty(dest\x2C `${prefix}Get${key}`\x2C {\n    value: uncurryThis(get)\x2C\n    enumerable\n  });\n  if (set !== undefined) {\n    ReflectDefineProperty(dest\x2C `${prefix}Set${key}`\x2C {\n      value: uncurryThis(set)\x2C\n      enumerable\n    });\n  }\n}\n\nfunction copyPropsRenamed(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          // `src` is bound as the `this` so that the static `this` points\n          // to the object it was defined on\x2C\n          // e.g.: `ArrayOfApply` gets a `this` of `Array`:\n          value: applyBind(desc.value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = value.bind(src);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPrototype(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = uncurryThis(value);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value)\x2C\n        });\n      }\n    }\n  }\n}\n\n// Create copies of configurable value properties of the global object\n[\n  'Proxy'\x2C\n  'globalThis'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  primordials[name] = globalThis[name];\n});\n\n// Create copies of URI handling functions\n[\n  decodeURI\x2C\n  decodeURIComponent\x2C\n  encodeURI\x2C\n  encodeURIComponent\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of the namespace objects\n[\n  'JSON'\x2C\n  'Math'\x2C\n  'Proxy'\x2C\n  'Reflect'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  copyPropsRenamed(global[name]\x2C primordials\x2C name);\n});\n\n// Create copies of intrinsic objects\n[\n  'AggregateError'\x2C\n  'Array'\x2C\n  'ArrayBuffer'\x2C\n  'BigInt'\x2C\n  'BigInt64Array'\x2C\n  'BigUint64Array'\x2C\n  'Boolean'\x2C\n  'DataView'\x2C\n  'Date'\x2C\n  'Error'\x2C\n  'EvalError'\x2C\n  'FinalizationRegistry'\x2C\n  'Float32Array'\x2C\n  'Float64Array'\x2C\n  'Function'\x2C\n  'Int16Array'\x2C\n  'Int32Array'\x2C\n  'Int8Array'\x2C\n  'Map'\x2C\n  'Number'\x2C\n  'Object'\x2C\n  'RangeError'\x2C\n  'ReferenceError'\x2C\n  'RegExp'\x2C\n  'Set'\x2C\n  'String'\x2C\n  'Symbol'\x2C\n  'SyntaxError'\x2C\n  'TypeError'\x2C\n  'URIError'\x2C\n  'Uint16Array'\x2C\n  'Uint32Array'\x2C\n  'Uint8Array'\x2C\n  'Uint8ClampedArray'\x2C\n  'WeakMap'\x2C\n  'WeakRef'\x2C\n  'WeakSet'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamed(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of abstract intrinsic objects that are not directly exposed\n// on the global object.\n// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object\n[\n  { name: 'TypedArray'\x2C original: Reflect.getPrototypeOf(Uint8Array) }\x2C\n  { name: 'ArrayIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n  { name: 'StringIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n].forEach(({ name\x2C original }) => {\n  primordials[name] = original;\n  // The static %TypedArray% methods require a valid `this`\x2C but can't be bound\x2C\n  // as they need a subclass constructor as the receiver:\n  copyPrototype(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n/* eslint-enable node-core/prefer-primordials */\n\nconst {\n  ArrayPrototypeForEach\x2C\n  FinalizationRegistry\x2C\n  FunctionPrototypeCall\x2C\n  Map\x2C\n  ObjectFreeze\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  Set\x2C\n  SymbolIterator\x2C\n  WeakMap\x2C\n  WeakRef\x2C\n  WeakSet\x2C\n} = primordials;\n\n// Because these functions are used by `makeSafe`\x2C which is exposed\n// on the `primordials` object\x2C it's important to use const references\n// to the primordials that they use:\nconst createSafeIterator = (factory\x2C next) => {\n  class SafeIterator {\n    constructor(iterable) {\n      this._iterator = factory(iterable);\n    }\n    next() {\n      return next(this._iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype\x2C null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nprimordials.SafeArrayIterator = createSafeIterator(\n  primordials.ArrayPrototypeSymbolIterator\x2C\n  primordials.ArrayIteratorPrototypeNext\n);\nprimordials.SafeStringIterator = createSafeIterator(\n  primordials.StringPrototypeSymbolIterator\x2C\n  primordials.StringIteratorPrototypeNext\n);\n\nconst copyProps = (src\x2C dest) => {\n  ArrayPrototypeForEach(ReflectOwnKeys(src)\x2C (key) => {\n    if (!ReflectGetOwnPropertyDescriptor(dest\x2C key)) {\n      ReflectDefineProperty(\n        dest\x2C\n        key\x2C\n        ReflectGetOwnPropertyDescriptor(src\x2C key));\n    }\n  });\n};\n\n/**\n * @type {typeof primordials.makeSafe}\n */\nconst makeSafe = (unsafe\x2C safe) => {\n  if (SymbolIterator in unsafe.prototype) {\n    const dummy = new unsafe();\n    let next; // We can reuse the same `next` method.\n\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype)\x2C (key) => {\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype\x2C key)) {\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype\x2C key);\n        if (\n          typeof desc.value === 'function' &&\n          desc.value.length === 0 &&\n          SymbolIterator in (FunctionPrototypeCall(desc.value\x2C dummy) ?? {})\n        ) {\n          const createIterator = uncurryThis(desc.value);\n          next ??= uncurryThis(createIterator(dummy).next);\n          const SafeIterator = createSafeIterator(createIterator\x2C next);\n          desc.value = function() {\n            return new SafeIterator(this);\n          };\n        }\n        ReflectDefineProperty(safe.prototype\x2C key\x2C desc);\n      }\n    });\n  } else {\n    copyProps(unsafe.prototype\x2C safe.prototype);\n  }\n  copyProps(unsafe\x2C safe);\n\n  ObjectSetPrototypeOf(safe.prototype\x2C null);\n  ObjectFreeze(safe.prototype);\n  ObjectFreeze(safe);\n  return safe;\n};\nprimordials.makeSafe = makeSafe;\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\n// Defining the `constructor` is necessary here to avoid the default\n// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.\nprimordials.SafeMap = makeSafe(\n  Map\x2C\n  class SafeMap extends Map {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap\x2C\n  class SafeWeakMap extends WeakMap {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeSet = makeSafe(\n  Set\x2C\n  class SafeSet extends Set {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakSet = makeSafe(\n  WeakSet\x2C\n  class SafeWeakSet extends WeakSet {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeFinalizationRegistry = makeSafe(\n  FinalizationRegistry\x2C\n  class SafeFinalizationRegistry extends FinalizationRegistry {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(cleanupCallback) { super(cleanupCallback); }\n  }\n);\nprimordials.SafeWeakRef = makeSafe(\n  WeakRef\x2C\n  class SafeWeakRef extends WeakRef {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(target) { super(target); }\n  }\n);\n\nconst SafePromise = makeSafe(\n  Promise\x2C\n  class SafePromise extends Promise {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(executor) { super(executor); }\n  }\n);\n\nprimordials.PromisePrototypeCatch = (thisPromise\x2C onRejected) =>\n  PromisePrototypeThen(thisPromise\x2C undefined\x2C onRejected);\n\n/**\n * Attaches a callback that is invoked when the Promise is settled (fulfilled or\n * rejected). The resolved value cannot be modified from the callback.\n * Prefer using async functions when possible.\n * @param {Promise<any>} thisPromise\n * @param {() => void) | undefined | null} onFinally The callback to execute\n *        when the Promise is settled (fulfilled or rejected).\n * @returns A Promise for the completion of the callback.\n */\nprimordials.SafePromisePrototypeFinally = (thisPromise\x2C onFinally) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    new SafePromise((a\x2C b) => PromisePrototypeThen(thisPromise\x2C a\x2C b))\n      .finally(onFinally)\n      .then(a\x2C b)\n  );\n\nprimordials.AsyncIteratorPrototype =\n  primordials.ReflectGetPrototypeOf(\n    primordials.ReflectGetPrototypeOf(\n      async function* () {}).prototype);\n\nObjectSetPrototypeOf(primordials\x2C null);\nObjectFreeze(primordials);\n
code-source-info,0x1eea2da9acbe,6,10527,10544,C3O10533C7O10539C11O10533C26O10543,,
tick,0x10e98ed2f,91548,0,0x0,3,0x10f0ac650,0x1eea2da9a24f,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da97325,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da961fc,0x1eea2da848e0,0x1eea4787e23d
code-creation,LazyCompile,10,91603,0x1eea2da9bafe,27,SafeMap node:internal/per_context/primordials:351:16,0x1eeab58c9e38,~
code-source-info,0x1eea2da9bafe,6,10200,10217,C3O10206C7O10212C11O10206C26O10216,,
code-creation,LazyCompile,10,91667,0x1eea2da9bc76,16,IterableWeakMap node:internal/util/iterable_weak_map:16:1,0x1eea2da985d8,~
code-source-info,0x1eea2da9bc76,97,373,373,C0O373C15O373,,
code-creation,LazyCompile,10,91706,0x1eea2da9bffe,27,SafeWeakMap node:internal/per_context/primordials:357:16,0x1eeab58c9ef8,~
code-source-info,0x1eea2da9bffe,6,10371,10388,C3O10377C7O10383C11O10377C26O10387,,
code-creation,LazyCompile,10,91768,0x1eea2da9c106,27,SafeFinalizationRegistry node:internal/per_context/primordials:378:16,0x1eeab58ca148,~
code-source-info,0x1eea2da9c106,6,10977,11022,C3O10997C7O11003C11O10997C26O11021,,
code-creation,LazyCompile,10,91929,0x1eea2da9c98e,492,initializeDeprecations node:internal/bootstrap/pre_execution:251:32,0x1eea2da818f0,~
code-source-info,0x1eea2da9c98e,92,7965,10464,C0O7965C11O7994C19O7994C24O7980C29O8049C39O8049C44O8240C52O8240C57O8281C65O8281C70O8334C99O8326C127O8326C130O8652C141O8672C145O8714C156O8788C167O8878C178O8833C187O8699C196O8937C199O8670C203O8315C269O9214C277O9214C282O9193C287O9243C289O9271C304O9292C311O9410C315O9271C320O9442C324O9472C334O9508C344O9585C351O9490C356O9488C360O9671C370O9713C381O9695C386O9693C390O10052C394O10052C396O10063C407O10084C418O10113C426O10155C434O10063C439O10268C445O10268C447O10278C458O10299C469O10327C477O10368C485O10278C491O10463,,
code-creation,LazyCompile,10,92051,0x1eea2da9cfbe,53,initializeWASI node:internal/bootstrap/pre_execution:415:24,0x1eea2da81a70,~
code-source-info,0x1eea2da9cfbe,92,13153,13359,C0O13185C6O13185C11O13168C16O13251C21O13255C29O13255C35O13270C37O13301C43O13301C47O13295C52O13358,,
code-creation,LazyCompile,10,92103,0x1eea2da9d18e,57,initializeCJSLoader node:internal/bootstrap/pre_execution:422:29,0x1eea2da81ac0,~
code-source-info,0x1eea2da9d18e,92,13389,13683,C0O13414C6O13414C11O13456C17O13498C22O13505C27O13505C31O13601C42O13622C47O13658C51O13616C56O13682,,
tick,0x10ebc9ee6,92676,1,0x10ea6ba00,2,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Eval,10,93106,0x1eea2da9f136,5, node:internal/modules/cjs/loader:1:1,0x1eea2da9e850,~
script-source,99,node:internal/modules/cjs/loader,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypeUnshiftApply\x2C\n  Boolean\x2C\n  Error\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototype\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Proxy\x2C\n  ReflectApply\x2C\n  ReflectSet\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\n// Map used to store CJS parsing data.\nconst cjsParseCache = new SafeWeakMap();\n\n// Set first due to cycle with ESM loader functions.\nmodule.exports = {\n  wrapSafe\x2C Module\x2C toRealPath\x2C readPackageScope\x2C cjsParseCache\x2C\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\n};\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  maybeCacheSourceMap\x2C\n} = require('internal/source_map/source_map_cache');\nconst { pathToFileURL\x2C fileURLToPath\x2C isURLInstance } = require('internal/url');\nconst { deprecate } = require('internal/util');\nconst vm = require('vm');\nconst assert = require('internal/assert');\nconst fs = require('fs');\nconst internalFS = require('internal/fs/utils');\nconst path = require('path');\nconst { sep } = path;\nconst { internalModuleStat } = internalBinding('fs');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { safeGetenv } = internalBinding('credentials');\nconst {\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst { getOptionValue } = require('internal/options');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\n// Whether any user-provided CJS modules had been loaded (executed).\n// Used for internal assertions.\nlet hasLoadedAnyUserCJSModule = false;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_MODULE_SPECIFIER\x2C\n    ERR_REQUIRE_ESM\x2C\n    ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  }\x2C\n  setArrowMessage\x2C\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\n} = require('internal/constants');\n\nconst {\n  isProxy\n} = require('internal/util/types');\n\nconst asyncESM = require('internal/process/esm_loader');\nconst { enrichCJSError } = require('internal/modules/esm/translators');\nconst { kEvaluated } = internalBinding('module_wrap');\nconst {\n  encodedSepRegEx\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\n} = require('internal/modules/esm/resolve');\n\nconst isWindows = process.platform === 'win32';\n\nconst relativeResolveCache = ObjectCreate(null);\n\nlet requireDepth = 0;\nlet statCache = null;\nlet isPreloading = false;\n\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename\x2C result);\n  }\n  return result;\n}\n\nfunction updateChildren(parent\x2C child\x2C scan) {\n  const children = parent?.children;\n  if (children && !(scan && ArrayPrototypeIncludes(children\x2C child)))\n    ArrayPrototypePush(children\x2C child);\n}\n\nconst moduleParentCache = new SafeWeakMap();\nfunction Module(id = ''\x2C parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  this.exports = {};\n  moduleParentCache.set(this\x2C parent);\n  updateChildren(parent\x2C this\x2C false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n\nconst builtinModules = [];\nfor (const { 0: id\x2C 1: mod } of NativeModule.map) {\n  if (mod.canBeRequiredByUsers) {\n    ArrayPrototypePush(builtinModules\x2C id);\n  }\n}\n\nObjectFreeze(builtinModules);\nModule.builtinModules = builtinModules;\n\nModule._cache = ObjectCreate(null);\nModule._pathCache = ObjectCreate(null);\nModule._extensions = ObjectCreate(null);\nlet modulePaths = [];\nModule.globalPaths = [];\n\nlet patched = false;\n\n// eslint-disable-next-line func-style\nlet wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nconst wrapper = [\n  '(function (exports\x2C require\x2C module\x2C __filename\x2C __dirname) { '\x2C\n  '\\n});'\x2C\n];\n\nlet wrapperProxy = new Proxy(wrapper\x2C {\n  set(target\x2C property\x2C value\x2C receiver) {\n    patched = true;\n    return ReflectSet(target\x2C property\x2C value\x2C receiver);\n  }\x2C\n\n  defineProperty(target\x2C property\x2C descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target\x2C property\x2C descriptor);\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrap'\x2C {\n  get() {\n    return wrap;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrapper'\x2C {\n  get() {\n    return wrapperProxy;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\n});\n\nconst isPreloadingDesc = { get() { return isPreloading; } };\nObjectDefineProperty(Module.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\nObjectDefineProperty(NativeModule.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\n\nfunction getModuleParent() {\n  return moduleParentCache.get(this);\n}\n\nfunction setModuleParent(value) {\n  moduleParentCache.set(this\x2C value);\n}\n\nObjectDefineProperty(Module.prototype\x2C 'parent'\x2C {\n  get: pendingDeprecation ? deprecate(\n    getModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : getModuleParent\x2C\n  set: pendingDeprecation ? deprecate(\n    setModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : setModuleParent\x2C\n});\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\nModule._debug = deprecate(debug\x2C 'Module._debug is deprecated.'\x2C 'DEP0077');\n\n// Given a module name\x2C and a list of paths to test\x2C returns the first\n// matching file in the following precedence.\n//\n// require("a.<ext>")\n//   -> a.<ext>\n//\n// require("a")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\n\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath\x2C 'package.json');\n\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath\x2C false);\n    return false;\n  }\n\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name\x2C\n      main: parsed.main\x2C\n      exports: parsed.exports\x2C\n      imports: parsed.imports\x2C\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath\x2C filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\n\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath\x2C sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath\x2C sep);\n    checkPath = StringPrototypeSlice(checkPath\x2C 0\x2C separatorIndex);\n    if (StringPrototypeEndsWith(checkPath\x2C sep + 'node_modules'))\n      return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson\x2C\n      path: checkPath\x2C\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\nfunction tryPackage(requestPath\x2C exts\x2C isMain\x2C originalPath) {\n  const pkg = readPackage(requestPath)?.main;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n  }\n\n  const filename = path.resolve(requestPath\x2C pkg);\n  let actual = tryFile(filename\x2C isMain) ||\n    tryExtensions(filename\x2C exts\x2C isMain) ||\n    tryExtensions(path.resolve(filename\x2C 'index')\x2C exts\x2C isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid "main" entry'\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath\x2C 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath\x2C 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author'\x2C\n        'DeprecationWarning'\x2C\n        'DEP0128'\n      );\n    }\n  }\n  return actual;\n}\n\n// In order to minimize unnecessary lstat() calls\x2C\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new SafeMap();\n\n// Check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false\x2C\n// keep symlinks intact\x2C otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath\x2C isMain) {\n  const rc = stat(requestPath);\n  if (rc !== 0) return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath\x2C {\n    [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\n// Given a path\x2C check if the file exists with any of the set extensions\nfunction tryExtensions(p\x2C exts\x2C isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i]\x2C isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n// Find the longest (possibly multi-dot) extension registered in\n// Module._extensions\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = StringPrototypeIndexOf(name\x2C '.'\x2C startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0) continue; // Skip dotfiles like .gitignore\n    currentExtension = StringPrototypeSlice(name\x2C index);\n    if (Module._extensions[currentExtension]) return currentExtension;\n  }\n  return '.js';\n}\n\nfunction trySelfParentPath(parent) {\n  if (!parent) return false;\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\nfunction trySelf(parentPath\x2C request) {\n  if (!parentPath) return false;\n\n  const { data: pkg\x2C path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === undefined) return false;\n  if (typeof pkg.name !== 'string') return false;\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request\x2C `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request\x2C pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json')\x2C expansion\x2C pkg\x2C\n      pathToFileURL(parentPath)\x2C cjsConditions)\x2C request\x2C parentPath\x2C pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\n      throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n    throw e;\n  }\n}\n\n// This only applies to requests of a specific form:\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath\x2C request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name\x2C 2: expansion = '' } =\n    StringPrototypeMatch(request\x2C EXPORTS_PATTERN) || [];\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath\x2C name);\n  const pkg = readPackage(pkgPath);\n  if (pkg?.exports != null) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json')\x2C '.' + expansion\x2C pkg\x2C null\x2C\n        cjsConditions)\x2C request\x2C null\x2C pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\n        throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n      throw e;\n    }\n  }\n}\n\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\nModule._findPath = function(request\x2C paths\x2C isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths\x2C '\\x00');\n  const entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n\n  let exts;\n  let trailingSlash = request.length > 0 &&\n    StringPrototypeCharCodeAt(request\x2C request.length - 1) ===\n    CHAR_FORWARD_SLASH;\n  if (!trailingSlash) {\n    trailingSlash = RegExpPrototypeTest(trailingSlashRegex\x2C request);\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath\x2C request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n\n    const basePath = path.resolve(curPath\x2C request);\n    let filename;\n\n    const rc = stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          // For the main module\x2C we use the preserveSymlinksMain flag instead\n          // mainly for backward compatibility\x2C as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working\x2C as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said\x2C in some use cases following symlinks\n          // causes bigger problems which is why the preserveSymlinksMain option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath\x2C exts\x2C isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at "index"\n      if (exts === undefined)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath\x2C exts\x2C isMain\x2C request);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n\n  return false;\n};\n\n// 'node_modules' character codes reversed\nconst nmChars = [ 115\x2C 101\x2C 108\x2C 117\x2C 100\x2C 111\x2C 109\x2C 95\x2C 101\x2C 100\x2C 111\x2C 110 ];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (StringPrototypeCharCodeAt(from\x2C from.length - 1) ===\n          CHAR_BACKWARD_SLASH &&\n        StringPrototypeCharCodeAt(from\x2C from.length - 2) === CHAR_COLON)\n      return [from + 'node_modules'];\n\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === CHAR_BACKWARD_SLASH ||\n          code === CHAR_FORWARD_SLASH ||\n          code === CHAR_COLON) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '\\\\node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work\x2C but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules'\x2C '/node_modules' ]\n    if (from === '/')\n      return ['/node_modules'];\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '/node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    ArrayPrototypePush(paths\x2C '/node_modules');\n\n    return paths;\n  };\n}\n\nModule._resolveLookupPaths = function(request\x2C parent) {\n  if (NativeModule.canBeRequiredByUsers(request)) {\n    debug('looking for %j in []'\x2C request);\n    return null;\n  }\n\n  // Check for node modules paths.\n  if (StringPrototypeCharAt(request\x2C 0) !== '.' ||\n      (request.length > 1 &&\n      StringPrototypeCharAt(request\x2C 1) !== '.' &&\n      StringPrototypeCharAt(request\x2C 1) !== '/' &&\n      (!isWindows || StringPrototypeCharAt(request\x2C 1) !== '\\\\'))) {\n\n    let paths = modulePaths;\n    if (parent?.paths?.length) {\n      paths = ArrayPrototypeConcat(parent.paths\x2C paths);\n    }\n\n    debug('looking for %j in %j'\x2C request\x2C paths);\n    return paths.length > 0 ? paths : null;\n  }\n\n  // In REPL\x2C parent.filename is null.\n  if (!parent || !parent.id || !parent.filename) {\n    // Make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but in REPL there is no filename\n    const mainPaths = ['.'];\n\n    debug('looking for %j in %j'\x2C request\x2C mainPaths);\n    return mainPaths;\n  }\n\n  debug('RELATIVE: requested: %s from parent.id %s'\x2C request\x2C parent.id);\n\n  const parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j'\x2C parentDir);\n  return parentDir;\n};\n\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\n    'inside circular dependency'\n  );\n}\n\n// A Proxy that can be used as the prototype of a module.exports object and\n// warns when non-existent properties are accessed.\nconst CircularRequirePrototypeWarningProxy = new Proxy({}\x2C {\n  get(target\x2C prop) {\n    // Allow __esModule access in any case because it is used in the output\n    // of transpiled code to determine whether something comes from an\n    // ES module\x2C and is not used as a regular key of `module.exports`.\n    if (prop in target || prop === '__esModule') return target[prop];\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n\n  getOwnPropertyDescriptor(target\x2C prop) {\n    if (ObjectPrototypeHasOwnProperty(target\x2C prop) || prop === '__esModule')\n      return ObjectGetOwnPropertyDescriptor(target\x2C prop);\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\n});\n\nfunction getExportsForCircularRequire(module) {\n  if (module.exports &&\n      !isProxy(module.exports) &&\n      ObjectGetPrototypeOf(module.exports) === ObjectPrototype &&\n      // Exclude transpiled ES6 modules / TypeScript code because those may\n      // employ unusual patterns for accessing 'module.exports'. That should\n      // be okay because ES6 modules have a different approach to circular\n      // dependencies anyway.\n      !module.exports.__esModule) {\n    // This is later unset once the module is done loading.\n    ObjectSetPrototypeOf(\n      module.exports\x2C CircularRequirePrototypeWarningProxy);\n  }\n\n  return module.exports;\n}\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call\n//    `NativeModule.prototype.compileForPublicLoader()` and return the exports.\n// 3. Otherwise\x2C create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request\x2C parent\x2C isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s'\x2C request\x2C parent.id);\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\n    // caching is required to allow cache invalidation without changing the old\n    // cache key names.\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\n    if (filename !== undefined) {\n      const cachedModule = Module._cache[filename];\n      if (cachedModule !== undefined) {\n        updateChildren(parent\x2C cachedModule\x2C true);\n        if (!cachedModule.loaded)\n          return getExportsForCircularRequire(cachedModule);\n        return cachedModule.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n\n  const filename = Module._resolveFilename(request\x2C parent\x2C isMain);\n  if (StringPrototypeStartsWith(filename\x2C 'node:')) {\n    // Slice 'node:' prefix\n    const id = StringPrototypeSlice(filename\x2C 5);\n\n    const module = loadNativeModule(id\x2C request);\n    if (!module?.canBeRequiredByUsers) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(filename);\n    }\n\n    return module.exports;\n  }\n\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    updateChildren(parent\x2C cachedModule\x2C true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded)\n        return getExportsForCircularRequire(cachedModule);\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  const mod = loadNativeModule(filename\x2C request);\n  if (mod?.canBeRequiredByUsers) return mod.exports;\n\n  // Don't call updateChildren()\x2C Module constructor already does.\n  const module = cachedModule || new Module(filename\x2C parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== undefined) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent?.children;\n        if (ArrayIsArray(children)) {\n          const index = ArrayPrototypeIndexOf(children\x2C module);\n          if (index !== -1) {\n            ArrayPrototypeSplice(children\x2C index\x2C 1);\n          }\n        }\n      }\n    } else if (module.exports &&\n               !isProxy(module.exports) &&\n               ObjectGetPrototypeOf(module.exports) ===\n                 CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module.exports\x2C ObjectPrototype);\n    }\n  }\n\n  return module.exports;\n};\n\nModule._resolveFilename = function(request\x2C parent\x2C isMain\x2C options) {\n  if (StringPrototypeStartsWith(request\x2C 'node:') ||\n      NativeModule.canBeRequiredByUsers(request)) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request\x2C './') ||\n          StringPrototypeStartsWith(request\x2C '../') ||\n          ((isWindows && StringPrototypeStartsWith(request\x2C '.\\\\')) ||\n          StringPrototypeStartsWith(request\x2C '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module(''\x2C null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request\x2C fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths\x2C lookupPaths[j]))\n              ArrayPrototypePush(paths\x2C lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request\x2C parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths'\x2C options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request\x2C parent);\n  }\n\n  if (parent?.filename) {\n    if (request[0] === '#') {\n      const pkg = readPackageScope(parent.filename) || {};\n      if (pkg.data?.imports != null) {\n        try {\n          return finalizeEsmResolution(\n            packageImportsResolve(request\x2C pathToFileURL(parent.filename)\x2C\n                                  cjsConditions)\x2C request\x2C parent.filename\x2C\n            pkg.path);\n        } catch (e) {\n          if (e.code === 'ERR_MODULE_NOT_FOUND')\n            throw createEsmNotFoundErr(request);\n          throw e;\n        }\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath\x2C request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths\x2C '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first\x2C since that's the cache key.\n  const filename = Module._findPath(request\x2C paths\x2C isMain\x2C false);\n  if (filename) return filename;\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack\x2C cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack\x2C '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\nfunction finalizeEsmResolution(match\x2C request\x2C parentPath\x2C pkgPath) {\n  const { resolved\x2C exact } = match;\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved\x2C 'must not include encoded "/" or "\\\\" characters'\x2C parentPath);\n  const filename = fileURLToPath(resolved);\n  let actual = tryFile(filename);\n  if (!exact && !actual) {\n    const exts = ObjectKeys(Module._extensions);\n    actual = tryExtensions(filename\x2C exts\x2C false) ||\n      tryPackage(filename\x2C exts\x2C false\x2C request);\n  }\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename\x2C\n                                   path.resolve(pkgPath\x2C 'package.json'));\n  throw err;\n}\n\nfunction createEsmNotFoundErr(request\x2C path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path)\n    err.path = path;\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n// Given a file name\x2C pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j'\x2C filename\x2C this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  if (StringPrototypeEndsWith(filename\x2C '.mjs') && !Module._extensions['.mjs'])\n    throw new ERR_REQUIRE_ESM(filename\x2C true);\n\n  Module._extensions[extension](this\x2C filename);\n  this.loaded = true;\n\n  const esmLoader = asyncESM.esmLoader;\n  // Create module entry at load time to snapshot exports correctly\n  const exports = this.exports;\n  // Preemptively cache\n  if ((module?.module === undefined ||\n       module.module.getStatus() < kEvaluated) &&\n      !esmLoader.cjsCache.has(this))\n    esmLoader.cjsCache.set(this\x2C exports);\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C this\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n};\n\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --inspect-brk)\nlet resolvedArgv;\nlet hasPausedEntry = false;\n\nfunction wrapSafe(filename\x2C content\x2C cjsModuleInstance) {\n  if (patched) {\n    const wrapper = Module.wrap(content);\n    return vm.runInThisContext(wrapper\x2C {\n      filename\x2C\n      lineOffset: 0\x2C\n      displayErrors: true\x2C\n      importModuleDynamically: async (specifier) => {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename));\n      }\x2C\n    });\n  }\n  try {\n    return vm.compileFunction(content\x2C [\n      'exports'\x2C\n      'require'\x2C\n      'module'\x2C\n      '__filename'\x2C\n      '__dirname'\x2C\n    ]\x2C {\n      filename\x2C\n      importModuleDynamically(specifier) {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename));\n      }\x2C\n    });\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance)\n      enrichCJSError(err\x2C content);\n    throw err;\n  }\n}\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require\x2C module\x2C exports) to\n// the file.\n// Returns exception\x2C if any.\nModule.prototype._compile = function(content\x2C filename) {\n  let moduleURL;\n  let redirects;\n  if (policy?.manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = policy.manifest.getDependencyMapper(moduleURL);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  maybeCacheSourceMap(filename\x2C content\x2C this);\n  const compiledWrapper = wrapSafe(filename\x2C content\x2C this);\n\n  let inspectorWrapper = null;\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\n    if (!resolvedArgv) {\n      // We enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1]\x2C null\x2C false);\n        } catch {\n          // We only expect this codepath to be reached in the case of a\n          // preloaded module (it will fail earlier with the main entry)\n          assert(ArrayIsArray(getOptionValue('--require')));\n        }\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this\x2C redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) statCache = new SafeMap();\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper\x2C thisValue\x2C exports\x2C\n                              require\x2C module\x2C filename\x2C dirname);\n  } else {\n    result = ReflectApply(compiledWrapper\x2C thisValue\x2C\n                          [exports\x2C require\x2C module\x2C filename\x2C dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) statCache = null;\n  return result;\n};\n\n// Native extension for .js\nModule._extensions['.js'] = function(module\x2C filename) {\n  // If already analyzed the source\x2C then it will be cached.\n  const cached = cjsParseCache.get(module);\n  let content;\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    content = fs.readFileSync(filename\x2C 'utf8');\n  }\n  if (StringPrototypeEndsWith(filename\x2C '.js')) {\n    const pkg = readPackageScope(filename);\n    // Function require shouldn't be used in ES modules.\n    if (pkg?.data?.type === 'module') {\n      const parent = moduleParentCache.get(module);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path\x2C 'package.json');\n      const usesEsm = hasEsmSyntax(content);\n      const err = new ERR_REQUIRE_ESM(filename\x2C usesEsm\x2C parentPath\x2C\n                                      packageJsonPath);\n      // Attempt to reconstruct the parent require frame.\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath\x2C 'utf8');\n        } catch {}\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(\n            StringPrototypeSlice(err.stack\x2C StringPrototypeIndexOf(\n              err.stack\x2C '    at '))\x2C '\\n'\x2C 1)[0];\n          const { 1: line\x2C 2: col } =\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/\x2C errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource\x2C '\\n')[line - 1];\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\n              StringPrototypeRepeat(' '\x2C col - 1)}^\\n`;\n            setArrowMessage(err\x2C frame);\n          }\n        }\n      }\n      throw err;\n    }\n  }\n  module._compile(content\x2C filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module\x2C filename) {\n  const content = fs.readFileSync(filename\x2C 'utf8');\n\n  if (policy?.manifest) {\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  try {\n    module.exports = JSONParse(stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n// Native extension for .node\nModule._extensions['.node'] = function(module\x2C filename) {\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n  // Be aware this doesn't use `content`\n  return process.dlopen(module\x2C path.toNamespacedPath(filename));\n};\n\nfunction createRequireFromPath(filename) {\n  // Allow a directory to be passed as the filename\n  const trailingSlash =\n    StringPrototypeEndsWith(filename\x2C '/') ||\n    (isWindows && StringPrototypeEndsWith(filename\x2C '\\\\'));\n\n  const proxyPath = trailingSlash ?\n    path.join(filename\x2C 'noop.js') :\n    filename;\n\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m\x2C null);\n}\n\nconst createRequireError = 'must be a file URL object\x2C file URL string\x2C or ' +\n  'absolute path string';\n\nfunction createRequire(filename) {\n  let filepath;\n\n  if (isURLInstance(filename) ||\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C\n                                      createRequireError);\n    }\n  } else if (typeof filename !== 'string') {\n    throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\n\nModule.createRequire = createRequire;\n\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\n\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\n  const prefixDir = isWindows ?\n    path.resolve(process.execPath\x2C '..') :\n    path.resolve(process.execPath\x2C '..'\x2C '..');\n\n  const paths = [path.resolve(prefixDir\x2C 'lib'\x2C 'node')];\n\n  if (homeDir) {\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_libraries'));\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_modules'));\n  }\n\n  if (nodePath) {\n    ArrayPrototypeUnshiftApply(paths\x2C ArrayPrototypeFilter(\n      StringPrototypeSplit(nodePath\x2C path.delimiter)\x2C\n      Boolean\n    ));\n  }\n\n  modulePaths = paths;\n\n  // Clone as a shallow copy\x2C for introspection.\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\n};\n\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests))\n    return;\n\n  isPreloading = true;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  const parent = new Module('internal/preload'\x2C null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      isPreloading = false;\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++)\n    parent.require(requests[n]);\n  isPreloading = false;\n};\n\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of NativeModule.map.values()) {\n    if (mod.canBeRequiredByUsers) {\n      mod.syncExports();\n    }\n  }\n};\n\n// Backwards compatibility\nModule.Module = Module;\n
code-source-info,0x1eea2da9f136,99,0,40182,C0O0C4O40182,,
code-creation,Function,10,95878,0x1eea2daa0ed6,2547, node:internal/modules/cjs/loader:1:1,0x1eea2da9f0b0,~
code-source-info,0x1eea2daa0ed6,99,0,40182,C0O0C446O1159C452O1175C458O1199C464O1223C470O1249C476O1274C482O1296C488O1318C494O1341C500O1365C506O1390C512O1420C518O1431C524O1440C530O1453C535O1469C541O1493C546O1509C552O1543C558O1567C564O1581C570O1600C576O1633C582O1657C587O1666C593O1682C599O1696C605O1719C611O1742C617O1753C622O1768C628O1778C634O1803C640O1832C646O1859C652O1889C658O1915C664O1939C670O1964C676O1988C682O2012C688O2118C690O2118C695O2118C697O2191C709O2212C715O2222C721O2230C727O2242C733O2260C763O2206C767O2376C771O2376C777O2359C783O2450C787O2450C793O2425C799O2555C803O2555C809O2507C815O2522C821O2537C827O2602C831O2602C837O2588C842O2639C846O2639C850O2639C852O2669C856O2669C860O2669C862O2708C866O2708C870O2708C872O2742C876O2742C880O2742C882O2785C886O2785C890O2785C892O2818C896O2810C902O2855C910O2855C916O2832C922O2904C926O2904C930O2904C932O2976C940O2976C946O2961C952O3132C956O3132C962O3018C968O3035C974O3051C980O3071C986O3094C992O3118C998O3200C1002O3200C1008O3181C1014O3254C1022O3254C1026O3254C1028O3322C1036O3322C1040O3322C1042O3432C1050O3432C1060O3476C1067O3432C1069O3656C1070O3656C1072O3825C1076O3825C1082O3825C1088O3687C1094O3714C1100O3748C1106O3769C1112O3804C1118O3880C1122O3880C1128O3861C1134O3939C1142O3939C1147O4051C1151O4051C1157O3991C1163O4013C1169O4036C1175O4105C1179O4105C1185O4093C1191O4155C1195O4155C1199O4155C1201O4222C1205O4222C1211O4203C1217O4290C1225O4290C1231O4275C1237O4402C1241O4402C1247O4332C1253O4351C1259O4376C1265O4462C1269O4470C1277O4479C1280O4462C1282O4522C1285O4522C1289O4522C1291O4562C1292O4562C1294O4581C1295O4581C1297O4606C1298O4606C1300O5250C1302O5250C1307O5250C1309O5546C1312O5595C1316O5595C1350O5577C1381O5566C1388O5573C1397O5612C1403O5640C1407O5640C1412O5550C1483O5687C1487O5717C1493O5739C1497O5758C1504O5774C1508O5772C1512O5794C1519O5814C1527O5812C1535O5834C1542O5855C1550O5853C1558O5893C1562O5893C1564O5897C1572O5916C1580O5937C1581O5937C1583O5995C1587O5995C1589O6091C1597O6205C1606O6218C1618O6345C1635O6195C1645O6195C1647O6484C1659O6505C1668O6525C1680O6558C1692O6484C1702O6618C1714O6639C1723O6662C1735O6703C1747O6618C1757O6796C1766O6798C1781O6832C1789O6860C1806O6832C1816O6906C1824O6940C1841O6906C1851O7132C1859O7160C1884O7190C1892O7313C1907O7211C1921O7394C1931O7418C1939O7541C1954O7439C1968O7622C1976O7132C1986O7656C1990O7656C2000O7689C2020O7690C2032O7656C2034O7737C2050O7753C2060O7751C2068O8066C2072O8066C2082O8066C2084O10869C2088O10869C2098O10869C2100O13498C2107O13498C2109O14282C2116O14282C2118O14300C2126O14317C2134O16993C2141O16993C2143O17070C2147O17078C2155O17070C2157O17086C2161O17149C2169O17173C2179O18757C2187O18781C2195O19927C2203O19954C2211O21502C2223O21520C2235O21897C2249O21502C2259O21502C2261O23185C2269O23198C2277O26129C2285O26153C2293O30233C2297O30240C2311O30255C2319O31169C2323O31176C2337O31194C2345O31632C2346O31632C2348O31667C2349O31667C2351O32724C2355O32731C2369O32750C2377O34632C2381O34639C2395O34658C2403O36402C2407O36409C2421O36430C2429O36830C2433O36837C2447O36858C2455O37671C2461O37721C2467O37671C2469O38305C2475O38326C2483O38344C2491O38362C2499O39331C2507O39354C2515O39941C2523O39970C2531O40158C2537O40172C2546O40181,,
tick,0x7fff203e4e5d,96073,1,0x10ea6ba00,3,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
tick,0x7fff202f7251,96099,1,0x10ea6ba00,3,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
tick,0x7fff204326e6,96117,1,0x10ea6ba00,3,0x10ebf8f80,0x1eea4787f1c4,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Eval,10,96356,0x1eea2daa4e66,5, node:internal/modules/package_json_reader:1:1,0x1eea2daa4cc0,~
script-source,100,node:internal/modules/package_json_reader,'use strict';\n\nconst { SafeMap } = primordials;\nconst { internalModuleReadJSON } = internalBinding('fs');\nconst { pathToFileURL } = require('url');\nconst { toNamespacedPath } = require('path');\n\nconst cache = new SafeMap();\n\nlet manifest;\n\n/**\n *\n * @param {string} jsonPath\n */\nfunction read(jsonPath) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const { 0: string\x2C 1: containsKeys } = internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\n  );\n  const result = { string\x2C containsKeys };\n  const { getOptionValue } = require('internal/options');\n  if (string !== undefined) {\n    if (manifest === undefined) {\n      manifest = getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').manifest :\n        null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL\x2C string);\n    }\n  }\n  cache.set(jsonPath\x2C result);\n  return result;\n}\n\nmodule.exports = { read };\n
code-source-info,0x1eea2daa4e66,100,0,983,C0O0C4O983,,
code-creation,Function,10,96464,0x1eea2daa4fb6,113, node:internal/modules/package_json_reader:1:1,0x1eea2daa4de0,~
code-source-info,0x1eea2daa4fb6,100,0,983,C0O0C29O23C34O83C37O83C42O56C48O132C54O132C59O114C65O177C71O177C76O156C82O209C84O209C89O209C91O229C92O229C94O956C101O975C107O971C112O982,,
tick,0x10ebec110,97279,0,0x0,0,0x10f0b4b60,0x1eea2da8e83e,0x1eea2da8e4a1,0x1eea2daa12d4,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
new,MemoryChunk,0x11b700000,262144
code-creation,Function,11,97935,0x11b703060,432,getOptionsFromBinding node:internal/options:18:31,0x1eea2da838c8,^
code-source-info,0x11b703060,93,467,565,,,
code-creation,Function,11,97979,0x11b703280,116,isPosixPathSeparator node:path:56:30,0x1eeac2067ec8,^
code-source-info,0x11b703280,35,1854,1902,,,
code-creation,Function,11,98029,0x11b703360,572,getOptionValue node:internal/options:32:24,0x1eea2da83968,^
code-source-info,0x11b703360,93,720,960,,,
code-creation,Function,11,98079,0x11b703600,664,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x1eeab58cf8f8,^
code-source-info,0x11b703600,9,10315,10658,,,
code-creation,Function,11,98112,0x11b703900,1252,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x1eeab58cf828,^
code-source-info,0x11b703900,9,9528,10089,,,
code-creation,Eval,10,98352,0x1eea2daa5a46,5, node:internal/process/esm_loader:1:1,0x1eea2daa5850,~
script-source,101,node:internal/process/esm_loader,'use strict';\n\nconst {\n  ObjectCreate\x2C\n} = primordials;\n\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\x2C\n} = require('internal/errors').codes;\nconst { ESMLoader } = require('internal/modules/esm/loader');\nconst {\n  hasUncaughtExceptionCaptureCallback\x2C\n} = require('internal/process/execution');\nconst { pathToFileURL } = require('internal/url');\nconst {\n  getModuleFromWrap\x2C\n} = require('internal/vm/module');\n\nexports.initializeImportMetaObject = function(wrap\x2C meta) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { initializeImportMeta } = callbackMap.get(wrap);\n    if (initializeImportMeta !== undefined) {\n      initializeImportMeta(meta\x2C getModuleFromWrap(wrap) || wrap);\n    }\n  }\n};\n\nexports.importModuleDynamicallyCallback =\nasync function importModuleDynamicallyCallback(wrap\x2C specifier\x2C assertions) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { importModuleDynamically } = callbackMap.get(wrap);\n    if (importModuleDynamically !== undefined) {\n      return importModuleDynamically(\n        specifier\x2C getModuleFromWrap(wrap) || wrap\x2C assertions);\n    }\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n};\n\nconst esmLoader = new ESMLoader();\n\nexports.esmLoader = esmLoader;\n\n/**\n * Causes side-effects: user-defined loader hooks are added to esmLoader.\n * @returns {void}\n */\nasync function initializeLoader() {\n  const { getOptionValue } = require('internal/options');\n  // customLoaders CURRENTLY can be only 1 (a string)\n  // Once chaining is implemented\x2C it will be string[]\n  const customLoaders = getOptionValue('--experimental-loader');\n\n  if (!customLoaders.length) return;\n\n  const { emitExperimentalWarning } = require('internal/util');\n  emitExperimentalWarning('--experimental-loader');\n\n  let cwd;\n  try {\n    cwd = process.cwd() + '/';\n  } catch {\n    cwd = 'file:///';\n  }\n\n  // A separate loader instance is necessary to avoid cross-contamination\n  // between internal Node.js and userland. For example\x2C a module with internal\n  // state (such as a counter) should be independent.\n  const internalEsmLoader = new ESMLoader();\n\n  // Importation must be handled by internal loader to avoid poluting userland\n  const exports = await internalEsmLoader.import(\n    customLoaders\x2C\n    pathToFileURL(cwd).href\x2C\n    ObjectCreate(null)\x2C\n  );\n\n  // Hooks must then be added to external/public loader\n  // (so they're triggered in userland)\n  await esmLoader.addCustomLoaders(exports);\n}\n\nexports.loadESM = async function loadESM(callback) {\n  try {\n    await initializeLoader();\n    await callback(esmLoader);\n  } catch (err) {\n    if (hasUncaughtExceptionCaptureCallback()) {\n      process._fatalException(err);\n      return;\n    }\n    internalBinding('errors').triggerUncaughtException(\n      err\x2C\n      true /* fromPromise */\n    );\n  }\n};\n
code-source-info,0x1eea2daa5a46,101,0,2883,C0O0C4O2883,,
code-creation,Function,10,98607,0x1eea2daa5ce6,182, node:internal/process/esm_loader:1:1,0x1eea2daa59c0,~
code-source-info,0x1eea2daa5ce6,101,0,2883,C0O0C44O25C50O111C56O111C61O137C66O67C72O167C78O167C83O153C89O258C95O258C100O217C106O323C112O323C117O305C123O381C129O381C134O358C140O413C144O448C148O749C152O789C156O1259C159O1259C164O1259C166O1277C168O1295C172O2528C176O2544C181O2882,,
tick,0x7fff203e537c,98688,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Eval,10,98974,0x1eea2daa6d4e,5, node:internal/modules/esm/loader:1:1,0x1eea2daa6950,~
script-source,102,node:internal/modules/esm/loader,'use strict';\n\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\nrequire('internal/modules/cjs/loader');\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectCreate\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  SafeWeakMap\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\n  ERR_INVALID_RETURN_VALUE\x2C\n  ERR_UNKNOWN_MODULE_FORMAT\n} = require('internal/errors').codes;\nconst { pathToFileURL\x2C isURLInstance } = require('internal/url');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst ModuleMap = require('internal/modules/esm/module_map');\nconst ModuleJob = require('internal/modules/esm/module_job');\n\nconst {\n  defaultResolve\x2C\n  DEFAULT_CONDITIONS\x2C\n} = require('internal/modules/esm/resolve');\nconst { defaultLoad } = require('internal/modules/esm/load');\nconst { translators } = require(\n  'internal/modules/esm/translators');\nconst { getOptionValue } = require('internal/options');\n\n/**\n * An ESMLoader instance is used as the main entry point for loading ES modules.\n * Currently\x2C this is a singleton -- there is only one used for loading\n * the main module and everything in its dependency graph.\n */\nclass ESMLoader {\n  /**\n   * Prior to ESM loading. These are called once before any modules are started.\n   * @private\n   * @property {function[]} globalPreloaders First-in-first-out list of\n   * preload hooks.\n   */\n  #globalPreloaders = [];\n\n  /**\n   * Phase 2 of 2 in ESM loading.\n   * @private\n   * @property {function[]} loaders First-in-first-out list of loader hooks.\n   */\n  #loaders = [\n    defaultLoad\x2C\n  ];\n\n  /**\n   * Phase 1 of 2 in ESM loading.\n   * @private\n   * @property {function[]} resolvers First-in-first-out list of resolver hooks\n   */\n  #resolvers = [\n    defaultResolve\x2C\n  ];\n\n  /**\n   * Map of already-loaded CJS modules to use\n   */\n  cjsCache = new SafeWeakMap();\n\n  /**\n   * The index for assigning unique URLs to anonymous module evaluation\n   */\n  evalIndex = 0;\n\n  /**\n   * Registry of loaded modules\x2C akin to `require.cache`\n   */\n  moduleMap = new ModuleMap();\n\n  /**\n   * Methods which translate input code or other information into ES modules\n   */\n  translators = translators;\n\n  static pluckHooks({\n    globalPreload\x2C\n    resolve\x2C\n    load\x2C\n    // obsolete hooks:\n    dynamicInstantiate\x2C\n    getFormat\x2C\n    getGlobalPreloadCode\x2C\n    getSource\x2C\n    transformSource\x2C\n  }) {\n    const obsoleteHooks = [];\n    const acceptedHooks = ObjectCreate(null);\n\n    if (getGlobalPreloadCode) {\n      globalPreload ??= getGlobalPreloadCode;\n\n      process.emitWarning(\n        'Loader hook "getGlobalPreloadCode" has been renamed to "globalPreload"'\n      );\n    }\n    if (dynamicInstantiate) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'dynamicInstantiate'\n    );\n    if (getFormat) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getFormat'\x2C\n    );\n    if (getSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getSource'\x2C\n    );\n    if (transformSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'transformSource'\x2C\n    );\n\n    if (obsoleteHooks.length) process.emitWarning(\n      `Obsolete loader hook(s) supplied and will be ignored: ${\n        ArrayPrototypeJoin(obsoleteHooks\x2C '\x2C ')\n      }`\x2C\n      'DeprecationWarning'\x2C\n    );\n\n    // Use .bind() to avoid giving access to the Loader instance when called.\n    if (globalPreload) {\n      acceptedHooks.globalPreloader =\n        FunctionPrototypeBind(globalPreload\x2C null);\n    }\n    if (resolve) {\n      acceptedHooks.resolver = FunctionPrototypeBind(resolve\x2C null);\n    }\n    if (load) {\n      acceptedHooks.loader = FunctionPrototypeBind(load\x2C null);\n    }\n\n    return acceptedHooks;\n  }\n\n  /**\n   * Collect custom/user-defined hook(s). After all hooks have been collected\x2C\n   * calls global preload hook(s).\n   * @param {object | object[]} customLoaders A list of exports from\n   * user-defined loaders (as returned by ESMLoader.import()).\n   */\n  async addCustomLoaders(\n    customLoaders = []\x2C\n  ) {\n    if (!ArrayIsArray(customLoaders)) customLoaders = [customLoaders];\n\n    for (let i = 0; i < customLoaders.length; i++) {\n      const exports = customLoaders[i];\n      const {\n        globalPreloader\x2C\n        resolver\x2C\n        loader\x2C\n      } = ESMLoader.pluckHooks(exports);\n\n      if (globalPreloader) ArrayPrototypePush(\n        this.#globalPreloaders\x2C\n        FunctionPrototypeBind(globalPreloader\x2C null)\x2C // [1]\n      );\n      if (resolver) ArrayPrototypePush(\n        this.#resolvers\x2C\n        FunctionPrototypeBind(resolver\x2C null)\x2C // [1]\n      );\n      if (loader) ArrayPrototypePush(\n        this.#loaders\x2C\n        FunctionPrototypeBind(loader\x2C null)\x2C // [1]\n      );\n    }\n\n    // [1] ensure hook function is not bound to ESMLoader instance\n\n    this.preload();\n  }\n\n  async eval(\n    source\x2C\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\n  ) {\n    const evalInstance = (url) => {\n      const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n      const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n      callbackMap.set(module\x2C {\n        importModuleDynamically: (specifier\x2C { url }) => {\n          return this.import(specifier\x2C url);\n        }\n      });\n\n      return module;\n    };\n    const job = new ModuleJob(this\x2C url\x2C evalInstance\x2C false\x2C false);\n    this.moduleMap.set(url\x2C job);\n    const { module } = await job.run();\n\n    return {\n      namespace: module.getNamespace()\x2C\n    };\n  }\n\n  async getModuleJob(specifier\x2C parentURL) {\n    const { format\x2C url } = await this.resolve(specifier\x2C parentURL);\n    let job = this.moduleMap.get(url);\n    // CommonJS will set functions for lazy job evaluation.\n    if (typeof job === 'function') this.moduleMap.set(url\x2C job = job());\n\n    if (job !== undefined) return job;\n\n    const moduleProvider = async (url\x2C isMain) => {\n      const { format: finalFormat\x2C source } = await this.load(url\x2C { format });\n\n      const translator = translators.get(finalFormat);\n\n      if (!translator) throw new ERR_UNKNOWN_MODULE_FORMAT(finalFormat);\n\n      return FunctionPrototypeCall(translator\x2C this\x2C url\x2C source\x2C isMain);\n    };\n\n    const inspectBrk = (\n      parentURL === undefined &&\n      getOptionValue('--inspect-brk')\n    );\n\n    job = new ModuleJob(\n      this\x2C\n      url\x2C\n      moduleProvider\x2C\n      parentURL === undefined\x2C\n      inspectBrk\n    );\n\n    this.moduleMap.set(url\x2C job);\n\n    return job;\n  }\n\n  /**\n   * This method is usually called indirectly as part of the loading processes.\n   * Internally\x2C it is used directly to add loaders. Use directly with caution.\n   *\n   * This method must NOT be renamed: it functions as a dynamic import on a\n   * loader module.\n   *\n   * @param {string | string[]} specifiers Path(s) to the module\n   * @param {string} [parentURL] Path of the parent importing the module\n   * @returns {object | object[]} A list of module export(s)\n   */\n  async import(specifiers\x2C parentURL) {\n    const wasArr = ArrayIsArray(specifiers);\n    if (!wasArr) specifiers = [specifiers];\n\n    const count = specifiers.length;\n    const jobs = new Array(count);\n\n    for (let i = 0; i < count; i++) {\n      jobs[i] = this.getModuleJob(specifiers[i]\x2C parentURL)\n        .then((job) => job.run())\n        .then(({ module }) => module.getNamespace());\n    }\n\n    const namespaces = await PromiseAll(new SafeArrayIterator(jobs));\n\n    return wasArr ?\n      namespaces :\n      namespaces[0];\n  }\n\n  /**\n   * Provide source that is understood by one of Node's translators.\n   *\n   * The internals of this WILL change when chaining is implemented\x2C\n   * depending on the resolution/consensus from #36954\n   * @param {string} url The URL/path of the module to be loaded\n   * @param {Object} context Metadata about the module\n   * @returns {Object}\n   */\n  async load(url\x2C context = {}) {\n    const defaultLoader = this.#loaders[0];\n\n    const loader = this.#loaders.length === 1 ?\n      defaultLoader :\n      this.#loaders[1];\n    const loaded = await loader(url\x2C context\x2C defaultLoader);\n\n    if (typeof loaded !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C\n        'loader load'\x2C\n        loaded\x2C\n      );\n    }\n\n    const {\n      format\x2C\n      source\x2C\n    } = loaded;\n\n    if (format == null) {\n      const dataUrl = RegExpPrototypeExec(\n        /^data:([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n        url\x2C\n      );\n\n      throw new ERR_INVALID_MODULE_SPECIFIER(\n        url\x2C\n        dataUrl ? `has an unsupported MIME type "${dataUrl[1]}"` : ''\n      );\n    }\n\n    if (typeof format !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n\n    if (\n      source != null &&\n      typeof source !== 'string' &&\n      !isAnyArrayBuffer(source) &&\n      !isArrayBufferView(source)\n    ) throw ERR_INVALID_RETURN_PROPERTY_VALUE(\n      'string\x2C an ArrayBuffer\x2C or a TypedArray'\x2C\n      'loader load'\x2C\n      'source'\x2C\n      source\n    );\n\n    return {\n      format\x2C\n      source\x2C\n    };\n  }\n\n  preload() {\n    const count = this.#globalPreloaders.length;\n    if (!count) return;\n\n    for (let i = 0; i < count; i++) {\n      const preload = this.#globalPreloaders[i]();\n\n      if (preload == null) return;\n\n      if (typeof preload !== 'string') {\n        throw new ERR_INVALID_RETURN_VALUE(\n          'string'\x2C\n          'loader globalPreloadCode'\x2C\n          preload\x2C\n        );\n      }\n      const { compileFunction } = require('vm');\n      const preloadInit = compileFunction(\n        preload\x2C\n        ['getBuiltin']\x2C\n        {\n          filename: '<preload>'\x2C\n        }\n      );\n      const { NativeModule } = require('internal/bootstrap/loaders');\n\n      FunctionPrototypeCall(preloadInit\x2C globalThis\x2C (builtinName) => {\n        if (NativeModule.canBeRequiredByUsers(builtinName)) {\n          return require(builtinName);\n        }\n        throw new ERR_INVALID_ARG_VALUE('builtinName'\x2C builtinName);\n      });\n    }\n  }\n\n  /**\n   * Resolve the location of the module.\n   *\n   * The internals of this WILL change when chaining is implemented\x2C\n   * depending on the resolution/consensus from #36954\n   * @param {string} originalSpecifier The specified URL path of the module to\n   * be resolved\n   * @param {String} parentURL The URL path of the module's parent\n   * @returns {{ url: String }}\n   */\n  async resolve(originalSpecifier\x2C parentURL) {\n    const isMain = parentURL === undefined;\n\n    if (\n      !isMain &&\n      typeof parentURL !== 'string' &&\n      !isURLInstance(parentURL)\n    ) throw new ERR_INVALID_ARG_TYPE(\n      'parentURL'\x2C\n      ['string'\x2C 'URL']\x2C\n      parentURL\x2C\n    );\n\n    const conditions = DEFAULT_CONDITIONS;\n\n    const defaultResolver = this.#resolvers[0];\n\n    const resolver = this.#resolvers.length === 1 ?\n      defaultResolver :\n      this.#resolvers[1];\n    const resolution = await resolver(\n      originalSpecifier\x2C\n      {\n        conditions\x2C\n        parentURL\x2C\n      }\x2C\n      defaultResolver\x2C\n    );\n\n    if (typeof resolution !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C\n        'loader resolve'\x2C\n        resolution\x2C\n      );\n    }\n\n    const { format\x2C url } = resolution;\n\n    if (\n      format != null &&\n      typeof format !== 'string'\n    ) {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n    if (typeof url !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'url'\x2C\n        url\x2C\n      );\n    }\n\n    return {\n      format\x2C\n      url\x2C\n    };\n  }\n}\n\nObjectSetPrototypeOf(ESMLoader.prototype\x2C null);\n\nexports.ESMLoader = ESMLoader;\n
code-source-info,0x1eea2daa6d4e,102,0,11918,C0O0C4O11918,,
code-creation,Function,10,99838,0x1eea2daa7496,530, node:internal/modules/esm/loader:1:1,0x1eea2daa6cc8,~
code-source-info,0x1eea2daa7496,102,0,11918,C0O0C104O79C110O79C114O130C120O139C126O155C132O177C138O199C144O224C150O249C156O265C161O289C167O303C173O326C179O347C185O362C191O578C197O578C202O604C207O402C213O426C219O451C225O483C231O520C237O548C243O653C249O653C254O620C260O635C266O731C272O731C277O688C283O708C289O781C295O781C299O781C301O843C307O843C311O843C313O940C319O940C324O898C330O916C336O1005C342O1005C347O989C353O1067C359O1067C364O1051C370O1142C376O1142C381O1123C510O11868C517O11837C522O11887C524O11905C529O11917,,
code-creation,Function,10,99885,0x1eea2daa788e,139,<instance_members_initializer> node:internal/modules/esm/loader:59:3,0x1eea2daa7050,~
code-source-info,0x1eea2daa788e,102,1611,2404,C3O1631C17O1786C28O1792C45O1966C56O1972C73O2065C80O2065C94O2183C104O2270C111O2270C125O2393C138O2404,,
tick,0x7fff202fa27a,99918,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Eval,10,100085,0x1eea2daa8c56,5, node:internal/modules/esm/module_map:1:1,0x1eea2daa8a88,~
script-source,103,node:internal/modules/esm/module_map,'use strict';\n\nconst ModuleJob = require('internal/modules/esm/module_job');\nconst {\n  SafeMap\x2C\n} = primordials;\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n// Tracks the state of the loader-level module cache\nclass ModuleMap extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  get(url) {\n    validateString(url\x2C 'url');\n    return super.get(url);\n  }\n  set(url\x2C job) {\n    validateString(url\x2C 'url');\n    if (job instanceof ModuleJob !== true &&\n        typeof job !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('job'\x2C 'ModuleJob'\x2C job);\n    }\n    debug(`Storing ${url} in ModuleMap`);\n    return super.set(url\x2C job);\n  }\n  has(url) {\n    validateString(url\x2C 'url');\n    return super.has(url);\n  }\n}\nmodule.exports = ModuleMap;\n
code-source-info,0x1eea2daa8c56,103,0,955,C0O0C4O955,,
code-creation,Function,10,100190,0x1eea2daa9076,149, node:internal/modules/esm/module_map:1:1,0x1eea2daa8bd0,~
code-source-info,0x1eea2daa9076,103,0,955,C0O0C17O33C20O33C24O33C26O87C31O125C34O125C39O158C52O159C58O125C60O236C63O236C68O262C73O211C79O297C82O297C87O278C97O407C141O927C143O942C148O954,,
code-creation,Eval,10,100437,0x1eea2daa9a9e,5, node:internal/modules/esm/module_job:1:1,0x1eea2daa97b8,~
script-source,104,node:internal/modules/esm/module_job,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSome\x2C\n  FunctionPrototype\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  PromiseResolve\x2C\n  PromisePrototypeCatch\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst { ModuleWrap } = internalBinding('module_wrap');\n\nconst { decorateErrorStack } = require('internal/util');\nconst {\n  getSourceMapsEnabled\x2C\n} = require('internal/source_map/source_map_cache');\nconst assert = require('internal/assert');\nconst resolvedPromise = PromiseResolve();\n\nconst noop = FunctionPrototype;\n\nlet hasPausedEntry = false;\n\nconst CJSGlobalLike = [\n  'require'\x2C\n  'module'\x2C\n  'exports'\x2C\n  '__filename'\x2C\n  '__dirname'\x2C\n];\nconst isCommonJSGlobalLikeNotDefinedError = (errorMessage) =>\n  ArrayPrototypeSome(\n    CJSGlobalLike\x2C\n    (globalLike) => errorMessage === `${globalLike} is not defined`\n  );\n\n/* A ModuleJob tracks the loading of a single Module\x2C and the ModuleJobs of\n * its dependencies\x2C over time. */\nclass ModuleJob {\n  // `loader` is the Loader instance used for loading dependencies.\n  // `moduleProvider` is a function\n  constructor(loader\x2C url\x2C moduleProvider\x2C isMain\x2C inspectBrk) {\n    this.loader = loader;\n    this.isMain = isMain;\n    this.inspectBrk = inspectBrk;\n\n    this.module = undefined;\n    // Expose the promise to the ModuleWrap directly for linking below.\n    // `this.module` is also filled in below.\n    this.modulePromise = ReflectApply(moduleProvider\x2C loader\x2C [url\x2C isMain]);\n\n    // Wait for the ModuleWrap instance being linked with all dependencies.\n    const link = async () => {\n      this.module = await this.modulePromise;\n      assert(this.module instanceof ModuleWrap);\n\n      // Explicitly keeping track of dependency jobs is needed in order\n      // to flatten out the dependency graph below in `_instantiate()`\x2C\n      // so that circular dependencies can't cause a deadlock by two of\n      // these `link` callbacks depending on each other.\n      const dependencyJobs = [];\n      const promises = this.module.link(async (specifier) => {\n        const jobPromise = this.loader.getModuleJob(specifier\x2C url);\n        ArrayPrototypePush(dependencyJobs\x2C jobPromise);\n        const job = await jobPromise;\n        return job.modulePromise;\n      });\n\n      if (promises !== undefined)\n        await PromiseAll(new SafeArrayIterator(promises));\n\n      return PromiseAll(new SafeArrayIterator(dependencyJobs));\n    };\n    // Promise for the list of all dependencyJobs.\n    this.linked = link();\n    // This promise is awaited later anyway\x2C so silence\n    // 'unhandled rejection' warnings.\n    PromisePrototypeCatch(this.linked\x2C noop);\n\n    // instantiated == deep dependency jobs wrappers are instantiated\x2C\n    // and module wrapper is instantiated.\n    this.instantiated = undefined;\n  }\n\n  instantiate() {\n    if (this.instantiated === undefined) {\n      this.instantiated = this._instantiate();\n    }\n    return this.instantiated;\n  }\n\n  async _instantiate() {\n    const jobsInGraph = new SafeSet();\n    const addJobsToDependencyGraph = async (moduleJob) => {\n      if (jobsInGraph.has(moduleJob)) {\n        return;\n      }\n      jobsInGraph.add(moduleJob);\n      const dependencyJobs = await moduleJob.linked;\n      return PromiseAll(new SafeArrayIterator(\n        ArrayPrototypeMap(dependencyJobs\x2C addJobsToDependencyGraph)));\n    };\n    await addJobsToDependencyGraph(this);\n\n    try {\n      if (!hasPausedEntry && this.inspectBrk) {\n        hasPausedEntry = true;\n        const initWrapper = internalBinding('inspector').callAndPauseOnStart;\n        initWrapper(this.module.instantiate\x2C this.module);\n      } else {\n        this.module.instantiate();\n      }\n    } catch (e) {\n      decorateErrorStack(e);\n      // TODO(@bcoe): Add source map support to exception that occurs as result\n      // of missing named export. This is currently not possible because\n      // stack trace originates in module_job\x2C not the file itself. A hidden\n      // symbol with filename could be set in node_errors.cc to facilitate this.\n      if (!getSourceMapsEnabled() &&\n          StringPrototypeIncludes(e.message\x2C\n                                  ' does not provide an export named')) {\n        const splitStack = StringPrototypeSplit(e.stack\x2C '\\n');\n        const parentFileUrl = StringPrototypeReplace(\n          splitStack[0]\x2C\n          /:\\d+$/\x2C\n          ''\n        );\n        const { 1: childSpecifier\x2C 2: name } = StringPrototypeMatch(\n          e.message\x2C\n          /module '(.*)' does not provide an export named '(.+)'/);\n        const { url: childFileURL } = await this.loader.resolve(\n          childSpecifier\x2C parentFileUrl\x2C\n        );\n        const { format } = await this.loader.load(childFileURL);\n\n        if (format === 'commonjs') {\n          const importStatement = splitStack[1];\n          // TODO(@ctavan): The original error stack only provides the single\n          // line which causes the error. For multi-line import statements we\n          // cannot generate an equivalent object destructuring assignment by\n          // just parsing the error stack.\n          const oneLineNamedImports = StringPrototypeMatch(importStatement\x2C /{.*}/);\n          const destructuringAssignment = oneLineNamedImports &&\n            StringPrototypeReplace(oneLineNamedImports\x2C /\\s+as\\s+/g\x2C ': ');\n          e.message = `Named export '${name}' not found. The requested module` +\n            ` '${childSpecifier}' is a CommonJS module\x2C which may not support` +\n            ' all module.exports as named exports.\\nCommonJS modules can ' +\n            'always be imported via the default export\x2C for example using:' +\n            `\\n\\nimport pkg from '${childSpecifier}';\\n${\n              destructuringAssignment ?\n                `const ${destructuringAssignment} = pkg;\\n` : ''}`;\n          const newStack = StringPrototypeSplit(e.stack\x2C '\\n');\n          newStack[3] = `SyntaxError: ${e.message}`;\n          e.stack = ArrayPrototypeJoin(newStack\x2C '\\n');\n        }\n      }\n      throw e;\n    }\n\n    for (const dependencyJob of jobsInGraph) {\n      // Calling `this.module.instantiate()` instantiates not only the\n      // ModuleWrap in this module\x2C but all modules in the graph.\n      dependencyJob.instantiated = resolvedPromise;\n    }\n  }\n\n  async run() {\n    await this.instantiate();\n    const timeout = -1;\n    const breakOnSigint = false;\n    try {\n      await this.module.evaluate(timeout\x2C breakOnSigint);\n    } catch (e) {\n      if (e?.name === 'ReferenceError' &&\n          isCommonJSGlobalLikeNotDefinedError(e.message)) {\n        e.message += ' in ES module scope';\n\n        if (StringPrototypeStartsWith(e.message\x2C 'require ')) {\n          e.message += '\x2C you can use import instead';\n        }\n\n        const packageConfig =\n          StringPrototypeStartsWith(this.module.url\x2C 'file://') &&\n            RegExpPrototypeTest(/\\.js(\\?[^#]*)?(#.*)?$/\x2C this.module.url) &&\n            require('internal/modules/esm/resolve')\n              .getPackageScopeConfig(this.module.url);\n        if (packageConfig.type === 'module') {\n          e.message +=\n            '\\nThis file is being treated as an ES module because it has a ' +\n            `'.js' file extension and '${packageConfig.pjsonPath}' contains ` +\n            '"type": "module". To treat it as a CommonJS script\x2C rename it ' +\n            'to use the \\'.cjs\\' file extension.';\n        }\n      }\n      throw e;\n    }\n    return { module: this.module };\n  }\n}\nObjectSetPrototypeOf(ModuleJob.prototype\x2C null);\nmodule.exports = ModuleJob;\n
code-source-info,0x1eea2daa9a9e,104,0,7692,C0O0C4O7692,,
code-creation,Function,10,100975,0x1eea2daa9f8e,334, node:internal/modules/esm/module_job:1:1,0x1eea2daa9a18,~
code-source-info,0x1eea2daa9f8e,104,0,7692,C0O0C85O25C91O47C97O68C103O90C109O112C114O133C119O157C125O171C130O189C136O214C142O230C148O253C154O274C160O285C166O312C172O336C178O362C184O386C190O454C196O454C201O439C207O518C213O518C218O495C224O580C230O580C235O554C241O644C247O644C251O644C253O696C256O696C258O728C260O728C262O769C263O769C265O799C269O799C271O917C275O917C314O7646C321O7615C326O7664C328O7679C333O7691,,
tick,0x10f10dad4,101057,1,0x10ea6ba00,6,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2daa908a,0x11b703c03,0x11b703885,0x1eea2daa75bd,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
tick,0x10efd3a67,102320,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2daa75d5,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Eval,10,102349,0x1eea2daaccc6,5, node:internal/modules/esm/resolve:1:1,0x1eea2daac5d0,~
script-source,105,node:internal/modules/esm/resolve,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  JSONParse\x2C\n  JSONStringify\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst internalFS = require('internal/fs/utils');\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  realpathSync\x2C\n  statSync\x2C\n  Stats\x2C\n} = require('fs');\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst { sep\x2C relative\x2C resolve } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst typeFlag = getOptionValue('--input-type');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\nconst { URL\x2C pathToFileURL\x2C fileURLToPath } = require('internal/url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n  ERR_INVALID_PACKAGE_TARGET\x2C\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n  ERR_PACKAGE_IMPORT_NOT_DEFINED\x2C\n  ERR_PACKAGE_PATH_NOT_EXPORTED\x2C\n  ERR_UNSUPPORTED_DIR_IMPORT\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst { Module: CJSModule } = require('internal/modules/cjs/loader');\n\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\nconst DEFAULT_CONDITIONS = ObjectFreeze([\n  'node'\x2C\n  'import'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\n/**\n * @typedef {string | string[] | Record<string\x2C unknown>} Exports\n * @typedef {'module' | 'commonjs'} PackageType\n * @typedef {{\n *   exports?: ExportConfig;\n *   name?: string;\n *   main?: string;\n *   type?: PackageType;\n * }} PackageConfig\n */\n\nconst emittedPackageWarnings = new SafeSet();\n\n/**\n * @param {string} match\n * @param {URL} pjsonUrl\n * @param {boolean} isExports\n * @param {string | URL | undefined} base\n * @returns {void}\n */\nfunction emitFolderMapDeprecation(match\x2C pjsonUrl\x2C isExports\x2C base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated folder mapping "${match}" in the ${isExports ?\n      '"exports"' : '"imports"'} field module resolution of the package at ${\n      pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ''}.\\n` +\n      `Update this package.json to use a subpath pattern like "${match}*".`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0148'\n  );\n}\n\nfunction emitTrailingSlashPatternDeprecation(match\x2C pjsonUrl\x2C isExports\x2C base) {\n  if (!pendingDeprecation) return;\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated trailing slash pattern mapping "${match}" in the ${\n      isExports ? '"exports"' : '"imports"'} field module resolution of the ` +\n      `package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` :\n        ''}. Mapping specifiers ending in "/" is no longer supported.`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0155'\n  );\n}\n\n/**\n * @param {URL} url\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @param {string} main\n * @returns\n */\nfunction emitLegacyIndexDeprecation(url\x2C packageJSONUrl\x2C base\x2C main) {\n  const format = defaultGetFormat(url);\n  if (format !== 'module')\n    return;\n  const path = fileURLToPath(url);\n  const pkgPath = fileURLToPath(new URL('.'\x2C packageJSONUrl));\n  const basePath = fileURLToPath(base);\n  if (main)\n    process.emitWarning(\n      `Package ${pkgPath} has a "main" field set to ${JSONStringify(main)}\x2C ` +\n      `excluding the full filename and extension to the resolved file at "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${\n        basePath}.\\n Automatic extension resolution of the "main" field is ` +\n      'deprecated for ES modules.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n  else\n    process.emitWarning(\n      `No "main" or "exports" field defined in the package.json for ${pkgPath\n      } resolving the main entry point "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${basePath\n      }.\\nDefault "index" lookups for the main are deprecated for ES modules.`\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n}\n\n/**\n * @param {string[]} [conditions]\n * @returns {Set<string>}\n */\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions'\x2C conditions\x2C\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap();  /* string -> PackageConfig */\n\n/**\n * @param {string | URL} path\n * @returns {import('fs').Stats}\n */\nconst tryStatSync =\n  (path) => statSync(path\x2C { throwIfNoEntry: false }) ?? new Stats();\n\n/**\n * @param {string} path\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {PackageConfig}\n */\nfunction getPackageConfig(path\x2C specifier\x2C base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path\x2C\n      exists: false\x2C\n      main: undefined\x2C\n      name: undefined\x2C\n      type: 'none'\x2C\n      exports: undefined\x2C\n      imports: undefined\x2C\n    };\n    packageJSONCache.set(path\x2C packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path\x2C\n      (base ? `"${specifier}" from ` : '') + fileURLToPath(base || specifier)\x2C\n      error.message\n    );\n  }\n\n  let { imports\x2C main\x2C name\x2C type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\n  if (typeof main !== 'string') main = undefined;\n  if (typeof name !== 'string') name = undefined;\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\n\n  const packageConfig = {\n    pjsonPath: path\x2C\n    exists: true\x2C\n    main\x2C\n    name\x2C\n    type\x2C\n    exports\x2C\n    imports\x2C\n  };\n  packageJSONCache.set(path\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {URL | string} resolved\n * @returns {PackageConfig}\n */\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json'\x2C resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath\x2C 'node_modules/package.json'))\n      break;\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl)\x2C\n                                           resolved);\n    if (packageConfig.exists) return packageConfig;\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json'\x2C packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check "/package.json" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath\x2C\n    exists: false\x2C\n    main: undefined\x2C\n    name: undefined\x2C\n    type: 'none'\x2C\n    exports: undefined\x2C\n    imports: undefined\x2C\n  };\n  packageJSONCache.set(packageJSONPath\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {string | URL} url\n * @returns {boolean}\n */\nfunction fileExists(url) {\n  return statSync(url\x2C { throwIfNoEntry: false })?.isFile() ?? false;\n}\n\n/**\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M\x2C M.js\x2C M.json\x2C M.node)\n * 3. TRY(M/index.js\x2C M/index.json\x2C M/index.node)\n * 4. TRY(pkg_url/index.js\x2C pkg_url/index.json\x2C pkg_url/index.node)\n * 5. NOT_FOUND\n * @param {URL} packageJSONUrl\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @returns {URL}\n */\nfunction legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess = new URL(`./${packageConfig.main}`\x2C\n                                   packageJSONUrl))) {\n      return guess;\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`\x2C\n                                          packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.node`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`\x2C\n                                        packageJSONUrl)));\n    else guess = undefined;\n    if (guess) {\n      emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C\n                                 packageConfig.main);\n      return guess;\n    }\n    // Fallthrough.\n  }\n  if (fileExists(guess = new URL('./index.js'\x2C packageJSONUrl)));\n  // So fs.\n  else if (fileExists(guess = new URL('./index.json'\x2C packageJSONUrl)));\n  else if (fileExists(guess = new URL('./index.node'\x2C packageJSONUrl)));\n  else guess = undefined;\n  if (guess) {\n    emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C packageConfig.main);\n    return guess;\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C fileURLToPath(base));\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensionsWithTryExactName(search) {\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\nconst extensions = ['.js'\x2C '.json'\x2C '.node'\x2C '.mjs'];\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensions(search) {\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const guess = new URL(`${search.pathname}${extension}`\x2C search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveDirectoryEntry(search) {\n  const dirPath = fileURLToPath(search);\n  const pkgJsonPath = resolve(dirPath\x2C 'package.json');\n  if (fileExists(pkgJsonPath)) {\n    const pkgJson = packageJsonReader.read(pkgJsonPath);\n    if (pkgJson.containsKeys) {\n      const { main } = JSONParse(pkgJson.string);\n      if (main != null) {\n        const mainUrl = pathToFileURL(resolve(dirPath\x2C main));\n        return resolveExtensionsWithTryExactName(mainUrl);\n      }\n    }\n  }\n  return resolveExtensions(new URL('index'\x2C search));\n}\n\nconst encodedSepRegEx = /%2F|%2C/i;\n/**\n * @param {URL} resolved\n * @param {string | URL | undefined} base\n * @returns {URL | undefined}\n */\nfunction finalizeResolution(resolved\x2C base) {\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved.pathname))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname\x2C 'must not include encoded "/" or "\\\\" characters'\x2C\n      fileURLToPath(base));\n\n  const path = fileURLToPath(resolved);\n  if (getOptionValue('--experimental-specifier-resolution') === 'node') {\n    let file = resolveExtensionsWithTryExactName(resolved);\n    if (file !== undefined) return file;\n    if (!StringPrototypeEndsWith(path\x2C '/')) {\n      file = resolveDirectoryEntry(new URL(`${resolved}/`));\n      if (file !== undefined) return file;\n    } else {\n      return resolveDirectoryEntry(resolved) || resolved;\n    }\n    throw new ERR_MODULE_NOT_FOUND(\n      resolved.pathname\x2C fileURLToPath(base)\x2C 'module');\n  }\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path\x2C '/') ?\n    StringPrototypeSlice(path\x2C -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path\x2C fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname\x2C base && fileURLToPath(base)\x2C 'module');\n  }\n\n  return resolved;\n}\n\n/**\n * @param {string} specifier\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwImportNotDefined(specifier\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier\x2C packageJSONUrl && fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C\n    fileURLToPath(base));\n}\n\n/**\n * @param {string} specifier\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwExportsNotFound(subpath\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C\n    base && fileURLToPath(base));\n}\n\n/**\n *\n * @param {string | URL} subpath\n * @param {URL} packageJSONUrl\n * @param {boolean} internal\n * @param {string | URL | undefined} base\n */\nfunction throwInvalidSubpath(subpath\x2C packageJSONUrl\x2C internal\x2C base) {\n  const reason = `request is not a valid subpath for the "${internal ?\n    'imports' : 'exports'}" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath\x2C reason\x2C\n                                         base && fileURLToPath(base));\n}\n\nfunction throwInvalidPackageTarget(\n  subpath\x2C target\x2C packageJSONUrl\x2C internal\x2C base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target\x2C null\x2C '');\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C target\x2C\n    internal\x2C base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\nconst patternRegEx = /\\*/g;\n\nfunction resolvePackageTargetString(\n  target\x2C subpath\x2C match\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C conditions) {\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (!StringPrototypeStartsWith(target\x2C './')) {\n    if (internal && !StringPrototypeStartsWith(target\x2C '../') &&\n        !StringPrototypeStartsWith(target\x2C '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {}\n      if (!isURL) {\n        const exportTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target + subpath;\n        return packageResolve(exportTarget\x2C packageJSONUrl\x2C conditions);\n      }\n    }\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  const resolved = new URL(target\x2C packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.'\x2C packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath\x2C packagePath))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C subpath))\n    throwInvalidSubpath(match + subpath\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (pattern)\n    return new URL(RegExpPrototypeSymbolReplace(patternRegEx\x2C resolved.href\x2C\n                                                () => subpath));\n  return new URL(subpath\x2C resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\nfunction resolvePackageTarget(packageJSONUrl\x2C target\x2C subpath\x2C packageSubpath\x2C\n                              base\x2C pattern\x2C internal\x2C conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target\x2C subpath\x2C packageSubpath\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C\n      conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0)\n      return null;\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolved;\n      try {\n        resolved = resolvePackageTarget(\n          packageJSONUrl\x2C targetItem\x2C subpath\x2C packageSubpath\x2C base\x2C pattern\x2C\n          internal\x2C conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET')\n          continue;\n        throw e;\n      }\n      if (resolved === undefined)\n        continue;\n      if (resolved === null) {\n        lastException = null;\n        continue;\n      }\n      return resolved;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl)\x2C base\x2C\n          '"exports" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolved = resolvePackageTarget(\n          packageJSONUrl\x2C conditionalTarget\x2C subpath\x2C packageSubpath\x2C base\x2C\n          pattern\x2C internal\x2C conditions);\n        if (resolved === undefined)\n          continue;\n        return resolved;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath\x2C target\x2C packageJSONUrl\x2C internal\x2C\n                            base);\n}\n\n/**\n *\n * @param {Exports} exports\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @returns\n */\nfunction isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl)\x2C base\x2C\n        '"exports" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageExportsResolve(\n  packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports\x2C packageSubpath) &&\n      !StringPrototypeIncludes(packageSubpath\x2C '*') &&\n      !StringPrototypeEndsWith(packageSubpath\x2C '/')) {\n    const target = exports[packageSubpath];\n    const resolved = resolvePackageTarget(\n      packageJSONUrl\x2C target\x2C ''\x2C packageSubpath\x2C base\x2C false\x2C false\x2C conditions\n    );\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    return { resolved\x2C exact: true };\n  }\n\n  let bestMatch = '';\n  let bestMatchSubpath;\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n    if (patternIndex !== -1 &&\n        StringPrototypeStartsWith(packageSubpath\x2C\n                                  StringPrototypeSlice(key\x2C 0\x2C patternIndex))) {\n      if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n        emitTrailingSlashPatternDeprecation(packageSubpath\x2C packageJSONUrl\x2C\n                                            true\x2C base);\n      const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n      if (packageSubpath.length >= key.length &&\n          StringPrototypeEndsWith(packageSubpath\x2C patternTrailer) &&\n          patternKeyCompare(bestMatch\x2C key) === 1 &&\n          StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = StringPrototypeSlice(\n          packageSubpath\x2C patternIndex\x2C\n          packageSubpath.length - patternTrailer.length);\n      }\n    } else if (key[key.length - 1] === '/' &&\n      StringPrototypeStartsWith(packageSubpath\x2C key) &&\n      patternKeyCompare(bestMatch\x2C key) === 1) {\n      bestMatch = key;\n      bestMatchSubpath = StringPrototypeSlice(packageSubpath\x2C key.length);\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const pattern = StringPrototypeIncludes(bestMatch\x2C '*');\n    const resolved = resolvePackageTarget(packageJSONUrl\x2C target\x2C\n                                          bestMatchSubpath\x2C bestMatch\x2C base\x2C\n                                          pattern\x2C false\x2C conditions);\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    if (!pattern)\n      emitFolderMapDeprecation(bestMatch\x2C packageJSONUrl\x2C true\x2C base);\n    return { resolved\x2C exact: pattern };\n  }\n\n  throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n}\n\nfunction patternKeyCompare(a\x2C b) {\n  const aPatternIndex = StringPrototypeIndexOf(a\x2C '*');\n  const bPatternIndex = StringPrototypeIndexOf(b\x2C '*');\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB) return -1;\n  if (baseLenB > baseLenA) return 1;\n  if (aPatternIndex === -1) return 1;\n  if (bPatternIndex === -1) return -1;\n  if (a.length > b.length) return -1;\n  if (b.length > a.length) return 1;\n  return 0;\n}\n\n/**\n * @param {string} name\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns\n */\nfunction packageImportsResolve(name\x2C base\x2C conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name\x2C '#/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name\x2C reason\x2C fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports\x2C name) &&\n          !StringPrototypeIncludes(name\x2C '*') &&\n          !StringPrototypeEndsWith(name\x2C '/')) {\n        const resolved = resolvePackageTarget(\n          packageJSONUrl\x2C imports[name]\x2C ''\x2C name\x2C base\x2C false\x2C true\x2C conditions\n        );\n        if (resolved !== null)\n          return { resolved\x2C exact: true };\n      } else {\n        let bestMatch = '';\n        let bestMatchSubpath;\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n          if (patternIndex !== -1 &&\n              StringPrototypeStartsWith(name\x2C\n                                        StringPrototypeSlice(key\x2C 0\x2C\n                                                             patternIndex))) {\n            const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n            if (name.length >= key.length &&\n                StringPrototypeEndsWith(name\x2C patternTrailer) &&\n                patternKeyCompare(bestMatch\x2C key) === 1 &&\n                StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n              bestMatch = key;\n              bestMatchSubpath = StringPrototypeSlice(\n                name\x2C patternIndex\x2C name.length - patternTrailer.length);\n            }\n          } else if (key[key.length - 1] === '/' &&\n            StringPrototypeStartsWith(name\x2C key) &&\n            patternKeyCompare(bestMatch\x2C key) === 1) {\n            bestMatch = key;\n            bestMatchSubpath = StringPrototypeSlice(name\x2C key.length);\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const pattern = StringPrototypeIncludes(bestMatch\x2C '*');\n          const resolved = resolvePackageTarget(packageJSONUrl\x2C target\x2C\n                                                bestMatchSubpath\x2C bestMatch\x2C\n                                                base\x2C pattern\x2C true\x2C\n                                                conditions);\n          if (resolved !== null) {\n            if (!pattern)\n              emitFolderMapDeprecation(bestMatch\x2C packageJSONUrl\x2C false\x2C base);\n            return { resolved\x2C exact: pattern };\n          }\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name\x2C packageJSONUrl\x2C base);\n}\n\n/**\n * @param {URL} url\n * @returns {PackageType}\n */\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {{ packageName: string\x2C packageSubpath: string\x2C isScoped: boolean }}\n */\nfunction parsePackageName(specifier\x2C base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier\x2C '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier\x2C '/'\x2C separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier\x2C 0\x2C separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // separators.\n  for (let i = 0; i < packageName.length; i++) {\n    if (packageName[i] === '%' || packageName[i] === '\\\\') {\n      validPackageName = false;\n      break;\n    }\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier\x2C 'is not a valid package name'\x2C fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier\x2C separatorIndex));\n\n  return { packageName\x2C packageSubpath\x2C isScoped };\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageResolve(specifier\x2C base\x2C conditions) {\n  const { packageName\x2C packageSubpath\x2C isScoped } =\n    parsePackageName(specifier\x2C base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions\n      ).resolved;\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json'\x2C base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath\x2C 0\x2C\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json'\x2C packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath\x2C specifier\x2C base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null)\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions\n      ).resolved;\n    if (packageSubpath === '.')\n      return legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base);\n    return new URL(packageSubpath\x2C packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName\x2C fileURLToPath(base));\n}\n\n/**\n * @param {string} specifier\n * @returns {boolean}\n */\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction moduleResolve(specifier\x2C base\x2C conditions) {\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier\x2C base);\n  } else if (specifier[0] === '#') {\n    ({ resolved } = packageImportsResolve(specifier\x2C base\x2C conditions));\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      resolved = packageResolve(specifier\x2C base\x2C conditions);\n    }\n  }\n  return finalizeResolution(resolved\x2C base);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier\x2C parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent\x2C null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier\x2C tmpModule\x2C false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent\x2C found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found\x2C `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier\x2C '/')[0];\n      const index = StringPrototypeIndexOf(found\x2C pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found\x2C index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = RegExpPrototypeSymbolReplace(new RegExp(`\\\\${sep}`\x2C 'g')\x2C\n                                           found\x2C '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\nfunction defaultResolve(specifier\x2C context = {}\x2C defaultResolveUnused) {\n  let { parentURL\x2C conditions } = context;\n  if (parentURL && policy?.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve\x2C reaction } = redirects;\n      const destination = resolve(specifier\x2C new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C '))\n        );\n      }\n    }\n  }\n  let parsed;\n  try {\n    parsed = new URL(specifier);\n    if (parsed.protocol === 'data:') {\n      return {\n        url: specifier\n      };\n    }\n  } catch {}\n  if (parsed && parsed.protocol === 'node:')\n    return { url: specifier };\n  if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:')\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n  if (NativeModule.canBeRequiredByUsers(specifier)) {\n    return {\n      url: 'node:' + specifier\n    };\n  }\n  if (parentURL && StringPrototypeStartsWith(parentURL\x2C 'data:')) {\n    // This is gonna blow up\x2C we want the error\n    new URL(specifier\x2C parentURL);\n  }\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program\x2C and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval\x2C --print or STDIN string input. It is not allowed with file\n    // input\x2C to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only\x2C package scope surrounding the\n    // entry point\x2C etc.).\n    if (typeFlag)\n      throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(specifier\x2C parentURL\x2C conditions);\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier\x2C 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier\x2C parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack\x2C '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines\x2C '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {\n    const urlPath = fileURLToPath(url);\n    const real = realpathSync(urlPath\x2C {\n      [internalFS.realpathCacheKey]: realpathCache\n    });\n    const old = url;\n    url = pathToFileURL(\n      real + (StringPrototypeEndsWith(urlPath\x2C sep) ? '/' : ''));\n    url.search = old.search;\n    url.hash = old.hash;\n  }\n\n  return { url: `${url}` };\n}\n\nmodule.exports = {\n  DEFAULT_CONDITIONS\x2C\n  defaultResolve\x2C\n  encodedSepRegEx\x2C\n  getPackageScopeConfig\x2C\n  getPackageType\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\n};\n\n// cycle\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\n
code-source-info,0x1eea2daaccc6,105,0,36468,C0O0C4O36468,,
tick,0x10ebc3bd0,104870,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2daa75d5,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
tick,0x7fff203e5398,104895,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2daa75d5,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Function,10,104909,0x1eea2daadc66,1086, node:internal/modules/esm/resolve:1:1,0x1eea2daacc40,~
code-source-info,0x1eea2daadc66,105,0,36468,C0O0C379O25C385O41C391O63C397O86C403O99C409O116C414O132C420O161C426O194C432O204C438O236C444O259C449O270C455O281C461O291C467O318C473O345C479O371C485O401C491O425C497O449C503O512C506O512C510O512C512O567C515O567C520O550C526O655C529O655C534O616C540O632C546O644C552O697C555O697C560O678C566O792C572O792C581O836C588O792C590O916C593O916C598O889C604O894C610O904C616O958C622O958C626O958C628O1026C634O1026C638O1026C640O1087C646O1087C650O1087C652O1146C658O1146C662O1146C664O1233C667O1233C672O1195C678O1200C684O1215C690O1607C693O1607C698O1633C703O1268C709O1298C715O1323C721O1355C727O1385C733O1415C739O1450C745O1474C751O1508C757O1541C763O1571C769O1671C772O1671C777O1657C783O1738C786O1738C790O1738C792O1810C798O1810C803O1859C809O1859C814O1914C825O1975C832O2017C833O2017C887O2039C938O1975C942O1975C944O2091C952O2091C957O2091C959O2408C962O2408C967O2408C969O5520C971O5520C976O5520C978O5560C980O5560C985O5560C987O5700C991O5700C993O11011C997O11011C999O11985C1003O11985C1005O14877C1009O14877C1011O14940C1015O14940C1017O36212C1024O36233C1030O36255C1036O36273C1042O36292C1048O36317C1054O36335C1060O36360C1066O36227C1070O36424C1073O36424C1078O36403C1085O36467,,
code-creation,Eval,10,105498,0x1eea2dab0e4e,5, node:internal/modules/esm/get_format:1:1,0x1eea2dab0c28,~
script-source,106,node:internal/modules/esm/get_format,'use strict';\nconst {\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n} = primordials;\nconst { extname } = require('path');\nconst { getOptionValue } = require('internal/options');\n\nconst experimentalJsonModules = getOptionValue('--experimental-json-modules');\nconst experimentalSpecifierResolution =\n  getOptionValue('--experimental-specifier-resolution');\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\nconst { getPackageType } = require('internal/modules/esm/resolve');\nconst { URL\x2C fileURLToPath } = require('internal/url');\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('internal/errors').codes;\n\nconst extensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'module'\x2C\n  '.mjs': 'module'\n};\n\nconst legacyExtensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'commonjs'\x2C\n  '.json': 'commonjs'\x2C\n  '.mjs': 'module'\x2C\n  '.node': 'commonjs'\n};\n\nif (experimentalWasmModules)\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\n\nif (experimentalJsonModules)\n  extensionFormatMap['.json'] = legacyExtensionFormatMap['.json'] = 'json';\n\nconst protocolHandlers = ObjectAssign(ObjectCreate(null)\x2C {\n  'data:'(parsed) {\n    const { 1: mime } = RegExpPrototypeExec(\n      /^([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n      parsed.pathname\x2C\n    ) || [\x2C null];\n    const format = ({\n      '__proto__': null\x2C\n      'text/javascript': 'module'\x2C\n      'application/json': experimentalJsonModules ? 'json' : null\x2C\n      'application/wasm': experimentalWasmModules ? 'wasm' : null\n    })[mime] || null;\n\n    return format;\n  }\x2C\n  'file:'(parsed\x2C url) {\n    const ext = extname(parsed.pathname);\n    let format;\n\n    if (ext === '.js') {\n      format = getPackageType(parsed.href) === 'module' ? 'module' : 'commonjs';\n    } else {\n      format = extensionFormatMap[ext];\n    }\n    if (!format) {\n      if (experimentalSpecifierResolution === 'node') {\n        process.emitWarning(\n          'The Node.js specifier resolution in ESM is experimental.'\x2C\n          'ExperimentalWarning');\n        format = legacyExtensionFormatMap[ext];\n      } else {\n        throw new ERR_UNKNOWN_FILE_EXTENSION(ext\x2C fileURLToPath(url));\n      }\n    }\n\n    return format || null;\n  }\x2C\n  'node:'() { return 'builtin'; }\x2C\n});\n\nfunction defaultGetFormat(url\x2C context) {\n  const parsed = new URL(url);\n\n  return ObjectPrototypeHasOwnProperty(protocolHandlers\x2C parsed.protocol) ?\n    protocolHandlers[parsed.protocol](parsed\x2C url) :\n    null;\n}\n\nmodule.exports = {\n  defaultGetFormat\x2C\n  extensionFormatMap\x2C\n  legacyExtensionFormatMap\x2C\n};\n
code-source-info,0x1eea2dab0e4e,106,0,2630,C0O0C4O2630,,
code-creation,Function,10,105719,0x1eea2dab127e,314, node:internal/modules/esm/get_format:1:1,0x1eea2dab0dc8,~
code-source-info,0x1eea2dab127e,106,0,2630,C0O0C53O24C58O40C63O56C69O89C75O147C78O147C83O135C89O191C92O191C97O172C102O253C105O253C109O253C111O342C114O342C118O342C120O429C123O429C127O429C129O503C132O503C137O484C143O575C146O575C151O552C157O557C163O639C166O639C171O665C176O608C182O701C186O701C188O821C192O821C194O956C198O987C207O1051C213O1015C217O1062C221O1093C230O1157C236O1121C240O1193C242O1206C252O1230C260O1646C268O2284C276O1193C281O1193C283O2538C290O2559C296O2579C302O2601C308O2553C313O2629,,
code-creation,Eval,10,105909,0x1eea2dab1c0e,5, node:internal/modules/esm/load:1:1,0x1eea2dab1a98,~
script-source,107,node:internal/modules/esm/load,'use strict';\n\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\nconst { defaultGetSource } = require('internal/modules/esm/get_source');\nconst { translators } = require('internal/modules/esm/translators');\n\nasync function defaultLoad(url\x2C context) {\n  let {\n    format\x2C\n    source\x2C\n  } = context;\n\n  if (!translators.has(format)) format = defaultGetFormat(url);\n\n  if (\n    format === 'builtin' ||\n    format === 'commonjs'\n  ) {\n    source = null;\n  } else if (source == null) {\n    source = await defaultGetSource(url\x2C { format });\n  }\n\n  return {\n    format\x2C\n    source\x2C\n  };\n}\n\nmodule.exports = {\n  defaultLoad\x2C\n};\n
code-source-info,0x1eea2dab1c0e,107,0,643,C0O0C4O643,,
code-creation,Function,10,106012,0x1eea2dab1d56,80, node:internal/modules/esm/load:1:1,0x1eea2dab1b88,~
code-source-info,0x1eea2dab1d56,107,0,643,C0O0C19O44C22O44C27O23C33O117C36O117C41O96C47O185C50O185C55O169C61O606C68O627C74O621C79O642,,
tick,0x7fff20215b64,106084,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Eval,10,106129,0x1eea2dab22be,5, node:internal/modules/esm/get_source:1:1,0x1eea2dab20e8,~
script-source,108,node:internal/modules/esm/get_source,'use strict';\n\nconst {\n  RegExpPrototypeExec\x2C\n  decodeURIComponent\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\nconst { Buffer } = require('buffer');\n\nconst fs = require('internal/fs/promises').exports;\nconst { URL } = require('internal/url');\nconst {\n  ERR_INVALID_URL\x2C\n  ERR_INVALID_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst readFileAsync = fs.readFile;\n\nconst DATA_URL_PATTERN = /^[^/]+\\/[^\x2C;]+(?:[^\x2C]*?)(;base64)?\x2C([\\s\\S]*)$/;\n\nasync function defaultGetSource(url\x2C { format } = {}\x2C defaultGetSource) {\n  const parsed = new URL(url);\n  let source;\n  if (parsed.protocol === 'file:') {\n    source = await readFileAsync(parsed);\n  } else if (parsed.protocol === 'data:') {\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN\x2C parsed.pathname);\n    if (!match) {\n      throw new ERR_INVALID_URL(url);\n    }\n    const { 1: base64\x2C 2: body } = match;\n    source = Buffer.from(decodeURIComponent(body)\x2C base64 ? 'base64' : 'utf8');\n  } else {\n    throw new ERR_INVALID_URL_SCHEME(['file'\x2C 'data']);\n  }\n  if (policy?.manifest) {\n    policy.manifest.assertIntegrity(parsed\x2C source);\n  }\n  return source;\n}\nexports.defaultGetSource = defaultGetSource;\n
code-source-info,0x1eea2dab22be,108,0,1349,C0O0C4O1349,,
code-creation,Function,10,106259,0x1eea2dab242e,169, node:internal/modules/esm/get_source:1:1,0x1eea2dab2238,~
code-source-info,0x1eea2dab242e,108,0,1349,C0O0C37O25C43O48C49O112C52O112C57O93C62O207C65O207C74O251C81O207C83O316C86O316C91O305C97O347C100O347C105O378C110O404C113O404C118O396C124O486C127O486C132O512C137O439C143O458C149O545C153O542C155O581C159O581C161O1304C163O1329C168O1348,,
tick,0x10f01bfbf,107298,1,0x10ea6ba00,2,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2dab2492,0x11b703c03,0x11b703885,0x1eea2dab1d7a,0x11b703c03,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Eval,10,107744,0x1eea2dab37a6,5, node:internal/fs/promises:1:1,0x1eea2dab3008,~
script-source,109,node:internal/fs/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  Error\x2C\n  MathMax\x2C\n  MathMin\x2C\n  NumberIsSafeInteger\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  SafeArrayIterator\x2C\n  SafePromisePrototypeFinally\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  F_OK\x2C\n  O_SYMLINK\x2C\n  O_WRONLY\x2C\n  S_IFMT\x2C\n  S_IFREG\n} = internalBinding('constants').fs;\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\n\nconst {\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst { isArrayBufferView } = require('internal/util/types');\nconst { rimrafPromises } = require('internal/fs/rimraf');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  copyObject\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getStatsFromBinding\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validateRmOptions\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n} = require('internal/fs/utils');\nconst { opendir } = require('internal/fs/dir');\nconst {\n  parseFileMode\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst { lazyDOMException\x2C promisify } = require('internal/util');\nconst { EventEmitterMixin } = require('internal/event_target');\nconst { watch } = require('internal/fs/watchers');\nconst { isIterable } = require('internal/streams/utils');\nconst assert = require('internal/assert');\n\nconst kHandle = Symbol('kHandle');\nconst kFd = Symbol('kFd');\nconst kRefs = Symbol('kRefs');\nconst kClosePromise = Symbol('kClosePromise');\nconst kCloseResolve = Symbol('kCloseResolve');\nconst kCloseReject = Symbol('kCloseReject');\nconst kRef = Symbol('kRef');\nconst kUnref = Symbol('kUnref');\n\nconst { kUsePromises } = binding;\nconst {\n  JSTransferable\x2C kDeserialize\x2C kTransfer\x2C kTransferList\n} = require('internal/worker/js_transferable');\n\nconst getDirectoryEntriesPromise = promisify(getDirents);\nconst validateRmOptionsPromise = promisify(validateRmOptions);\n\nlet cpPromises;\nfunction lazyLoadCpPromises() {\n  return cpPromises ??= require('internal/fs/cp/cp').cpFn;\n}\n\n// Lazy loaded to avoid circular dependency.\nlet fsStreams;\nfunction lazyFsStreams() {\n  return fsStreams ??= require('internal/fs/streams');\n}\n\nclass FileHandle extends EventEmitterMixin(JSTransferable) {\n  /**\n   * @param {InternalFSBinding.FileHandle | undefined} filehandle\n   */\n  constructor(filehandle) {\n    super();\n    this[kHandle] = filehandle;\n    this[kFd] = filehandle ? filehandle.fd : -1;\n\n    this[kRefs] = 1;\n    this[kClosePromise] = null;\n  }\n\n  getAsyncId() {\n    return this[kHandle].getAsyncId();\n  }\n\n  get fd() {\n    return this[kFd];\n  }\n\n  appendFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  chmod(mode) {\n    return fsCall(fchmod\x2C this\x2C mode);\n  }\n\n  chown(uid\x2C gid) {\n    return fsCall(fchown\x2C this\x2C uid\x2C gid);\n  }\n\n  datasync() {\n    return fsCall(fdatasync\x2C this);\n  }\n\n  sync() {\n    return fsCall(fsync\x2C this);\n  }\n\n  read(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(read\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  readv(buffers\x2C position) {\n    return fsCall(readv\x2C this\x2C buffers\x2C position);\n  }\n\n  readFile(options) {\n    return fsCall(readFile\x2C this\x2C options);\n  }\n\n  stat(options) {\n    return fsCall(fstat\x2C this\x2C options);\n  }\n\n  truncate(len = 0) {\n    return fsCall(ftruncate\x2C this\x2C len);\n  }\n\n  utimes(atime\x2C mtime) {\n    return fsCall(futimes\x2C this\x2C atime\x2C mtime);\n  }\n\n  write(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(write\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  writev(buffers\x2C position) {\n    return fsCall(writev\x2C this\x2C buffers\x2C position);\n  }\n\n  writeFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  close = () => {\n    if (this[kFd] === -1) {\n      return PromiseResolve();\n    }\n\n    if (this[kClosePromise]) {\n      return this[kClosePromise];\n    }\n\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        this[kHandle].close()\x2C\n        () => { this[kClosePromise] = undefined; }\n      );\n    } else {\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        new Promise((resolve\x2C reject) => {\n          this[kCloseResolve] = resolve;\n          this[kCloseReject] = reject;\n        })\x2C () => {\n          this[kClosePromise] = undefined;\n          this[kCloseReject] = undefined;\n          this[kCloseResolve] = undefined;\n        }\n      );\n    }\n\n    this.emit('close');\n    return this[kClosePromise];\n  }\n\n  /**\n   * @typedef {import('./streams').ReadStream\n   * } ReadStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   end?: number;\n   *   highWaterMark?: number;\n   *   }} [options]\n   * @returns {ReadStream}\n   */\n  createReadStream(options = undefined) {\n    const { ReadStream } = lazyFsStreams();\n    return new ReadStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  /**\n   * @typedef {import('./streams').WriteStream\n   * } WriteStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   }} [options]\n   * @returns {WriteStream}\n   */\n  createWriteStream(options = undefined) {\n    const { WriteStream } = lazyFsStreams();\n    return new WriteStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  [kTransfer]() {\n    if (this[kClosePromise] || this[kRefs] > 1) {\n      throw lazyDOMException('Cannot transfer FileHandle while in use'\x2C\n                             'DataCloneError');\n    }\n\n    const handle = this[kHandle];\n    this[kFd] = -1;\n    this[kHandle] = null;\n    this[kRefs] = 0;\n\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/fs/promises:FileHandle'\n    };\n  }\n\n  [kTransferList]() {\n    return [ this[kHandle] ];\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kFd] = handle.fd;\n  }\n\n  [kRef]() {\n    this[kRefs]++;\n  }\n\n  [kUnref]() {\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      PromisePrototypeThen(\n        this[kHandle].close()\x2C\n        this[kCloseResolve]\x2C\n        this[kCloseReject]\n      );\n    }\n  }\n}\n\nasync function fsCall(fn\x2C handle\x2C ...args) {\n  assert(handle[kRefs] !== undefined\x2C\n         'handle must be an instance of FileHandle');\n\n  if (handle.fd === -1) {\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error('file closed');\n    err.code = 'EBADF';\n    err.syscall = fn.name;\n    throw err;\n  }\n\n  try {\n    handle[kRef]();\n    return await fn(handle\x2C ...new SafeArrayIterator(args));\n  } finally {\n    handle[kUnref]();\n  }\n}\n\nfunction checkAborted(signal) {\n  if (signal?.aborted)\n    throw new AbortError();\n}\n\nasync function writeFileHandle(filehandle\x2C data\x2C signal\x2C encoding) {\n  checkAborted(signal);\n  if (isCustomIterable(data)) {\n    for await (const buf of data) {\n      checkAborted(signal);\n      const toWrite =\n        isArrayBufferView(buf) ? buf : Buffer.from(buf\x2C encoding || 'utf8');\n      let remaining = toWrite.byteLength;\n      while (remaining > 0) {\n        const writeSize = MathMin(kWriteFileMaxChunkSize\x2C remaining);\n        const { bytesWritten } = await write(\n          filehandle\x2C toWrite\x2C toWrite.byteLength - remaining\x2C writeSize);\n        remaining -= bytesWritten;\n        checkAborted(signal);\n      }\n    }\n    return;\n  }\n  data = new Uint8Array(data.buffer\x2C data.byteOffset\x2C data.byteLength);\n  let remaining = data.byteLength;\n  if (remaining === 0) return;\n  do {\n    checkAborted(signal);\n    const { bytesWritten } =\n      await write(filehandle\x2C data\x2C 0\x2C\n                  MathMin(kWriteFileMaxChunkSize\x2C data.byteLength));\n    remaining -= bytesWritten;\n    data = new Uint8Array(\n      data.buffer\x2C\n      data.byteOffset + bytesWritten\x2C\n      data.byteLength - bytesWritten\n    );\n  } while (remaining > 0);\n}\n\nasync function readFileHandle(filehandle\x2C options) {\n  const signal = options?.signal;\n\n  checkAborted(signal);\n\n  const statFields = await binding.fstat(filehandle.fd\x2C false\x2C kUsePromises);\n\n  checkAborted(signal);\n\n  let size;\n  if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\n    size = statFields[8/* size */];\n  } else {\n    size = 0;\n  }\n\n  if (size > kIoMaxLength)\n    throw new ERR_FS_FILE_TOO_LARGE(size);\n\n  let endOfFile = false;\n  let totalRead = 0;\n  const noSize = size === 0;\n  const buffers = [];\n  const fullBuffer = noSize ? undefined : Buffer.allocUnsafeSlow(size);\n  do {\n    checkAborted(signal);\n    let buffer;\n    let offset;\n    let length;\n    if (noSize) {\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n      offset = 0;\n      length = kReadFileUnknownBufferLength;\n    } else {\n      buffer = fullBuffer;\n      offset = totalRead;\n      length = MathMin(size - totalRead\x2C kReadFileBufferLength);\n    }\n\n    const bytesRead = (await binding.read(filehandle.fd\x2C buffer\x2C offset\x2C\n                                          length\x2C -1\x2C kUsePromises)) || 0;\n    totalRead += bytesRead;\n    endOfFile = bytesRead === 0 || totalRead === size;\n    if (noSize && bytesRead > 0) {\n      const isBufferFull = bytesRead === kReadFileUnknownBufferLength;\n      const chunkBuffer = isBufferFull ? buffer : buffer.slice(0\x2C bytesRead);\n      ArrayPrototypePush(buffers\x2C chunkBuffer);\n    }\n  } while (!endOfFile);\n\n  let result;\n  if (size > 0) {\n    result = totalRead === size ? fullBuffer : fullBuffer.slice(0\x2C totalRead);\n  } else {\n    result = buffers.length === 1 ? buffers[0] : Buffer.concat(buffers\x2C\n                                                               totalRead);\n  }\n\n  return options.encoding ? result.toString(options.encoding) : result;\n}\n\n// All of the functions are defined as async in order to ensure that errors\n// thrown cause promise rejections rather than being thrown synchronously.\nasync function access(path\x2C mode = F_OK) {\n  path = getValidatedPath(path);\n\n  mode = getValidMode(mode\x2C 'access');\n  return binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C\n                        kUsePromises);\n}\n\nasync function cp(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  return lazyLoadCpPromises()(src\x2C dest\x2C options);\n}\n\nasync function copyFile(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n  mode = getValidMode(mode\x2C 'copyFile');\n  return binding.copyFile(pathModule.toNamespacedPath(src)\x2C\n                          pathModule.toNamespacedPath(dest)\x2C\n                          mode\x2C\n                          kUsePromises);\n}\n\n// Note that unlike fs.open() which uses numeric file descriptors\x2C\n// fsPromises.open() uses the fs.FileHandle class.\nasync function open(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  return new FileHandle(\n    await binding.openFileHandle(pathModule.toNamespacedPath(path)\x2C\n                                 flagsNumber\x2C mode\x2C kUsePromises));\n}\n\nasync function read(handle\x2C bufferOrOptions\x2C offset\x2C length\x2C position) {\n  let buffer = bufferOrOptions;\n  if (!isArrayBufferView(buffer)) {\n    if (bufferOrOptions === undefined) {\n      bufferOrOptions = {};\n    }\n    if (bufferOrOptions.buffer) {\n      buffer = bufferOrOptions.buffer;\n      validateBuffer(buffer);\n    } else {\n      buffer = Buffer.alloc(16384);\n    }\n    offset = bufferOrOptions.offset || 0;\n    length = buffer.byteLength;\n    position = bufferOrOptions.position || null;\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0)\n    return { bytesRead: length\x2C buffer };\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  const bytesRead = (await binding.read(handle.fd\x2C buffer\x2C offset\x2C length\x2C\n                                        position\x2C kUsePromises)) || 0;\n\n  return { bytesRead\x2C buffer };\n}\n\nasync function readv(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesRead = (await binding.readBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                               kUsePromises)) || 0;\n  return { bytesRead\x2C buffers };\n}\n\nasync function write(handle\x2C buffer\x2C offset\x2C length\x2C position) {\n  if (buffer?.byteLength === 0)\n    return { bytesWritten: 0\x2C buffer };\n\n  if (isArrayBufferView(buffer)) {\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    const bytesWritten =\n      (await binding.writeBuffer(handle.fd\x2C buffer\x2C offset\x2C\n                                 length\x2C position\x2C kUsePromises)) || 0;\n    return { bytesWritten\x2C buffer };\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n  validateEncoding(buffer\x2C length);\n  const bytesWritten = (await binding.writeString(handle.fd\x2C buffer\x2C offset\x2C\n                                                  length\x2C kUsePromises)) || 0;\n  return { bytesWritten\x2C buffer };\n}\n\nasync function writev(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesWritten = (await binding.writeBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                                   kUsePromises)) || 0;\n  return { bytesWritten\x2C buffers };\n}\n\nasync function rename(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                        pathModule.toNamespacedPath(newPath)\x2C\n                        kUsePromises);\n}\n\nasync function truncate(path\x2C len = 0) {\n  const fd = await open(path\x2C 'r+');\n  return SafePromisePrototypeFinally(ftruncate(fd\x2C len)\x2C fd.close);\n}\n\nasync function ftruncate(handle\x2C len = 0) {\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  return binding.ftruncate(handle.fd\x2C len\x2C kUsePromises);\n}\n\nasync function rm(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = await validateRmOptionsPromise(path\x2C options\x2C false);\n  return rimrafPromises(path\x2C options);\n}\n\nasync function rmdir(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = validateRmdirOptions(options);\n\n  if (options.recursive) {\n    emitRecursiveRmdirWarning();\n    const stats = await stat(path);\n    if (stats.isDirectory()) {\n      return rimrafPromises(path\x2C options);\n    }\n  }\n\n  return binding.rmdir(path\x2C kUsePromises);\n}\n\nasync function fdatasync(handle) {\n  return binding.fdatasync(handle.fd\x2C kUsePromises);\n}\n\nasync function fsync(handle) {\n  return binding.fsync(handle.fd\x2C kUsePromises);\n}\n\nasync function mkdir(path\x2C options) {\n  if (typeof options === 'number' || typeof options === 'string') {\n    options = { mode: options };\n  }\n  const {\n    recursive = false\x2C\n    mode = 0o777\n  } = options || {};\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  return binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                       parseFileMode(mode\x2C 'mode'\x2C 0o777)\x2C recursive\x2C\n                       kUsePromises);\n}\n\nasync function readdir(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const result = await binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                       options.encoding\x2C\n                                       !!options.withFileTypes\x2C\n                                       kUsePromises);\n  return options.withFileTypes ?\n    getDirectoryEntriesPromise(path\x2C result) :\n    result;\n}\n\nasync function readlink(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  return binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                          options.encoding\x2C kUsePromises);\n}\n\nasync function symlink(target\x2C path\x2C type_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  return binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                         pathModule.toNamespacedPath(path)\x2C\n                         stringToSymlinkType(type)\x2C\n                         kUsePromises);\n}\n\nasync function fstat(handle\x2C options = { bigint: false }) {\n  const result = await binding.fstat(handle.fd\x2C options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function lstat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                                     options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function stat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.stat(pathModule.toNamespacedPath(path)\x2C\n                                    options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function link(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                      pathModule.toNamespacedPath(newPath)\x2C\n                      kUsePromises);\n}\n\nasync function unlink(path) {\n  path = getValidatedPath(path);\n  return binding.unlink(pathModule.toNamespacedPath(path)\x2C kUsePromises);\n}\n\nasync function fchmod(handle\x2C mode) {\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.fchmod(handle.fd\x2C mode\x2C kUsePromises);\n}\n\nasync function chmod(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C kUsePromises);\n}\n\nasync function lchmod(path\x2C mode) {\n  if (O_SYMLINK === undefined)\n    throw new ERR_METHOD_NOT_IMPLEMENTED('lchmod()');\n\n  const fd = await open(path\x2C O_WRONLY | O_SYMLINK);\n  return SafePromisePrototypeFinally(fchmod(fd\x2C mode)\x2C fd.close);\n}\n\nasync function lchown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.lchown(pathModule.toNamespacedPath(path)\x2C\n                        uid\x2C gid\x2C kUsePromises);\n}\n\nasync function fchown(handle\x2C uid\x2C gid) {\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.fchown(handle.fd\x2C uid\x2C gid\x2C kUsePromises);\n}\n\nasync function chown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.chown(pathModule.toNamespacedPath(path)\x2C\n                       uid\x2C gid\x2C kUsePromises);\n}\n\nasync function utimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                        toUnixTimestamp(atime)\x2C\n                        toUnixTimestamp(mtime)\x2C\n                        kUsePromises);\n}\n\nasync function futimes(handle\x2C atime\x2C mtime) {\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  return binding.futimes(handle.fd\x2C atime\x2C mtime\x2C kUsePromises);\n}\n\nasync function lutimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                         toUnixTimestamp(atime)\x2C\n                         toUnixTimestamp(mtime)\x2C\n                         kUsePromises);\n}\n\nasync function realpath(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  return binding.realpath(path\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function mkdtemp(prefix\x2C options) {\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix);\n  warnOnNonPortableTemplate(prefix);\n  return binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function writeFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data) && !isCustomIterable(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\n  }\n\n  validateAbortSignal(options.signal);\n  if (path instanceof FileHandle)\n    return writeFileHandle(path\x2C data\x2C options.signal\x2C options.encoding);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C options.mode);\n  return SafePromisePrototypeFinally(\n    writeFileHandle(fd\x2C data\x2C options.signal\x2C options.encoding)\x2C fd.close);\n}\n\nfunction isCustomIterable(obj) {\n  return isIterable(obj) && !isArrayBufferView(obj) && typeof obj !== 'string';\n}\n\nasync function appendFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n  options = copyObject(options);\n  options.flag = options.flag || 'a';\n  return writeFile(path\x2C data\x2C options);\n}\n\nasync function readFile(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const flag = options.flag || 'r';\n\n  if (path instanceof FileHandle)\n    return readFileHandle(path\x2C options);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C 0o666);\n  return SafePromisePrototypeFinally(readFileHandle(fd\x2C options)\x2C fd.close);\n}\n\nmodule.exports = {\n  exports: {\n    access\x2C\n    copyFile\x2C\n    cp\x2C\n    open\x2C\n    opendir: promisify(opendir)\x2C\n    rename\x2C\n    truncate\x2C\n    rm\x2C\n    rmdir\x2C\n    mkdir\x2C\n    readdir\x2C\n    readlink\x2C\n    symlink\x2C\n    lstat\x2C\n    stat\x2C\n    link\x2C\n    unlink\x2C\n    chmod\x2C\n    lchmod\x2C\n    lchown\x2C\n    chown\x2C\n    utimes\x2C\n    lutimes\x2C\n    realpath\x2C\n    mkdtemp\x2C\n    writeFile\x2C\n    appendFile\x2C\n    readFile\x2C\n    watch\x2C\n  }\x2C\n\n  FileHandle\x2C\n  kRef\x2C\n  kUnref\x2C\n};\n
code-source-info,0x1eea2dab37a6,109,0,22879,C0O0C4O22879,,
tick,0x10e98ed27,109414,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2dab2492,0x11b703c03,0x11b703885,0x1eea2dab1d7a,0x11b703c03,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
tick,0x7fff203b64ca,109450,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2dab2492,0x11b703c03,0x11b703885,0x1eea2dab1d7a,0x11b703c03,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Function,10,109477,0x1eea2dab5ede,1659, node:internal/fs/promises:1:1,0x1eea2dab3720,~
code-source-info,0x1eea2dab5ede,109,0,22879,C0O0C490O25C496O47C502O56C508O67C514O78C520O101C526O112C532O136C538O154C544O175C550O206C555O216C561O311C565O311C571O339C577O256C583O264C589O277C595O289C601O299C607O360C611O360C615O360C617O402C625O402C631O391C637O550C645O550C651O550C657O445C663O472C669O499C675O534C681O608C689O608C695O586C701O667C709O667C715O648C721O1300C729O1300C735O1300C741O725C747O743C753O759C759O786C765O820C771O851C777O865C783O894C788O908C794O922C800O945C806O965C812O981C818O994C824O1026C830O1043C836O1066C842O1085C848O1108C854O1129C860O1157C866O1186C871O1207C877O1231C883O1269C889O1350C897O1350C903O1338C908O1524C916O1524C922O1388C928O1405C934O1428C940O1447C946O1465C952O1485C958O1504C964O1575C972O1575C976O1575C978O1632C986O1632C992O1600C998O1618C1003O1688C1011O1688C1017O1666C1022O1740C1030O1740C1036O1730C1041O1796C1049O1796C1055O1781C1061O1846C1069O1846C1073O1846C1075O1891C1079O1891C1083O1891C1085O1922C1089O1922C1093O1922C1095O1951C1099O1951C1103O1951C1105O1990C1109O1990C1113O1990C1115O2037C1119O2037C1123O2037C1125O2083C1129O2083C1133O2083C1135O2120C1139O2120C1143O2120C1145O2151C1149O2151C1153O2151C1155O2195C1159O2178C1165O2273C1173O2273C1179O2214C1184O2230C1189O2244C1194O2255C1199O2353C1203O2353C1205O2409C1209O2409C1211O2444C1212O2444C1214O2599C1215O2599C1217O2720C1339O5857C1349O6260C1359O6317C1371O6408C1381O6445C1413O2695C1415O22436C1421O22466C1429O22472C1435O22484C1441O22498C1447O22506C1451O22525C1461O22549C1467O22561C1473O22575C1479O22583C1485O22594C1491O22605C1497O22618C1503O22632C1509O22645C1515O22656C1521O22666C1527O22676C1533O22688C1539O22699C1545O22711C1551O22723C1557O22734C1563O22746C1569O22759C1575O22773C1581O22786C1587O22801C1593O22817C1599O22831C1619O22846C1629O22860C1639O22868C1649O22451C1658O22878,,
code-creation,Function,10,109588,0x1eea2dab6886,27,<instance_members_initializer> node:internal/fs/promises:189:3,0x1eea2dab4d80,~
code-source-info,0x1eea2dab6886,109,4202,5000,C0O4202C12O4210C26O5000,,
code-creation,Eval,10,110042,0x1eea2dab9326,5, node:internal/fs/rimraf:1:1,0x1eea2dab8fc0,~
script-source,110,node:internal/fs/rimraf,// This file is a modified version of the rimraf module on npm. It has been\n// modified in the following ways:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  Promise\x2C\n  SafeSet\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst fs = require('fs');\nconst {\n  chmod\x2C\n  chmodSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  unlink\x2C\n  unlinkSync\n} = fs;\nconst { sep } = require('path');\nconst { setTimeout } = require('timers');\nconst { sleep } = require('internal/util');\nconst notEmptyErrorCodes = new SafeSet(['ENOTEMPTY'\x2C 'EEXIST'\x2C 'EPERM']);\nconst retryErrorCodes = new SafeSet(\n  ['EBUSY'\x2C 'EMFILE'\x2C 'ENFILE'\x2C 'ENOTEMPTY'\x2C 'EPERM']);\nconst isWindows = process.platform === 'win32';\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\nconst readdirEncoding = 'buffer';\nconst separator = Buffer.from(sep);\n\n\nfunction rimraf(path\x2C options\x2C callback) {\n  let retries = 0;\n\n  _rimraf(path\x2C options\x2C function CB(err) {\n    if (err) {\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\n        retries++;\n        const delay = retries * options.retryDelay;\n        return setTimeout(_rimraf\x2C delay\x2C path\x2C options\x2C CB);\n      }\n\n      // The file is already gone.\n      if (err.code === 'ENOENT')\n        err = null;\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rimraf(path\x2C options\x2C callback) {\n  // SunOS lets the root user unlink directories. Use lstat here to make sure\n  // it's not a directory.\n  lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (err.code === 'ENOENT')\n        return callback(null);\n\n      // Windows can EPERM on stat.\n      if (isWindows && err.code === 'EPERM')\n        return fixWinEPERM(path\x2C options\x2C err\x2C callback);\n    } else if (stats.isDirectory()) {\n      return _rmdir(path\x2C options\x2C err\x2C callback);\n    }\n\n    unlink(path\x2C (err) => {\n      if (err) {\n        if (err.code === 'ENOENT')\n          return callback(null);\n        if (err.code === 'EISDIR')\n          return _rmdir(path\x2C options\x2C err\x2C callback);\n        if (err.code === 'EPERM') {\n          return epermHandler(path\x2C options\x2C err\x2C callback);\n        }\n      }\n\n      return callback(err);\n    });\n  });\n}\n\n\nfunction fixWinEPERM(path\x2C options\x2C originalErr\x2C callback) {\n  chmod(path\x2C 0o666\x2C (err) => {\n    if (err)\n      return callback(err.code === 'ENOENT' ? null : originalErr);\n\n    stat(path\x2C (err\x2C stats) => {\n      if (err)\n        return callback(err.code === 'ENOENT' ? null : originalErr);\n\n      if (stats.isDirectory())\n        _rmdir(path\x2C options\x2C originalErr\x2C callback);\n      else\n        unlink(path\x2C callback);\n    });\n  });\n}\n\n\nfunction _rmdir(path\x2C options\x2C originalErr\x2C callback) {\n  rmdir(path\x2C (err) => {\n    if (err) {\n      if (notEmptyErrorCodes.has(err.code))\n        return _rmchildren(path\x2C options\x2C callback);\n      if (err.code === 'ENOTDIR')\n        return callback(originalErr);\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rmchildren(path\x2C options\x2C callback) {\n  const pathBuf = Buffer.from(path);\n\n  readdir(pathBuf\x2C readdirEncoding\x2C (err\x2C files) => {\n    if (err)\n      return callback(err);\n\n    let numFiles = files.length;\n\n    if (numFiles === 0)\n      return rmdir(path\x2C callback);\n\n    let done = false;\n\n    ArrayPrototypeForEach(files\x2C (child) => {\n      const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n      rimraf(childPath\x2C options\x2C (err) => {\n        if (done)\n          return;\n\n        if (err) {\n          done = true;\n          return callback(err);\n        }\n\n        numFiles--;\n        if (numFiles === 0)\n          rmdir(path\x2C callback);\n      });\n    });\n  });\n}\n\n\nfunction rimrafPromises(path\x2C options) {\n  return new Promise((resolve\x2C reject) => {\n    rimraf(path\x2C options\x2C (err) => {\n      if (err)\n        return reject(err);\n\n      resolve();\n    });\n  });\n}\n\n\nfunction rimrafSync(path\x2C options) {\n  let stats;\n\n  try {\n    stats = lstatSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    // Windows can EPERM on stat.\n    if (isWindows && err.code === 'EPERM')\n      fixWinEPERMSync(path\x2C options\x2C err);\n  }\n\n  try {\n    // SunOS lets the root user unlink directories.\n    if (stats?.isDirectory())\n      _rmdirSync(path\x2C options\x2C null);\n    else\n      _unlinkSync(path\x2C options);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'EPERM')\n      return epermHandlerSync(path\x2C options\x2C err);\n    if (err.code !== 'EISDIR')\n      throw err;\n\n    _rmdirSync(path\x2C options\x2C err);\n  }\n}\n\n\nfunction _unlinkSync(path\x2C options) {\n  const tries = options.maxRetries + 1;\n\n  for (let i = 1; i <= tries; i++) {\n    try {\n      return unlinkSync(path);\n    } catch (err) {\n      // Only sleep if this is not the last try\x2C and the delay is greater\n      // than zero\x2C and an error was encountered that warrants a retry.\n      if (retryErrorCodes.has(err.code) &&\n          i < tries &&\n          options.retryDelay > 0) {\n        sleep(i * options.retryDelay);\n      }\n    }\n  }\n}\n\n\nfunction _rmdirSync(path\x2C options\x2C originalErr) {\n  try {\n    rmdirSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'ENOTDIR')\n      throw originalErr;\n\n    if (notEmptyErrorCodes.has(err.code)) {\n      // Removing failed. Try removing all children and then retrying the\n      // original removal. Windows has a habit of not closing handles promptly\n      // when files are deleted\x2C resulting in spurious ENOTEMPTY failures. Work\n      // around that issue by retrying on Windows.\n      const pathBuf = Buffer.from(path);\n\n      ArrayPrototypeForEach(readdirSync(pathBuf\x2C readdirEncoding)\x2C (child) => {\n        const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n        rimrafSync(childPath\x2C options);\n      });\n\n      const tries = options.maxRetries + 1;\n\n      for (let i = 1; i <= tries; i++) {\n        try {\n          return fs.rmdirSync(path);\n        } catch (err) {\n          // Only sleep if this is not the last try\x2C and the delay is greater\n          // than zero\x2C and an error was encountered that warrants a retry.\n          if (retryErrorCodes.has(err.code) &&\n              i < tries &&\n              options.retryDelay > 0) {\n            sleep(i * options.retryDelay);\n          }\n        }\n      }\n    }\n  }\n}\n\n\nfunction fixWinEPERMSync(path\x2C options\x2C originalErr) {\n  try {\n    chmodSync(path\x2C 0o666);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    throw originalErr;\n  }\n\n  let stats;\n\n  try {\n    stats = statSync(path\x2C { throwIfNoEntry: false });\n  } catch {\n    throw originalErr;\n  }\n\n  if (stats === undefined) return;\n\n  if (stats.isDirectory())\n    _rmdirSync(path\x2C options\x2C originalErr);\n  else\n    _unlinkSync(path\x2C options);\n}\n\n\nmodule.exports = { rimraf\x2C rimrafPromises\x2C rimrafSync };\n
code-source-info,0x1eea2dab9326,110,0,7095,C0O0C4O7095,,
code-creation,Function,10,110584,0x1eea2dab9926,409, node:internal/fs/rimraf:1:1,0x1eea2dab92a0,~
code-source-info,0x1eea2dab9926,110,0,7095,C0O0C139O368C145O393C151O404C156O450C159O450C164O439C170O480C173O480C177O480C179O642C182O505C188O514C194O527C200O536C206O549C212O560C218O575C224O584C230O597C236O605C242O617C248O627C254O662C257O662C262O654C267O702C270O702C275O687C281O739C284O739C289O729C295O792C302O792C307O792C309O863C316O863C321O863C323O958C330O967C333O950C335O1001C345O1001C347O1060C357O1060C359O1126C361O1126C363O1154C366O1161C371O1161C376O1154C378O7038C385O7057C391O7065C397O7081C403O7053C408O7094,,
tick,0x7fff203e537c,110650,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2dab61a3,0x11b703c03,0x11b703885,0x1eea2dab2492,0x11b703c03,0x11b703885,0x1eea2dab1d7a,0x11b703c03,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,LazyCompile,10,110817,0x1eea2daba7be,188,from node:buffer:295:28,0x1eea1f7e4b08,~
script-source,18,node:buffer,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  Error\x2C\n  MathFloor\x2C\n  MathMin\x2C\n  MathTrunc\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  SymbolSpecies\x2C\n  SymbolToPrimitive\x2C\n  TypedArrayPrototypeGetByteLength\x2C\n  TypedArrayPrototypeFill\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n  Uint8ArrayPrototype\x2C\n} = primordials;\n\nconst {\n  byteLengthUtf8\x2C\n  compare: _compare\x2C\n  compareOffset\x2C\n  createFromString\x2C\n  fill: bindingFill\x2C\n  indexOfBuffer\x2C\n  indexOfNumber\x2C\n  indexOfString\x2C\n  swap16: _swap16\x2C\n  swap32: _swap32\x2C\n  swap64: _swap64\x2C\n  kMaxLength\x2C\n  kStringMaxLength\n} = internalBinding('buffer');\nconst {\n  getOwnNonIndexProperties\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\x2C\n} = internalBinding('util');\nconst {\n  customInspectSymbol\x2C\n  isInsideNodeModules\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  kIsEncodingSymbol\n} = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\n} = require('internal/util/types');\nconst {\n  inspect: utilInspect\n} = require('internal/util/inspect');\nconst { encodings } = internalBinding('string_decoder');\n\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_BUFFER_SIZE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_ENCODING\n  }\x2C\n  hideStackFrames\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateBuffer\x2C\n  validateNumber\x2C\n  validateInteger\x2C\n  validateString\n} = require('internal/validators');\n// Provide validateInteger() but with kMaxLength as the default maximum value.\nconst validateOffset = (value\x2C name\x2C min = 0\x2C max = kMaxLength) =>\n  validateInteger(value\x2C name\x2C min\x2C max);\n\nconst {\n  FastBuffer\x2C\n  markAsUntransferable\x2C\n  addBufferPrototypeMethods\x2C\n  createUnsafeBuffer\n} = require('internal/buffer');\n\nconst {\n  Blob\x2C\n  resolveObjectURL\x2C\n} = require('internal/blob');\n\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n\nconst constants = ObjectDefineProperties({}\x2C {\n  MAX_LENGTH: {\n    value: kMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\x2C\n  MAX_STRING_LENGTH: {\n    value: kStringMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\n});\n\nBuffer.poolSize = 8 * 1024;\nlet poolSize\x2C poolOffset\x2C allocPool;\n\nconst encodingsMap = ObjectCreate(null);\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\n                      'issues. Please use the Buffer.alloc()\x2C ' +\n                      'Buffer.allocUnsafe()\x2C or Buffer.from() methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted ||\n      ++nodeModulesCheckCounter > 10000 ||\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\n       isInsideNodeModules())) {\n    // We don't emit a warning\x2C because we either:\n    // - Already did so\x2C or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things\x2C or\n    // - We aren't running with `--pending-deprecation` enabled\x2C\n    //   and the code is inside `node_modules`.\n    return;\n  }\n\n  process.emitWarning(bufferWarning\x2C 'DeprecationWarning'\x2C 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\nfunction toInteger(n\x2C defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) &&\n      n >= NumberMIN_SAFE_INTEGER &&\n      n <= NumberMAX_SAFE_INTEGER) {\n    return ((n % 1) === 0 ? n : MathFloor(n));\n  }\n  return defaultVal;\n}\n\nfunction _copy(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE('source'\x2C ['Buffer'\x2C 'Uint8Array']\x2C source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n\n  if (targetStart === undefined) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart\x2C 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE('targetStart'\x2C '>= 0'\x2C targetStart);\n  }\n\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart\x2C 0);\n    if (sourceStart < 0)\n      throw new ERR_OUT_OF_RANGE('sourceStart'\x2C '>= 0'\x2C sourceStart);\n  }\n\n  if (sourceEnd === undefined) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd\x2C 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE('sourceEnd'\x2C '>= 0'\x2C sourceEnd);\n  }\n\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n\n  if (sourceStart > source.length) {\n    throw new ERR_OUT_OF_RANGE('sourceStart'\x2C\n                               `<= ${source.length}`\x2C\n                               sourceStart);\n  }\n\n  return _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n}\n\nfunction _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n\n  let nb = sourceEnd - sourceStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > sourceLen)\n    nb = sourceLen;\n\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer\x2C source.byteOffset + sourceStart\x2C nb);\n\n  TypedArrayPrototypeSet(target\x2C source\x2C targetStart);\n\n  return nb;\n}\n\n/**\n * The Buffer() constructor is deprecated in documentation and should not be\n * used moving forward. Rather\x2C developers should use one of the three new\n * factory APIs: Buffer.from()\x2C Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n */\nfunction Buffer(arg\x2C encodingOrOffset\x2C length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string'\x2C 'string'\x2C arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg\x2C encodingOrOffset\x2C length);\n}\n\nObjectDefineProperty(Buffer\x2C SymbolSpecies\x2C {\n  enumerable: false\x2C\n  configurable: true\x2C\n  get() { return FastBuffer; }\n});\n\n/**\n * Functionally equivalent to Buffer(arg\x2C encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[\x2C encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[\x2C byteOffset[\x2C length]])\n */\nBuffer.from = function from(value\x2C encodingOrOffset\x2C length) {\n  if (typeof value === 'string')\n    return fromString(value\x2C encodingOrOffset);\n\n  if (typeof value === 'object' && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value\x2C encodingOrOffset\x2C length);\n\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null &&\n        valueOf !== value &&\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\n      return from(valueOf\x2C encodingOrOffset\x2C length);\n    }\n\n    const b = fromObject(value);\n    if (b)\n      return b;\n\n    if (typeof value[SymbolToPrimitive] === 'function') {\n      const primitive = value[SymbolToPrimitive]('string');\n      if (typeof primitive === 'string') {\n        return fromString(primitive\x2C encodingOrOffset);\n      }\n    }\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'first argument'\x2C\n    ['string'\x2C 'Buffer'\x2C 'ArrayBuffer'\x2C 'Array'\x2C 'Array-like Object']\x2C\n    value\n  );\n};\n\n// Identical to the built-in %TypedArray%.of()\x2C but avoids using the deprecated\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\n// adding a `prototype` property and making the function a constructor.\n//\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\n\nObjectSetPrototypeOf(Buffer\x2C Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nconst assertSize = hideStackFrames((size) => {\n  validateNumber(size\x2C 'size');\n  if (!(size >= 0 && size <= kMaxLength)) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n});\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[\x2C fill[\x2C encoding]])\n */\nBuffer.alloc = function alloc(size\x2C fill\x2C encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf\x2C fill\x2C 0\x2C buf.length\x2C encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num)\x2C by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num)\x2C by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set\x2C a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\n\nObjectSetPrototypeOf(SlowBuffer.prototype\x2C Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer\x2C Uint8Array);\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\n\nfunction fromStringFast(string\x2C ops) {\n  const length = ops.byteLength(string);\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return createFromString(string\x2C ops.encodingVal);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  let b = new FastBuffer(allocPool\x2C poolOffset\x2C length);\n  const actual = ops.write(b\x2C string\x2C 0\x2C length);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case\x2C though.\n    b = new FastBuffer(allocPool\x2C poolOffset\x2C actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromString(string\x2C encoding) {\n  let ops;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n    encoding = undefined;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string\x2C ops);\n}\n\nfunction fromArrayBuffer(obj\x2C byteOffset\x2C length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj\x2C byteOffset\x2C length);\n}\n\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < (Buffer.poolSize >>> 1)) {\n    if (obj.length > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C obj.length);\n    TypedArrayPrototypeSet(b\x2C obj\x2C 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\n\nfunction fromObject(obj) {\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== 'number') {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\nBuffer.compare = function compare(buf1\x2C buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE('buf1'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf1);\n  }\n\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE('buf2'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf2);\n  }\n\n  if (buf1 === buf2) {\n    return 0;\n  }\n\n  return _compare(buf1\x2C buf2);\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === 'string' && encoding.length !== 0 &&\n         normalizeEncoding(encoding) !== undefined;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\n\nBuffer.concat = function concat(list\x2C length) {\n  validateArray(list\x2C 'list');\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length\x2C 'length');\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\n      // Instead\x2C find the proper error code for this.\n      throw new ERR_INVALID_ARG_TYPE(\n        `list[${i}]`\x2C ['Buffer'\x2C 'Uint8Array']\x2C list[i]);\n    }\n    pos += _copyActual(buf\x2C buffer\x2C pos\x2C 0\x2C buf.length);\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length\x2C i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    TypedArrayPrototypeFill(buffer\x2C 0\x2C pos\x2C length);\n  }\n\n  return buffer;\n};\n\nfunction base64ByteLength(str\x2C bytes) {\n  // Handle padding\n  if (StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\nconst encodingOps = {\n  utf8: {\n    encoding: 'utf8'\x2C\n    encodingVal: encodingsMap.utf8\x2C\n    byteLength: byteLengthUtf8\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.utf8Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.utf8Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf8\x2C dir)\n  }\x2C\n  ucs2: {\n    encoding: 'ucs2'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  utf16le: {\n    encoding: 'utf16le'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  latin1: {\n    encoding: 'latin1'\x2C\n    encodingVal: encodingsMap.latin1\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.latin1Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.latin1Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.latin1\x2C dir)\n  }\x2C\n  ascii: {\n    encoding: 'ascii'\x2C\n    encodingVal: encodingsMap.ascii\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.asciiWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.asciiSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.ascii)\x2C\n                    byteOffset\x2C\n                    encodingsMap.ascii\x2C\n                    dir)\n  }\x2C\n  base64: {\n    encoding: 'base64'\x2C\n    encodingVal: encodingsMap.base64\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.base64Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64\x2C\n                    dir)\n  }\x2C\n  base64url: {\n    encoding: 'base64url'\x2C\n    encodingVal: encodingsMap.base64url\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) =>\n      buf.base64urlWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64urlSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64url)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64url\x2C\n                    dir)\n  }\x2C\n  hex: {\n    encoding: 'hex'\x2C\n    encodingVal: encodingsMap.hex\x2C\n    byteLength: (string) => string.length >>> 1\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.hexWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.hexSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.hex)\x2C\n                    byteOffset\x2C\n                    encodingsMap.hex\x2C\n                    dir)\n  }\n};\nfunction getEncodingOps(encoding) {\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf16le')\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf-16le')\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === 'hex' || StringPrototypeToLowerCase(encoding) === 'hex')\n        return encodingOps.hex;\n      break;\n    case 9:\n      if (encoding === 'base64url' ||\n          StringPrototypeToLowerCase(encoding) === 'base64url')\n        return encodingOps.base64url;\n      break;\n  }\n}\n\nfunction byteLength(string\x2C encoding) {\n  if (typeof string !== 'string') {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new ERR_INVALID_ARG_TYPE(\n      'string'\x2C ['string'\x2C 'Buffer'\x2C 'ArrayBuffer']\x2C string\n    );\n  }\n\n  const len = string.length;\n  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n  if (!mustMatch && len === 0)\n    return 0;\n\n  if (!encoding)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n  return ops.byteLength(string);\n}\n\nBuffer.byteLength = byteLength;\n\n// For backwards compatibility.\nObjectDefineProperty(Buffer.prototype\x2C 'parent'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\n});\nObjectDefineProperty(Buffer.prototype\x2C 'offset'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\n});\n\nBuffer.prototype.copy =\n  function copy(target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n    return _copy(this\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n  };\n\n// No need to verify that "buf.length <= MAX_UINT32" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function toString(encoding\x2C start\x2C end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0\x2C this.length);\n  }\n\n  const len = this.length;\n\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n  else\n    start |= 0;\n\n  if (end === undefined || end > len)\n    end = len;\n  else\n    end |= 0;\n\n  if (end <= start)\n    return '';\n\n  if (encoding === undefined)\n    return this.utf8Slice(start\x2C end);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n\n  return ops.slice(this\x2C start\x2C end);\n};\n\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'otherBuffer'\x2C ['Buffer'\x2C 'Uint8Array']\x2C otherBuffer);\n  }\n\n  if (this === otherBuffer)\n    return true;\n\n  if (this.byteLength !== otherBuffer.byteLength)\n    return false;\n\n  return this.byteLength === 0 || _compare(this\x2C otherBuffer) === 0;\n};\n\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes\x2C ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max\x2C this.length);\n  const remaining = this.length - max;\n  let str = StringPrototypeTrim(StringPrototypeReplace(\n    this.hexSlice(0\x2C actualMax)\x2C /(.{2})/g\x2C '$1 '));\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  // Inspect special properties as well\x2C if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = ObjectCreate(null);\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this\x2C filter)\x2C\n                          (key) => {\n                            extras = true;\n                            obj[key] = this[key];\n                          });\n    if (extras) {\n      if (this.length !== 0)\n        str += '\x2C ';\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += StringPrototypeSlice(utilInspect(obj\x2C {\n        ...ctx\x2C\n        breakLength: Infinity\x2C\n        compact: true\n      })\x2C 27\x2C -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target\x2C\n                                            targetStart\x2C\n                                            targetEnd\x2C\n                                            sourceStart\x2C\n                                            sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n  }\n  if (arguments.length === 1)\n    return _compare(this\x2C target);\n\n  if (targetStart === undefined)\n    targetStart = 0;\n  else\n    validateOffset(targetStart\x2C 'targetStart');\n\n  if (targetEnd === undefined)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd\x2C 'targetEnd'\x2C 0\x2C target.length);\n\n  if (sourceStart === undefined)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart\x2C 'sourceStart');\n\n  if (sourceEnd === undefined)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd\x2C 'sourceEnd'\x2C 0\x2C this.length);\n\n  if (sourceStart >= sourceEnd)\n    return (targetStart >= targetEnd ? 0 : -1);\n  if (targetStart >= targetEnd)\n    return 1;\n\n  return compareOffset(this\x2C target\x2C targetStart\x2C sourceStart\x2C targetEnd\x2C\n                       sourceEnd);\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`\x2C\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string\x2C Buffer\x2C or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding\x2C relevant if val is a string\n// - dir - true for indexOf\x2C false for lastIndexOf\nfunction bidirectionalIndexOf(buffer\x2C val\x2C byteOffset\x2C encoding\x2C dir) {\n  validateBuffer(buffer);\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined\x2C "foo"\x2C {}\x2C coerces to NaN\x2C search whole buffer.\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'number')\n    return indexOfNumber(buffer\x2C val >>> 0\x2C byteOffset\x2C dir);\n\n  let ops;\n  if (encoding === undefined)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n\n  if (typeof val === 'string') {\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer\x2C val\x2C byteOffset\x2C dir);\n  }\n\n  if (isUint8Array(val)) {\n    const encodingVal =\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\n    return indexOfBuffer(buffer\x2C val\x2C byteOffset\x2C encodingVal\x2C dir);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'value'\x2C ['number'\x2C 'string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C val\n  );\n}\n\nBuffer.prototype.indexOf = function indexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C false);\n};\n\nBuffer.prototype.includes = function includes(val\x2C byteOffset\x2C encoding) {\n  return this.indexOf(val\x2C byteOffset\x2C encoding) !== -1;\n};\n\n// Usage:\n//    buffer.fill(number[\x2C offset[\x2C end]])\n//    buffer.fill(buffer[\x2C offset[\x2C end]])\n//    buffer.fill(string[\x2C offset[\x2C end]][\x2C encoding])\nBuffer.prototype.fill = function fill(value\x2C offset\x2C end\x2C encoding) {\n  return _fill(this\x2C value\x2C offset\x2C end\x2C encoding);\n};\n\nfunction _fill(buf\x2C value\x2C offset\x2C end\x2C encoding) {\n  if (typeof value === 'string') {\n    if (offset === undefined || typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buf.length;\n    }\n\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      validateString(encoding\x2C 'encoding');\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (value.length === 0) {\n      // If value === '' default to zero.\n      value = 0;\n    } else if (value.length === 1) {\n      // Fast path: If `value` fits into a single byte\x2C use that numeric value.\n      if (normalizedEncoding === 'utf8') {\n        const code = StringPrototypeCharCodeAt(value\x2C 0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === 'latin1') {\n        value = StringPrototypeCharCodeAt(value\x2C 0);\n      }\n    }\n  } else {\n    encoding = undefined;\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset\x2C 'offset');\n    // Invalid ranges are not set to a default\x2C so can range check early.\n    if (end === undefined) {\n      end = buf.length;\n    } else {\n      validateOffset(end\x2C 'end'\x2C 0\x2C buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n\n\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArrayPrototypeFill(buf\x2C value\x2C offset\x2C end);\n  } else {\n    const res = bindingFill(buf\x2C value\x2C offset\x2C end\x2C encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value'\x2C value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n\n  return buf;\n}\n\nBuffer.prototype.write = function write(string\x2C offset\x2C length\x2C encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string\x2C 0\x2C this.length);\n  }\n  // Buffer#write(string\x2C encoding)\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string\x2C offset[\x2C length][\x2C encoding])\n  } else {\n    validateOffset(offset\x2C 'offset'\x2C 0\x2C this.length);\n\n    const remaining = this.length - offset;\n\n    if (length === undefined) {\n      length = remaining;\n    } else if (typeof length === 'string') {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length\x2C 'length'\x2C 0\x2C this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n\n  if (!encoding)\n    return this.utf8Write(string\x2C offset\x2C length);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this\x2C string\x2C offset\x2C length);\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer'\x2C data };\n  }\n  return { type: 'Buffer'\x2C data: [] };\n};\n\nfunction adjustOffset(offset\x2C length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence\x2C don't use offset | 0 or similar techniques.\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\n\nBuffer.prototype.slice = function slice(start\x2C end) {\n  const srcLength = this.length;\n  start = adjustOffset(start\x2C srcLength);\n  end = end !== undefined ? adjustOffset(end\x2C srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer\x2C this.byteOffset + start\x2C newLength);\n};\n\nfunction swap(b\x2C n\x2C m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this\x2C i\x2C i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this\x2C i\x2C i + 3);\n      swap(this\x2C i + 1\x2C i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this\x2C i\x2C i + 7);\n      swap(this\x2C i + 1\x2C i + 6);\n      swap(this\x2C i + 2\x2C i + 5);\n      swap(this\x2C i + 3\x2C i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nlet transcode;\nif (internalBinding('config').hasIntl) {\n  const {\n    icuErrName\x2C\n    transcode: _transcode\n  } = internalBinding('icu');\n\n  // Transcodes the Buffer from one encoding to another\x2C returning a new\n  // Buffer instance.\n  transcode = function transcode(source\x2C fromEncoding\x2C toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE('source'\x2C\n                                     ['Buffer'\x2C 'Uint8Array']\x2C source);\n    }\n    if (source.length === 0) return Buffer.alloc(0);\n\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source\x2C fromEncoding\x2C toEncoding);\n    if (typeof result !== 'number')\n      return result;\n\n    const code = icuErrName(result);\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error(`Unable to transcode Buffer [${code}]`);\n    err.code = code;\n    err.errno = result;\n    throw err;\n  };\n}\n\nfunction btoa(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (input[n].charCodeAt(0) > 0xff)\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  const buf = Buffer.from(input\x2C 'latin1');\n  return buf.toString('base64');\n}\n\nconst kBase64Digits =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction atob(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (!kBase64Digits.includes(input[n]))\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  return Buffer.from(input\x2C 'base64').toString('latin1');\n}\n\nmodule.exports = {\n  Blob\x2C\n  resolveObjectURL\x2C\n  Buffer\x2C\n  SlowBuffer\x2C\n  transcode\x2C\n  // Legacy\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n  btoa\x2C\n  atob\x2C\n};\n\nObjectDefineProperties(module.exports\x2C {\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  INSPECT_MAX_BYTES: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() { return INSPECT_MAX_BYTES; }\x2C\n    set(val) { INSPECT_MAX_BYTES = val; }\n  }\n});\n
code-source-info,0x1eea2daba7be,18,8406,9357,C3O8444C9O8479C12O8486C17O8522C18O8526C28O8581C33O8585C39O8616C51O8623C56O8672C57O8700C63O8717C68O8717C73O8732C78O8771C95O8862C104O8869C109O8909C110O8931C113O8931C118O8954C120O8967C122O8976C123O8982C125O8999C127O8998C134O9060C136O9066C138O9065C145O9084C151O9102C155O9147C158O9154C163O9194C164O9216C182O9222C187O9216,,
tick,0x7fff202f9f9a,113473,0,0x0,3,0x10f0ac650,0x1eea2dab9a99,0x11b703c03,0x11b703885,0x1eea2dab61a3,0x11b703c03,0x11b703885,0x1eea2dab2492,0x11b703c03,0x11b703885,0x1eea2dab1d7a,0x11b703c03,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
tick,0x7fff203e4e78,113505,0,0x0,3,0x10f0ac650,0x1eea2dab9a99,0x11b703c03,0x11b703885,0x1eea2dab61a3,0x11b703c03,0x11b703885,0x1eea2dab2492,0x11b703c03,0x11b703885,0x1eea2dab1d7a,0x11b703c03,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,LazyCompile,10,113521,0x1eea2dabd196,110,fromString node:buffer:431:20,0x1eea1f7e4ef0,~
code-source-info,0x1eea2dabd196,18,12457,12891,C0O12484C2O12491C8O12536C14O12543C19O12567C25O12574C30O12587C35O12594C40O12611C41O12616C46O12634C51O12644C56O12681C59O12687C64O12717C66O12746C73O12752C78O12746C79O12803C85O12810C90O12823C95O12830C100O12847C101O12854C104O12861C109O12889,,
code-creation,LazyCompile,10,113596,0x1eea2dabd34e,177,fromStringFast node:buffer:412:24,0x1eea1f7e4e50,~
code-source-info,0x1eea2dabd34e,18,11913,12436,C0O11950C5O11950C11O11973C14O11995C18O12004C21O11984C26O12016C31O12052C36O12023C41O12065C42O12069C44O12083C49O12094C51O12092C54O12080C59O12111C62O12111C65O12135C72O12150C77O12161C85O12135C91O12203C110O12203C116O12234C118O12245C123O12329C130O12348C135O12359C143O12333C149O12386C156O12400C162O12397C168O12410C171O12410C174O12425C176O12434,,
code-creation,LazyCompile,10,113669,0x1eea2dabd53e,36,FastBuffer node:internal/buffer:958:14,0x1eea1f7f1a18,~
code-source-info,0x1eea2dabd53e,19,26364,26453,C3O26407C7O26441C20O26407C35O26452,,
code-creation,LazyCompile,10,113705,0x1eea2dabd63e,23,write node:buffer:592:12,0x1eea1f7e5260,~
code-source-info,0x1eea2dabd63e,18,16525,16589,C0O16559C17O16559C22O16589,,
tick,0x10ee610f0,114062,0,0x0,0,0x10ede27e0,0x1eea2dabd63e,0x1eea2dabd3bc,0x1eea2dabd1fe,0x1eea2daba7ca,0x1eea2dab9a99,0x11b703c03,0x11b703885,0x1eea2dab61a3,0x11b703c03,0x11b703885,0x1eea2dab2492,0x11b703c03,0x11b703885,0x1eea2dab1d7a,0x11b703c03,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,LazyCompile,10,114149,0x1eea2dabd72e,42,alignPool node:buffer:158:19,0x1eea1f7e4888,~
code-source-info,0x1eea2dabd72e,18,3998,4102,C0O4032C4O4047C9O4060C19O4071C25O4083C34O4093C41O4101,,
code-creation,LazyCompile,10,114317,0x1eea2dabdaee,251,promisify node:internal/util:324:19,0x1eeab58ea3e0,~
script-source,12,node:internal/util,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_NO_CRYPTO\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\x2C\n  uvErrmapGet\x2C\n  overrideStackTrace\x2C\n} = require('internal/errors');\nconst { signals } = internalBinding('constants').os;\nconst {\n  getHiddenValue\x2C\n  setHiddenValue\x2C\n  arrow_message_private_symbol: kArrowMessagePrivateSymbolIndex\x2C\n  decorated_private_symbol: kDecoratedPrivateSymbolIndex\x2C\n  sleep: _sleep\x2C\n  toUSVString: _toUSVString\x2C\n} = internalBinding('util');\nconst { isNativeError } = internalBinding('types');\n\nconst noCrypto = !process.versions.openssl;\n\nconst experimentalWarnings = new SafeSet();\n\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nconst unpairedSurrogateRe =\n  /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5\x2C `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = RegExpPrototypeExec(unpairedSurrogateRe\x2C str);\n  if (!match)\n    return str;\n  return _toUSVString(str\x2C match.index);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  uvBinding ??= internalBinding('uv');\n  return uvBinding;\n}\n\nfunction removeColors(str) {\n  return StringPrototypeReplace(str\x2C colorRegExp\x2C '');\n}\n\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\n\n// Keep a list of deprecation codes that have been warned on so we only warn on\n// each one once.\nconst codesWarned = new SafeSet();\n\nlet validateString;\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set\x2C then it is a no-op.\nfunction deprecate(fn\x2C msg\x2C code) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Lazy-load to avoid a circular dependency.\n  if (validateString === undefined)\n    ({ validateString } = require('internal/validators'));\n\n  if (code !== undefined)\n    validateString(code\x2C 'code');\n\n  let warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== undefined) {\n        if (!codesWarned.has(code)) {\n          process.emitWarning(msg\x2C 'DeprecationWarning'\x2C code\x2C deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg\x2C 'DeprecationWarning'\x2C deprecated);\n      }\n    }\n    if (new.target) {\n      return ReflectConstruct(fn\x2C args\x2C new.target);\n    }\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  ObjectSetPrototypeOf(deprecated\x2C fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype\x2C as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) ||\n      getHiddenValue(err\x2C kDecoratedPrivateSymbolIndex) === true)\n    return;\n\n  const arrow = getHiddenValue(err\x2C kArrowMessagePrivateSymbolIndex);\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    setHiddenValue(err\x2C kDecoratedPrivateSymbolIndex\x2C true);\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\n\n// Return undefined if there is no match.\n// Move the "slow cases" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\n  return slowCases(enc);\n}\n\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === 'UTF8') return 'utf8';\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf8') return 'utf8';\n      if (enc === 'ucs2') return 'utf16le';\n      break;\n    case 3:\n      if (enc === 'hex' || enc === 'HEX' ||\n          `${enc}`.toLowerCase() === 'hex')\n        return 'hex';\n      break;\n    case 5:\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      if (enc === 'UTF-8') return 'utf8';\n      if (enc === 'ASCII') return 'ascii';\n      if (enc === 'UCS-2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf-8') return 'utf8';\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      break;\n    case 6:\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      if (enc === 'BASE64') return 'base64';\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      break;\n    case 7:\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\n          `${enc}`.toLowerCase() === 'utf16le')\n        return 'utf16le';\n      break;\n    case 8:\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\n        `${enc}`.toLowerCase() === 'utf-16le')\n        return 'utf16le';\n      break;\n    case 9:\n      if (enc === 'base64url' || enc === 'BASE64URL' ||\n          `${enc}`.toLowerCase() === 'base64url')\n        return 'base64url';\n      break;\n    default:\n      if (enc === '') return 'utf8';\n  }\n}\n\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature)) return;\n  const msg = `${feature} is an experimental feature. This feature could ` +\n       'change at any time';\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg\x2C 'ExperimentalWarning');\n}\n\nfunction filterDuplicateStrings(items\x2C low) {\n  const map = new SafeMap();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = StringPrototypeToLowerCase(item);\n    if (low) {\n      map.set(key\x2C key);\n    } else {\n      map.set(key\x2C item);\n    }\n  }\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\n}\n\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return ArrayPrototypeSlice(result);\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type\x2C args\x2C new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  ObjectDefineProperties(fn\x2C {\n    name: { value: type.name }\x2C\n    length: { value: type.length }\n  });\n  ObjectSetPrototypeOf(fn\x2C type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\n\nfunction getSystemErrorMap() {\n  return lazyUv().getErrorMap();\n}\n\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nlet validateFunction;\n\nfunction promisify(original) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateFunction === undefined)\n    ({ validateFunction } = require('internal/validators'));\n\n  validateFunction(original\x2C 'original');\n\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn\x2C 'util.promisify.custom');\n\n    return ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n      value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments\x2C e.g. ['bytesRead'\x2C 'buffer'] for fs.read.\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve\x2C reject) => {\n      ArrayPrototypePush(args\x2C (err\x2C ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original\x2C this\x2C args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn\x2C ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n    value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n  });\n  return ObjectDefineProperties(\n    fn\x2C\n    ObjectGetOwnPropertyDescriptors(original)\n  );\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// The built-in Array#join is slower in v8 6.0\nfunction join(output\x2C separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\n\n// As of V8 6.6\x2C depending on the size of the array\x2C this is anywhere\n// between 1.5-10x faster than the two-arg version of Array#splice()\nfunction spliceOne(list\x2C index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\n\nlet getStructuredStack;\n\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    // Use `runInNewContext()` to get something tamper-proof and\n    // side-effect-free. Since this is currently only used for a deprecated API\x2C\n    // the perf implications should be okay.\n    getStructuredStack = runInNewContext(`(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e\x2C (err\x2C trace) => trace);\n        return e.stack;\n      };\n    })()`\x2C { overrideStackTrace }\x2C { filename: 'structured-stack' });\n  }\n\n  const stack = getStructuredStack();\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\\x2C\n      // it's likely from Node.js core.\n      if (!RegExpPrototypeTest(/^\\/|\\\\/\x2C filename))\n        continue;\n      return RegExpPrototypeTest(kNodeModulesRE\x2C filename);\n    }\n  }\n  return false;\n}\n\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    ReflectApply(callback\x2C this\x2C args);\n  };\n}\n\nlet validateUint32;\n\nfunction sleep(msec) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateUint32 === undefined)\n    ({ validateUint32 } = require('internal/validators'));\n\n  validateUint32(msec\x2C 'msec');\n  _sleep(msec);\n}\n\nfunction createDeferredPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res\x2C rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise\x2C resolve\x2C reject };\n}\n\nlet DOMException;\nconst lazyDOMException = hideStackFrames((message\x2C name) => {\n  if (DOMException === undefined)\n    DOMException = internalBinding('messaging').DOMException;\n  return new DOMException(message\x2C name);\n});\n\nfunction structuredClone(value) {\n  const {\n    DefaultSerializer\x2C\n    DefaultDeserializer\x2C\n  } = require('v8');\n  const ser = new DefaultSerializer();\n  ser._getDataCloneError = hideStackFrames((message) =>\n    lazyDOMException(message\x2C 'DataCloneError'));\n  ser.writeValue(value);\n  const serialized = ser.releaseBuffer();\n\n  const des = new DefaultDeserializer(serialized);\n  return des.readValue();\n}\n\nmodule.exports = {\n  assertCrypto\x2C\n  cachedResult\x2C\n  convertToValidSignal\x2C\n  createClassWrapper\x2C\n  createDeferredPromise\x2C\n  decorateErrorStack\x2C\n  deprecate\x2C\n  emitExperimentalWarning\x2C\n  filterDuplicateStrings\x2C\n  getConstructorOf\x2C\n  getSystemErrorMap\x2C\n  getSystemErrorName\x2C\n  isError\x2C\n  isInsideNodeModules\x2C\n  join\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  once\x2C\n  promisify\x2C\n  sleep\x2C\n  spliceOne\x2C\n  structuredClone\x2C\n  toUSVString\x2C\n  removeColors\x2C\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom')\x2C\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation\x2C just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol')\x2C\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\n};\n
code-source-info,0x1eea2dabdaee,12,8845,10349,C0O8845C17O8907C25O8947C33O8971C38O8950C55O9007C68O9007C73O9050C80O9063C82O9062C87O9107C94O9116C96O9115C100O9148C110O9148C115O9200C126O9232C136O9273C143O9207C148O9339C149O9502C156O9511C158O9510C161O9502C163O10066C174O10091C180O10091C185O10066C190O10127C201O10152C211O10191C218O10127C223O10258C234O10301C240O10301C245O10265C250O10347,,
tick,0x7fff203b72be,115354,0,0x0,3,0x10f0ac650,0x1eea2dab638d,0x11b703c03,0x11b703885,0x1eea2dab2492,0x11b703c03,0x11b703885,0x1eea2dab1d7a,0x11b703c03,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
new,MemoryChunk,0x1eea8f600000,262144
code-creation,LazyCompile,10,115985,0x1eea2dabf016,65,EventEmitterMixin node:internal/event_target:827:27,0x1eeac2076258,~
script-source,38,node:internal/event_target,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ReflectApply\x2C\n  SafeArrayIterator\x2C\n  SafeFinalizationRegistry\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SafeWeakSet\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_EVENT_RECURSION\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_INVALID_THIS\x2C\n  }\n} = require('internal/errors');\nconst { validateObject\x2C validateString } = require('internal/validators');\n\nconst { customInspectSymbol } = require('internal/util');\nconst { inspect } = require('util');\n\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\nconst kIsNodeEventTarget = Symbol('kIsNodeEventTarget');\n\nconst EventEmitter = require('events');\nconst {\n  kMaxEventTargetListeners\x2C\n  kMaxEventTargetListenersWarned\x2C\n} = EventEmitter;\n\nconst kEvents = Symbol('kEvents');\nconst kIsBeingDispatched = Symbol('kIsBeingDispatched');\nconst kStop = Symbol('kStop');\nconst kTarget = Symbol('kTarget');\nconst kHandlers = Symbol('khandlers');\nconst kWeakHandler = Symbol('kWeak');\n\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\nconst kCreateEvent = Symbol('kCreateEvent');\nconst kNewListener = Symbol('kNewListener');\nconst kRemoveListener = Symbol('kRemoveListener');\nconst kIsNodeStyleListener = Symbol('kIsNodeStyleListener');\nconst kTrustEvent = Symbol('kTrustEvent');\n\nconst { now } = require('internal/perf/utils');\n\n// TODO(joyeecheung): V8 snapshot does not support instance member\n// initializers for now:\n// https://bugs.chromium.org/p/v8/issues/detail?id=10704\nconst kType = Symbol('type');\nconst kDefaultPrevented = Symbol('defaultPrevented');\nconst kCancelable = Symbol('cancelable');\nconst kTimestamp = Symbol('timestamp');\nconst kBubbles = Symbol('bubbles');\nconst kComposed = Symbol('composed');\nconst kPropagationStopped = Symbol('propagationStopped');\n\nconst isTrustedSet = new SafeWeakSet();\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\n  get isTrusted() {\n    return isTrustedSet.has(this);\n  }\n}\x2C 'isTrusted').get;\n\nfunction isEvent(value) {\n  return typeof value?.[kType] === 'string';\n}\n\nclass Event {\n  constructor(type\x2C options = null) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    validateObject(options\x2C 'options'\x2C {\n      allowArray: true\x2C allowFunction: true\x2C nullable: true\x2C\n    });\n    const { cancelable\x2C bubbles\x2C composed } = { ...options };\n    this[kCancelable] = !!cancelable;\n    this[kBubbles] = !!bubbles;\n    this[kComposed] = !!composed;\n    this[kType] = `${type}`;\n    this[kDefaultPrevented] = false;\n    this[kTimestamp] = now();\n    this[kPropagationStopped] = false;\n    if (options?.[kTrustEvent]) {\n      isTrustedSet.add(this);\n    }\n\n    // isTrusted is special (LegacyUnforgeable)\n    ObjectDefineProperty(this\x2C 'isTrusted'\x2C {\n      get: isTrusted\x2C\n      enumerable: true\x2C\n      configurable: false\n    });\n    this[kTarget] = null;\n    this[kIsBeingDispatched] = false;\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({\n      type: this[kType]\x2C\n      defaultPrevented: this[kDefaultPrevented]\x2C\n      cancelable: this[kCancelable]\x2C\n      timeStamp: this[kTimestamp]\x2C\n    }\x2C opts)}`;\n  }\n\n  stopImmediatePropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kStop] = true;\n  }\n\n  preventDefault() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kDefaultPrevented] = true;\n  }\n\n  get target() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  get currentTarget() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  get srcElement() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  get type() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kType];\n  }\n\n  get cancelable() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kCancelable];\n  }\n\n  get defaultPrevented() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kCancelable] && this[kDefaultPrevented];\n  }\n\n  get timeStamp() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTimestamp];\n  }\n\n\n  // The following are non-op and unused properties/methods from Web API Event.\n  // These are not supported in Node.js and are provided purely for\n  // API completeness.\n\n  composedPath() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? [this[kTarget]] : [];\n  }\n\n  get returnValue() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return !this.defaultPrevented;\n  }\n\n  get bubbles() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kBubbles];\n  }\n\n  get composed() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kComposed];\n  }\n\n  get eventPhase() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\n  }\n\n  get cancelBubble() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kPropagationStopped];\n  }\n\n  set cancelBubble(value) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    if (value) {\n      this.stopPropagation();\n    }\n  }\n\n  stopPropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kPropagationStopped] = true;\n  }\n\n  static NONE = 0;\n  static CAPTURING_PHASE = 1;\n  static AT_TARGET = 2;\n  static BUBBLING_PHASE = 3;\n}\n\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\n\nObjectDefineProperties(\n  Event.prototype\x2C {\n    [SymbolToStringTag]: {\n      writable: false\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: 'Event'\x2C\n    }\x2C\n    stopImmediatePropagation: kEnumerableProperty\x2C\n    preventDefault: kEnumerableProperty\x2C\n    target: kEnumerableProperty\x2C\n    currentTarget: kEnumerableProperty\x2C\n    srcElement: kEnumerableProperty\x2C\n    type: kEnumerableProperty\x2C\n    cancelable: kEnumerableProperty\x2C\n    defaultPrevented: kEnumerableProperty\x2C\n    timeStamp: kEnumerableProperty\x2C\n    composedPath: kEnumerableProperty\x2C\n    returnValue: kEnumerableProperty\x2C\n    bubbles: kEnumerableProperty\x2C\n    composed: kEnumerableProperty\x2C\n    eventPhase: kEnumerableProperty\x2C\n    cancelBubble: kEnumerableProperty\x2C\n    stopPropagation: kEnumerableProperty\x2C\n  });\n\nclass NodeCustomEvent extends Event {\n  constructor(type\x2C options) {\n    super(type\x2C options);\n    if (options?.detail) {\n      this.detail = options.detail;\n    }\n  }\n}\n\n// Weak listener cleanup\n// This has to be lazy for snapshots to work\nlet weakListenersState = null;\n// The resource needs to retain the callback so that it doesn't\n// get garbage collected now that it's weak.\nlet objectToWeakListenerMap = null;\nfunction weakListeners() {\n  weakListenersState ??= new SafeFinalizationRegistry(\n    (listener) => listener.remove()\n  );\n  objectToWeakListenerMap ??= new SafeWeakMap();\n  return { registry: weakListenersState\x2C map: objectToWeakListenerMap };\n}\n\n// The listeners for an EventTarget are maintained as a linked list.\n// Unfortunately\x2C the way EventTarget is defined\x2C listeners are accounted\n// using the tuple [handler\x2Ccapture]\x2C and even if we don't actually make\n// use of capture or bubbling\x2C in order to be spec compliant we have to\n// take on the additional complexity of supporting it. Fortunately\x2C using\n// the linked list makes dispatching faster\x2C even if adding/removing is\n// slower.\nclass Listener {\n  constructor(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n              isNodeStyleListener\x2C weak) {\n    this.next = undefined;\n    if (previous !== undefined)\n      previous.next = this;\n    this.previous = previous;\n    this.listener = listener;\n    // TODO(benjamingr) these 4 can be 'flags' to save 3 slots\n    this.once = once;\n    this.capture = capture;\n    this.passive = passive;\n    this.isNodeStyleListener = isNodeStyleListener;\n    this.removed = false;\n    this.weak = Boolean(weak); // Don't retain the object\n\n    if (this.weak) {\n      this.callback = new SafeWeakRef(listener);\n      weakListeners().registry.register(listener\x2C this\x2C this);\n      // Make the retainer retain the listener in a WeakMap\n      weakListeners().map.set(weak\x2C listener);\n      this.listener = this.callback;\n    } else if (typeof listener === 'function') {\n      this.callback = listener;\n      this.listener = listener;\n    } else {\n      this.callback = FunctionPrototypeBind(listener.handleEvent\x2C listener);\n      this.listener = listener;\n    }\n  }\n\n  same(listener\x2C capture) {\n    const myListener = this.weak ? this.listener.deref() : this.listener;\n    return myListener === listener && this.capture === capture;\n  }\n\n  remove() {\n    if (this.previous !== undefined)\n      this.previous.next = this.next;\n    if (this.next !== undefined)\n      this.next.previous = this.previous;\n    this.removed = true;\n    if (this.weak)\n      weakListeners().registry.unregister(this);\n  }\n}\n\nfunction initEventTarget(self) {\n  self[kEvents] = new SafeMap();\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n  self[kMaxEventTargetListenersWarned] = false;\n}\n\nclass EventTarget {\n  // Used in checking whether an object is an EventTarget. This is a well-known\n  // symbol as EventTarget may be used cross-realm.\n  // Ref: https://github.com/nodejs/node/pull/33661\n  static [kIsEventTarget] = true;\n\n  constructor() {\n    initEventTarget(this);\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive) {\n    if (this[kMaxEventTargetListeners] > 0 &&\n        size > this[kMaxEventTargetListeners] &&\n        !this[kMaxEventTargetListenersWarned]) {\n      this[kMaxEventTargetListenersWarned] = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventTarget memory leak detected. ' +\n                          `${size} ${type} listeners ` +\n                          `added to ${inspect(this\x2C { depth: -1 })}. Use ` +\n                          'events.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.target = this;\n      w.type = type;\n      w.count = size;\n      process.emitWarning(w);\n    }\n  }\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {}\n\n  addEventListener(type\x2C listener\x2C options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n\n    // We validateOptions before the shouldAddListeners check because the spec\n    // requires us to hit getters.\n    const {\n      once\x2C\n      capture\x2C\n      passive\x2C\n      signal\x2C\n      isNodeStyleListener\x2C\n      weak\x2C\n    } = validateEventListenerOptions(options);\n\n    if (!shouldAddListener(listener)) {\n      // The DOM silently allows passing undefined as a second argument\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error(`addEventListener called with ${listener}` +\n                          ' which has no effect.');\n      w.name = 'AddEventListenerArgumentTypeWarning';\n      w.target = this;\n      w.type = type;\n      process.emitWarning(w);\n      return;\n    }\n    type = String(type);\n\n    if (signal) {\n      if (signal.aborted) {\n        return;\n      }\n      // TODO(benjamingr) make this weak somehow? ideally the signal would\n      // not prevent the event target from GC.\n      signal.addEventListener('abort'\x2C () => {\n        this.removeEventListener(type\x2C listener\x2C options);\n      }\x2C { once: true\x2C [kWeakHandler]: this });\n    }\n\n    let root = this[kEvents].get(type);\n\n    if (root === undefined) {\n      root = { size: 1\x2C next: undefined };\n      // This is the first handler in our linked list.\n      new Listener(root\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                   isNodeStyleListener\x2C weak);\n      this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive);\n      this[kEvents].set(type\x2C root);\n      return;\n    }\n\n    let handler = root.next;\n    let previous = root;\n\n    // We have to walk the linked list to see if we have a match\n    while (handler !== undefined && !handler.same(listener\x2C capture)) {\n      previous = handler;\n      handler = handler.next;\n    }\n\n    if (handler !== undefined) { // Duplicate! Ignore\n      return;\n    }\n\n    new Listener(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                 isNodeStyleListener\x2C weak);\n    root.size++;\n    this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive);\n  }\n\n  removeEventListener(type\x2C listener\x2C options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (!shouldAddListener(listener))\n      return;\n\n    type = String(type);\n    const capture = options?.capture === true;\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler.same(listener\x2C capture)) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  dispatchEvent(event) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n\n    if (!(event instanceof Event))\n      throw new ERR_INVALID_ARG_TYPE('event'\x2C 'Event'\x2C event);\n\n    if (event[kIsBeingDispatched])\n      throw new ERR_EVENT_RECURSION(event.type);\n\n    this[kHybridDispatch](event\x2C event.type\x2C event);\n\n    return event.defaultPrevented !== true;\n  }\n\n  [kHybridDispatch](nodeValue\x2C type\x2C event) {\n    const createEvent = () => {\n      if (event === undefined) {\n        event = this[kCreateEvent](nodeValue\x2C type);\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n      }\n      return event;\n    };\n    if (event !== undefined) {\n      event[kTarget] = this;\n      event[kIsBeingDispatched] = true;\n    }\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined) {\n      if (event !== undefined)\n        event[kIsBeingDispatched] = false;\n      return true;\n    }\n\n    let handler = root.next;\n    let next;\n\n    while (handler !== undefined &&\n           (handler.passive || event?.[kStop] !== true)) {\n      // Cache the next item in case this iteration removes the current one\n      next = handler.next;\n\n      if (handler.removed) {\n        // Deal with the case an event is removed while event handlers are\n        // Being processed (removeEventListener called from a listener)\n        handler = next;\n        continue;\n      }\n      if (handler.once) {\n        handler.remove();\n        root.size--;\n        const { listener\x2C capture } = handler;\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n      }\n\n      try {\n        let arg;\n        if (handler.isNodeStyleListener) {\n          arg = nodeValue;\n        } else {\n          arg = createEvent();\n        }\n        const callback = handler.weak ?\n          handler.callback.deref() : handler.callback;\n        let result;\n        if (callback) {\n          result = FunctionPrototypeCall(callback\x2C this\x2C arg);\n          if (!handler.isNodeStyleListener) {\n            arg[kIsBeingDispatched] = false;\n          }\n        }\n        if (result !== undefined && result !== null)\n          addCatch(result);\n      } catch (err) {\n        emitUncaughtException(err);\n      }\n\n      handler = next;\n    }\n\n    if (event !== undefined)\n      event[kIsBeingDispatched] = false;\n  }\n\n  [kCreateEvent](nodeValue\x2C type) {\n    return new NodeCustomEvent(type\x2C { detail: nodeValue });\n  }\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({}\x2C opts)}`;\n  }\n}\n\nObjectDefineProperties(EventTarget.prototype\x2C {\n  addEventListener: kEnumerableProperty\x2C\n  removeEventListener: kEnumerableProperty\x2C\n  dispatchEvent: kEnumerableProperty\x2C\n  [SymbolToStringTag]: {\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'EventTarget'\x2C\n  }\n});\n\nfunction initNodeEventTarget(self) {\n  initEventTarget(self);\n}\n\nclass NodeEventTarget extends EventTarget {\n  static [kIsNodeEventTarget] = true;\n  static defaultMaxListeners = 10;\n\n  constructor() {\n    super();\n    initNodeEventTarget(this);\n  }\n\n  setMaxListeners(n) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    EventEmitter.setMaxListeners(n\x2C this);\n  }\n\n  getMaxListeners() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return this[kMaxEventTargetListeners];\n  }\n\n  eventNames() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return ArrayFrom(this[kEvents].keys());\n  }\n\n  listenerCount(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    const root = this[kEvents].get(String(type));\n    return root !== undefined ? root.size : 0;\n  }\n\n  off(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  removeListener(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  on(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  addListener(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n  emit(type\x2C arg) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    validateString(type\x2C 'type');\n    const hadListeners = this.listenerCount(type) > 0;\n    this[kHybridDispatch](arg\x2C type);\n    return hadListeners;\n  }\n\n  once(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C\n                          { once: true\x2C [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  removeAllListeners(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    if (type !== undefined) {\n      this[kEvents].delete(String(type));\n    } else {\n      this[kEvents].clear();\n    }\n\n    return this;\n  }\n}\n\nObjectDefineProperties(NodeEventTarget.prototype\x2C {\n  setMaxListeners: kEnumerableProperty\x2C\n  getMaxListeners: kEnumerableProperty\x2C\n  eventNames: kEnumerableProperty\x2C\n  listenerCount: kEnumerableProperty\x2C\n  off: kEnumerableProperty\x2C\n  removeListener: kEnumerableProperty\x2C\n  on: kEnumerableProperty\x2C\n  addListener: kEnumerableProperty\x2C\n  once: kEnumerableProperty\x2C\n  emit: kEnumerableProperty\x2C\n  removeAllListeners: kEnumerableProperty\x2C\n});\n\n// EventTarget API\n\nfunction shouldAddListener(listener) {\n  if (typeof listener === 'function' ||\n      typeof listener?.handleEvent === 'function') {\n    return true;\n  }\n\n  if (listener == null)\n    return false;\n\n  throw new ERR_INVALID_ARG_TYPE('listener'\x2C 'EventListener'\x2C listener);\n}\n\nfunction validateEventListenerOptions(options) {\n  if (typeof options === 'boolean')\n    return { capture: options };\n\n  if (options === null)\n    return {};\n  validateObject(options\x2C 'options'\x2C {\n    allowArray: true\x2C allowFunction: true\x2C\n  });\n  return {\n    once: Boolean(options.once)\x2C\n    capture: Boolean(options.capture)\x2C\n    passive: Boolean(options.passive)\x2C\n    signal: options.signal\x2C\n    weak: options[kWeakHandler]\x2C\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\n  };\n}\n\n// Test whether the argument is an event object. This is far from a fool-proof\n// test\x2C for example this input will result in a false positive:\n// > isEventTarget({ constructor: EventTarget })\n// It stands in its current implementation as a compromise.\n// Ref: https://github.com/nodejs/node/pull/33661\nfunction isEventTarget(obj) {\n  return obj?.constructor?.[kIsEventTarget];\n}\n\nfunction isNodeEventTarget(obj) {\n  return obj?.constructor?.[kIsNodeEventTarget];\n}\n\nfunction addCatch(promise) {\n  const then = promise.then;\n  if (typeof then === 'function') {\n    FunctionPrototypeCall(then\x2C promise\x2C undefined\x2C function(err) {\n      // The callback is called with nextTick to avoid a follow-up\n      // rejection from this promise.\n      emitUncaughtException(err);\n    });\n  }\n}\n\nfunction emitUncaughtException(err) {\n  process.nextTick(() => { throw err; });\n}\n\nfunction makeEventHandler(handler) {\n  // Event handlers are dispatched in the order they were first set\n  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598\n  function eventHandler(...args) {\n    if (typeof eventHandler.handler !== 'function') {\n      return;\n    }\n    return ReflectApply(eventHandler.handler\x2C this\x2C args);\n  }\n  eventHandler.handler = handler;\n  return eventHandler;\n}\n\nfunction defineEventHandler(emitter\x2C name) {\n  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes\n  ObjectDefineProperty(emitter\x2C `on${name}`\x2C {\n    get() {\n      return this[kHandlers]?.get(name)?.handler;\n    }\x2C\n    set(value) {\n      if (!this[kHandlers]) {\n        this[kHandlers] = new SafeMap();\n      }\n      let wrappedHandler = this[kHandlers]?.get(name);\n      if (wrappedHandler) {\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size--;\n          const size = this[kEvents].get(name).size;\n          this[kRemoveListener](size\x2C name\x2C wrappedHandler.handler\x2C false);\n        }\n        wrappedHandler.handler = value;\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size++;\n          const size = this[kEvents].get(name).size;\n          this[kNewListener](size\x2C name\x2C value\x2C false\x2C false\x2C false);\n        }\n      } else {\n        wrappedHandler = makeEventHandler(value);\n        this.addEventListener(name\x2C wrappedHandler);\n      }\n      this[kHandlers].set(name\x2C wrappedHandler);\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n}\n\nconst EventEmitterMixin = (Superclass) => {\n  class MixedEventEmitter extends Superclass {\n    constructor(...args) {\n      args = new SafeArrayIterator(args);\n      super(...args);\n      FunctionPrototypeCall(EventEmitter\x2C this);\n    }\n  }\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\n  delete protoProps.constructor;\n  ObjectDefineProperties(MixedEventEmitter.prototype\x2C protoProps);\n  return MixedEventEmitter;\n};\n\nmodule.exports = {\n  Event\x2C\n  EventEmitterMixin\x2C\n  EventTarget\x2C\n  NodeEventTarget\x2C\n  defineEventHandler\x2C\n  initEventTarget\x2C\n  initNodeEventTarget\x2C\n  kCreateEvent\x2C\n  kNewListener\x2C\n  kTrustEvent\x2C\n  kRemoveListener\x2C\n  kEvents\x2C\n  kWeakHandler\x2C\n  isEventTarget\x2C\n};\n
code-source-info,0x1eea2dabf016,38,23423,23845,C0O23475C23O23659C30O23691C33O23704C38O23659C43O23718C47O23751C52O23792C57O23751C62O23818C64O23843,,
tick,0x7fff203e5136,117689,0,0x0,3,0x10f0ac650,0x1eea2dab639f,0x11b703c03,0x11b703885,0x1eea2dab2492,0x11b703c03,0x11b703885,0x1eea2dab1d7a,0x11b703c03,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
tick,0x7fff203e5398,117721,0,0x0,3,0x10f0ac650,0x1eea2dab639f,0x11b703c03,0x11b703885,0x1eea2dab2492,0x11b703c03,0x11b703885,0x1eea2dab1d7a,0x11b703c03,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Eval,10,118669,0x1eea8f603aa6,5, node:internal/modules/esm/translators:1:1,0x1eea8f6035f0,~
script-source,111,node:internal/modules/esm/translators,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  Boolean\x2C\n  JSONParse\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectKeys\x2C\n  PromisePrototypeThen\x2C\n  PromiseReject\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  SyntaxErrorPrototype\x2C\n  globalThis: { WebAssembly }\x2C\n} = primordials;\n\nlet _TYPES = null;\nfunction lazyTypes() {\n  if (_TYPES !== null) return _TYPES;\n  return _TYPES = require('internal/util/types');\n}\n\nconst { readFileSync } = require('fs');\nconst { extname\x2C isAbsolute } = require('path');\nconst {\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst {\n  Module: CJSModule\x2C\n  cjsParseCache\n} = require('internal/modules/cjs/loader');\nconst internalURLModule = require('internal/url');\nconst createDynamicModule = require(\n  'internal/modules/esm/create_dynamic_module');\nconst { fileURLToPath\x2C URL } = require('url');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\n} = require('internal/errors').codes;\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\nconst moduleWrap = internalBinding('module_wrap');\nconst { ModuleWrap } = moduleWrap;\nconst { getOptionValue } = require('internal/options');\nconst experimentalImportMetaResolve =\n    getOptionValue('--experimental-import-meta-resolve');\nconst asyncESM = require('internal/process/esm_loader');\nconst { emitWarningSync } = require('internal/process/warning');\nconst { TextDecoder } = require('internal/encoding');\n\nlet cjsParse;\nasync function initCJSParse() {\n  if (typeof WebAssembly === 'undefined') {\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n  } else {\n    const { parse\x2C init } =\n        require('internal/deps/cjs-module-lexer/dist/lexer');\n    await init();\n    cjsParse = parse;\n  }\n}\n\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\n\nlet DECODER = null;\nfunction assertBufferSource(body\x2C allowString\x2C hookName) {\n  if (allowString && typeof body === 'string') {\n    return;\n  }\n  const { isArrayBufferView\x2C isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n    `${allowString ? 'string\x2C ' : ''}array buffer\x2C or typed array`\x2C\n    hookName\x2C\n    'source'\x2C\n    body\n  );\n}\n\nfunction stringify(body) {\n  if (typeof body === 'string') return body;\n  assertBufferSource(body\x2C false\x2C 'transformSource');\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\n\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === 'file:') {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\n\nasync function importModuleDynamically(specifier\x2C { url }) {\n  return asyncESM.esmLoader.import(specifier\x2C url);\n}\n\nfunction createImportMetaResolve(defaultParentUrl) {\n  return async function resolve(specifier\x2C parentUrl = defaultParentUrl) {\n    return PromisePrototypeThen(\n      asyncESM.esmLoader.resolve(specifier\x2C parentUrl)\x2C\n      ({ url }) => url\x2C\n      (error) => (\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ?\n          error.url : PromiseReject(error))\n    );\n  };\n}\n\nfunction initializeImportMeta(meta\x2C { url }) {\n  // Alphabetical\n  if (experimentalImportMetaResolve)\n    meta.resolve = createImportMetaResolve(url);\n  meta.url = url;\n}\n\n// Strategy for loading a standard JavaScript module.\ntranslators.set('module'\x2C async function moduleStrategy(url\x2C source\x2C isMain) {\n  assertBufferSource(source\x2C true\x2C 'load');\n  source = stringify(source);\n  maybeCacheSourceMap(url\x2C source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n  moduleWrap.callbackMap.set(module\x2C {\n    initializeImportMeta\x2C\n    importModuleDynamically\x2C\n  });\n  return module;\n});\n\n/**\n * @param {Error | any} err\n * @param {string} [content] Content of the file\x2C if known.\n * @param {string} [filename] Useful only if `content` is unknown.\n */\nfunction enrichCJSError(err\x2C content\x2C filename) {\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype &&\n      hasEsmSyntax(content || readFileSync(filename\x2C 'utf-8'))) {\n    // Emit the warning synchronously because we are in the middle of handling\n    // a SyntaxError that will throw and likely terminate the process before an\n    // asynchronous warning would be emitted.\n    emitWarningSync(\n      'To load an ES module\x2C set "type": "module" in the package.json or use ' +\n      'the .mjs extension.'\n    );\n  }\n}\n\n// Strategy for loading a node-style CommonJS module\nconst isWindows = process.platform === 'win32';\nconst winSepRegEx = /\\//g;\ntranslators.set('commonjs'\x2C async function commonjsStrategy(url\x2C source\x2C\n                                                            isMain) {\n  debug(`Translating CJSModule ${url}`);\n\n  let filename = internalURLModule.fileURLToPath(new URL(url));\n  if (isWindows)\n    filename = StringPrototypeReplace(filename\x2C winSepRegEx\x2C '\\\\');\n\n  if (!cjsParse) await initCJSParse();\n  const { module\x2C exportNames } = cjsPreparseModuleExports(filename);\n  const namesWithDefault = exportNames.has('default') ?\n    [...exportNames] : ['default'\x2C ...exportNames];\n\n  return new ModuleWrap(url\x2C undefined\x2C namesWithDefault\x2C function() {\n    debug(`Loading CJSModule ${url}`);\n\n    let exports;\n    if (asyncESM.esmLoader.cjsCache.has(module)) {\n      exports = asyncESM.esmLoader.cjsCache.get(module);\n      asyncESM.esmLoader.cjsCache.delete(module);\n    } else {\n      try {\n        exports = CJSModule._load(filename\x2C undefined\x2C isMain);\n      } catch (err) {\n        enrichCJSError(err\x2C undefined\x2C filename);\n        throw err;\n      }\n    }\n\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports\x2C exportName) ||\n          exportName === 'default')\n        continue;\n      // We might trigger a getter -> dont fail.\n      let value;\n      try {\n        value = exports[exportName];\n      } catch {}\n      this.setExport(exportName\x2C value);\n    }\n    this.setExport('default'\x2C exports);\n  });\n});\n\nfunction cjsPreparseModuleExports(filename) {\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached)\n      return { module\x2C exportNames: cached.exportNames };\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n\n  let source;\n  try {\n    source = readFileSync(filename\x2C 'utf8');\n  } catch {}\n\n  let exports\x2C reexports;\n  try {\n    ({ exports\x2C reexports } = cjsParse(source || ''));\n  } catch {\n    exports = [];\n    reexports = [];\n  }\n\n  const exportNames = new SafeSet(new SafeArrayIterator(exports));\n\n  // Set first for cycles.\n  cjsParseCache.set(module\x2C { source\x2C exportNames\x2C loaded });\n\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n  }\n  ArrayPrototypeForEach(reexports\x2C (reexport) => {\n    let resolved;\n    try {\n      resolved = CJSModule._resolveFilename(reexport\x2C module);\n    } catch {\n      return;\n    }\n    const ext = extname(resolved);\n    if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\n        isAbsolute(resolved)) {\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\n      for (const name of reexportNames)\n        exportNames.add(name);\n    }\n  });\n\n  return { module\x2C exportNames };\n}\n\n// Strategy for loading a node builtin CommonJS module that isn't\n// through normal resolution\ntranslators.set('builtin'\x2C async function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  // Slice 'node:' scheme\n  const id = StringPrototypeSlice(url\x2C 5);\n  const module = loadNativeModule(id\x2C url);\n  if (!StringPrototypeStartsWith(url\x2C 'node:') || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\n\n// Strategy for loading a JSON file\ntranslators.set('json'\x2C async function jsonStrategy(url\x2C source) {\n  emitExperimentalWarning('Importing JSON modules');\n  assertBufferSource(source\x2C true\x2C 'load');\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url\x2C 'file:') ?\n    fileURLToPath(url) : null;\n  let modulePath;\n  let module;\n  if (pathname) {\n    modulePath = isWindows ?\n      StringPrototypeReplace(pathname\x2C winSepRegEx\x2C '\\\\') : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  source = stringify(source);\n  if (pathname) {\n    // A require call could have been called on the same file during loading and\n    // that resolves synchronously. To make sure we always return the identical\n    // export\x2C we have to check again if the module already exists or not.\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  try {\n    const exports = JSONParse(stripBOM(source));\n    module = {\n      exports\x2C\n      loaded: true\n    };\n  } catch (err) {\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\n    // parse error instead of just manipulating the original error message.\n    // That would allow to add further properties and maybe additional\n    // debugging information.\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n  if (pathname) {\n    CJSModule._cache[modulePath] = module;\n  }\n  return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport('default'\x2C module.exports);\n  });\n});\n\n// Strategy for loading a wasm module\ntranslators.set('wasm'\x2C async function(url\x2C source) {\n  emitExperimentalWarning('Importing Web Assembly modules');\n\n  assertBufferSource(source\x2C false\x2C 'load');\n\n  debug(`Translating WASMModule ${url}`);\n\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n\n  const imports =\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled)\x2C\n                        ({ module }) => module);\n  const exports =\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled)\x2C\n                      ({ name }) => name);\n\n  return createDynamicModule(imports\x2C exports\x2C url\x2C (reflect) => {\n    const { exports } = new WebAssembly.Instance(compiled\x2C reflect.imports);\n    for (const expt of ObjectKeys(exports))\n      reflect.exports[expt].set(exports[expt]);\n  }).module;\n});\n
code-source-info,0x1eea8f603aa6,111,0,11226,C0O0C4O11226,,
code-creation,Function,10,119482,0x1eea8f604346,773, node:internal/modules/esm/translators:1:1,0x1eea8f603a20,~
code-source-info,0x1eea8f604346,111,0,11226,C0O0C201O25C207O50C213O71C219O82C225O95C231O119C237O152C243O166C249O190C255O207C261O228C266O239C272O250C278O276C284O300C290O329C301O367C307O413C308O413C310O558C316O558C321O541C327O605C333O605C338O581C344O590C350O682C356O682C361O632C367O648C373O668C379O772C385O772C390O741C396O754C402O838C408O838C412O838C414O891C420O891C424O891C426O980C432O980C437O957C443O972C449O1008C455O1008C460O1041C473O1042C479O1008C481O1122C487O1122C492O1094C498O1226C504O1226C509O1252C514O1158C520O1188C526O1292C532O1292C537O1268C543O1360C546O1360C550O1360C552O1415C555O1400C561O1454C567O1454C572O1435C577O1525C580O1525C584O1525C586O1596C592O1596C596O1596C598O1664C604O1664C609O1644C615O1725C621O1725C626O1709C632O1760C633O1760C635O2084C637O2084C643O2099C645O2119C649O2134C651O2157C655O2190C656O2190C658O3712C671O3712C677O4902C684O4911C687O4894C689O4944C693O4944C695O4963C708O4963C714O7967C727O7967C733O8416C746O8416C752O10364C765O10364C772O11225,,
tick,0x7fff203e52e3,119561,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2dab1d88,0x11b703c03,0x11b703885,0x1eea2daa75ec,0x11b703c03,0x11b703885,0x1eea2daa5d34,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Eval,10,119722,0x1eea8f60595e,5, node:internal/modules/esm/create_dynamic_module:1:1,0x1eea8f605788,~
script-source,112,node:internal/modules/esm/create_dynamic_module,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  JSONStringify\x2C\n  ObjectCreate\x2C\n  SafeSet\x2C\n} = primordials;\n\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\n\nfunction createImport(impt\x2C index) {\n  const imptPath = JSONStringify(impt);\n  return `import * as $import_${index} from ${imptPath};\nimport.meta.imports[${imptPath}] = $import_${index};`;\n}\n\nfunction createExport(expt) {\n  const name = `${expt}`;\n  return `let $${name};\nexport { $${name} as ${name} };\nimport.meta.exports.${name} = {\n  get: () => $${name}\x2C\n  set: (v) => $${name} = v\x2C\n};`;\n}\n\nconst createDynamicModule = (imports\x2C exports\x2C url = ''\x2C evaluate) => {\n  debug('creating ESM facade for %s with exports: %j'\x2C url\x2C exports);\n  const source = `\n${ArrayPrototypeJoin(ArrayPrototypeMap(imports\x2C createImport)\x2C '\\n')}\n${ArrayPrototypeJoin(ArrayPrototypeMap(exports\x2C createExport)\x2C '\\n')}\nimport.meta.done();\n`;\n  const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n  const m = new ModuleWrap(`${url}`\x2C undefined\x2C source\x2C 0\x2C 0);\n\n  const readyfns = new SafeSet();\n  const reflect = {\n    exports: ObjectCreate(null)\x2C\n    onReady: (cb) => { readyfns.add(cb); }\x2C\n  };\n\n  if (imports.length)\n    reflect.imports = ObjectCreate(null);\n\n  callbackMap.set(m\x2C {\n    initializeImportMeta: (meta\x2C wrap) => {\n      meta.exports = reflect.exports;\n      if (reflect.imports)\n        meta.imports = reflect.imports;\n      meta.done = () => {\n        evaluate(reflect);\n        reflect.onReady = (cb) => cb(reflect);\n        for (const fn of readyfns) {\n          readyfns.delete(fn);\n          fn(reflect);\n        }\n      };\n    }\x2C\n  });\n\n  return {\n    module: m\x2C\n    reflect\x2C\n  };\n};\n\nmodule.exports = createDynamicModule;\n
code-source-info,0x1eea8f60595e,112,0,1756,C0O0C4O1756,,
code-creation,Function,10,119884,0x1eea8f605b86,111, node:internal/modules/esm/create_dynamic_module:1:1,0x1eea8f6058d8,~
code-source-info,0x1eea8f605b86,112,0,1756,C0O0C39O25C45O47C51O68C57O85C63O101C69O140C72O140C77O173C90O174C96O140C98O642C103O1718C105O1733C110O1755,,
tick,0x10ebc7296,120195,1,0x10ea6ba00,2,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2daa5d67,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,Eval,10,120695,0x1eea8f606b3e,5, node:internal/vm/module:1:1,0x1eea8f6065f8,~
script-source,113,node:internal/vm/module,'use strict';\n\nconst assert = require('internal/assert');\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeSome\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  ReflectApply\x2C\n  SafeWeakMap\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  TypeError\x2C\n} = primordials;\n\nconst { isContext } = internalBinding('contextify');\nconst {\n  isModuleNamespaceObject\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  getConstructorOf\x2C\n  customInspectSymbol\x2C\n  emitExperimentalWarning\x2C\n} = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_VM_MODULE_ALREADY_LINKED\x2C\n  ERR_VM_MODULE_DIFFERENT_CONTEXT\x2C\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA\x2C\n  ERR_VM_MODULE_LINKING_ERRORED\x2C\n  ERR_VM_MODULE_NOT_MODULE\x2C\n  ERR_VM_MODULE_STATUS\x2C\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateUint32\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst binding = internalBinding('module_wrap');\nconst {\n  ModuleWrap\x2C\n  kUninstantiated\x2C\n  kInstantiating\x2C\n  kInstantiated\x2C\n  kEvaluating\x2C\n  kEvaluated\x2C\n  kErrored\x2C\n} = binding;\n\nconst STATUS_MAP = {\n  [kUninstantiated]: 'unlinked'\x2C\n  [kInstantiating]: 'linking'\x2C\n  [kInstantiated]: 'linked'\x2C\n  [kEvaluating]: 'evaluating'\x2C\n  [kEvaluated]: 'evaluated'\x2C\n  [kErrored]: 'errored'\x2C\n};\n\nlet globalModuleId = 0;\nconst defaultModuleName = 'vm:module';\nconst wrapToModuleMap = new SafeWeakMap();\n\nconst kWrap = Symbol('kWrap');\nconst kContext = Symbol('kContext');\nconst kPerContextModuleId = Symbol('kPerContextModuleId');\nconst kLink = Symbol('kLink');\n\nclass Module {\n  constructor(options) {\n    emitExperimentalWarning('VM Modules');\n\n    if (new.target === Module) {\n      // eslint-disable-next-line no-restricted-syntax\n      throw new TypeError('Module is not a constructor');\n    }\n\n    const {\n      context\x2C\n      sourceText\x2C\n      syntheticExportNames\x2C\n      syntheticEvaluationSteps\x2C\n    } = options;\n\n    if (context !== undefined) {\n      validateObject(context\x2C 'context');\n      if (!isContext(context)) {\n        throw new ERR_INVALID_ARG_TYPE('options.context'\x2C 'vm.Context'\x2C\n                                       context);\n      }\n    }\n\n    let { identifier } = options;\n    if (identifier !== undefined) {\n      validateString(identifier\x2C 'options.identifier');\n    } else if (context === undefined) {\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\n    } else if (context[kPerContextModuleId] !== undefined) {\n      const curId = context[kPerContextModuleId];\n      identifier = `${defaultModuleName}(${curId})`;\n      context[kPerContextModuleId] += 1;\n    } else {\n      identifier = `${defaultModuleName}(0)`;\n      ObjectDefineProperty(context\x2C kPerContextModuleId\x2C {\n        value: 1\x2C\n        writable: true\x2C\n        enumerable: false\x2C\n        configurable: true\x2C\n      });\n    }\n\n    if (sourceText !== undefined) {\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C sourceText\x2C\n                                   options.lineOffset\x2C options.columnOffset\x2C\n                                   options.cachedData);\n\n      binding.callbackMap.set(this[kWrap]\x2C {\n        initializeImportMeta: options.initializeImportMeta\x2C\n        importModuleDynamically: options.importModuleDynamically ?\n          importModuleDynamicallyWrap(options.importModuleDynamically) :\n          undefined\x2C\n      });\n    } else {\n      assert(syntheticEvaluationSteps);\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C\n                                   syntheticExportNames\x2C\n                                   syntheticEvaluationSteps);\n    }\n\n    wrapToModuleMap.set(this[kWrap]\x2C this);\n\n    this[kContext] = context;\n  }\n\n  get identifier() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kWrap].url;\n  }\n\n  get context() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kContext];\n  }\n\n  get namespace() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must not be unlinked or linking');\n    }\n    return this[kWrap].getNamespace();\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return STATUS_MAP[this[kWrap].getStatus()];\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS('must be errored');\n    }\n    return this[kWrap].getError();\n  }\n\n  async link(linker) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateFunction(linker\x2C 'linker');\n    if (this.status === 'linked') {\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\n    }\n    if (this.status !== 'unlinked') {\n      throw new ERR_VM_MODULE_STATUS('must be unlinked');\n    }\n    await this[kLink](linker);\n    this[kWrap].instantiate();\n  }\n\n  async evaluate(options = {}) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n\n    validateObject(options\x2C 'options');\n\n    let timeout = options.timeout;\n    if (timeout === undefined) {\n      timeout = -1;\n    } else {\n      validateUint32(timeout\x2C 'options.timeout'\x2C true);\n    }\n    const { breakOnSigint = false } = options;\n    validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n    const status = this[kWrap].getStatus();\n    if (status !== kInstantiated &&\n        status !== kEvaluated &&\n        status !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\n        'must be one of linked\x2C evaluated\x2C or errored'\n      );\n    }\n    await this[kWrap].evaluate(timeout\x2C breakOnSigint);\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || Module;\n    const o = ObjectCreate({ constructor });\n    o.status = this.status;\n    o.identifier = this.identifier;\n    o.context = this.context;\n\n    ObjectSetPrototypeOf(o\x2C ObjectGetPrototypeOf(this));\n    ObjectDefineProperty(o\x2C SymbolToStringTag\x2C {\n      value: constructor.name\x2C\n      configurable: true\n    });\n\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return inspect(o\x2C { ...options\x2C customInspect: false });\n  }\n}\n\nconst kDependencySpecifiers = Symbol('kDependencySpecifiers');\nconst kNoError = Symbol('kNoError');\n\nclass SourceTextModule extends Module {\n  #error = kNoError;\n  #statusOverride;\n\n  constructor(sourceText\x2C options = {}) {\n    validateString(sourceText\x2C 'sourceText');\n    validateObject(options\x2C 'options');\n\n    const {\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n      context\x2C\n      identifier\x2C\n      cachedData\x2C\n    } = options;\n\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n\n    if (initializeImportMeta !== undefined &&\n        typeof initializeImportMeta !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.initializeImportMeta'\x2C 'function'\x2C initializeImportMeta);\n    }\n\n    if (importModuleDynamically !== undefined &&\n        typeof importModuleDynamically !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.importModuleDynamically'\x2C 'function'\x2C\n        importModuleDynamically);\n    }\n\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n\n    super({\n      sourceText\x2C\n      context\x2C\n      identifier\x2C\n      lineOffset\x2C\n      columnOffset\x2C\n      cachedData\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n    });\n\n    this[kLink] = async (linker) => {\n      this.#statusOverride = 'linking';\n\n      const promises = this[kWrap].link(async (identifier\x2C assert) => {\n        const module = await linker(identifier\x2C this\x2C { assert });\n        if (module[kWrap] === undefined) {\n          throw new ERR_VM_MODULE_NOT_MODULE();\n        }\n        if (module.context !== this.context) {\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\n        }\n        if (module.status === 'errored') {\n          // TODO(devsnek): replace with ERR_VM_MODULE_LINK_FAILURE\n          // and error cause proposal.\n          throw new ERR_VM_MODULE_LINKING_ERRORED();\n        }\n        if (module.status === 'unlinked') {\n          await module[kLink](linker);\n        }\n        return module[kWrap];\n      });\n\n      try {\n        if (promises !== undefined) {\n          await PromiseAll(promises);\n        }\n      } catch (e) {\n        this.#error = e;\n        throw e;\n      } finally {\n        this.#statusOverride = undefined;\n      }\n    };\n\n    this[kDependencySpecifiers] = undefined;\n  }\n\n  get dependencySpecifiers() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kDependencySpecifiers] === undefined) {\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\n    }\n    return this[kDependencySpecifiers];\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return 'errored';\n    }\n    if (this.#statusOverride) {\n      return this.#statusOverride;\n    }\n    return super.status;\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return this.#error;\n    }\n    return super.error;\n  }\n\n  createCachedData() {\n    const { status } = this;\n    if (status === 'evaluating' ||\n        status === 'evaluated' ||\n        status === 'errored') {\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\n    }\n    return this[kWrap].createCachedData();\n  }\n}\n\nclass SyntheticModule extends Module {\n  constructor(exportNames\x2C evaluateCallback\x2C options = {}) {\n    if (!ArrayIsArray(exportNames) ||\n      ArrayPrototypeSome(exportNames\x2C (e) => typeof e !== 'string')) {\n      throw new ERR_INVALID_ARG_TYPE('exportNames'\x2C\n                                     'Array of unique strings'\x2C\n                                     exportNames);\n    } else {\n      ArrayPrototypeForEach(exportNames\x2C (name\x2C i) => {\n        if (ArrayPrototypeIndexOf(exportNames\x2C name\x2C i + 1) !== -1) {\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`\x2C\n                                          name\x2C\n                                          'is duplicated');\n        }\n      });\n    }\n    validateFunction(evaluateCallback\x2C 'evaluateCallback');\n\n    validateObject(options\x2C 'options');\n\n    const { context\x2C identifier } = options;\n\n    super({\n      syntheticExportNames: exportNames\x2C\n      syntheticEvaluationSteps: evaluateCallback\x2C\n      context\x2C\n      identifier\x2C\n    });\n\n    this[kLink] = () => this[kWrap].link(() => {\n      assert.fail('link callback should not be called');\n    });\n  }\n\n  setExport(name\x2C value) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateString(name\x2C 'name');\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must be linked');\n    }\n    this[kWrap].setExport(name\x2C value);\n  }\n}\n\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\n  const importModuleDynamicallyWrapper = async (...args) => {\n    const m = await ReflectApply(importModuleDynamically\x2C this\x2C args);\n    if (isModuleNamespaceObject(m)) {\n      return m;\n    }\n    if (!m || m[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (m.status === 'errored') {\n      throw m.error;\n    }\n    return m.namespace;\n  };\n  return importModuleDynamicallyWrapper;\n}\n\nmodule.exports = {\n  Module\x2C\n  SourceTextModule\x2C\n  SyntheticModule\x2C\n  importModuleDynamicallyWrap\x2C\n  getModuleFromWrap: (wrap) => wrapToModuleMap.get(wrap)\x2C\n};\n
code-source-info,0x1eea8f606b3e,113,0,12310,C0O0C4O12310,,
code-creation,Function,10,121684,0x1eea8f607d9e,872, node:internal/vm/module:1:1,0x1eea8f606ab8,~
code-source-info,0x1eea8f607d9e,113,0,12310,C0O0C156O30C162O30C166O30C168O68C174O84C180O109C186O134C192O156C198O172C204O196C210O220C216O244C222O258C228O274C233O289C238O299C244O320C250O371C253O371C258O357C264O462C270O462C275O412C281O439C287O576C293O576C298O504C304O524C309O547C315O858C321O858C326O884C331O612C337O636C343O661C349O693C355O728C361O771C367O804C373O832C379O1014C385O1014C390O902C396O921C402O941C408O958C414O976C420O994C426O1063C429O1063C433O1063C435O1216C438O1105C444O1119C449O1138C454O1156C460O1173C465O1188C471O1202C477O1245C484O1250C488O1268C495O1283C499O1300C506O1314C510O1330C517O1343C521O1357C528O1374C532O1387C539O1403C543O1414C550O1245C552O1450C553O1450C555O1479C557O1479C559O1516C561O1516C566O1516C568O1550C571O1550C575O1550C577O1584C580O1584C584O1584C586O1632C589O1632C593O1632C595O1677C598O1677C602O1677C660O5923C688O6683C691O6683C695O6683C697O6733C700O6733C704O6733C736O6785C799O10265C827O12150C834O12171C840O12181C846O12201C852O12220C856O12270C866O12165C871O12309,,
code-creation,Function,10,121803,0x1eea8f6082de,30,<instance_members_initializer> node:internal/vm/module:256:3,0x1eea8f607128,~
code-source-info,0x1eea8f6082de,113,6796,6832,C3O6805C29O6832,,
tick,0x7fff203e5158,121905,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2daa5d67,0x11b703c03,0x11b703885,0x1eea2daa1381,0x1eea4787f1e5,0x1eea4787e4b5,0x1eea2da9d194,0x1eea2da848f2,0x1eea4787e23d
code-creation,LazyCompile,10,122120,0x1eea8f6096d6,16,ESMLoader node:internal/modules/esm/loader:52:1,0x1eea2daa6d80,~
code-source-info,0x1eea8f6096d6,102,1392,1392,C0O1392C15O1392,,
code-creation,LazyCompile,10,122191,0x1eea8f60a66e,27,ModuleMap node:internal/modules/esm/module_map:15:14,0x1eea2daa8cd8,~
code-source-info,0x1eea8f60a66e,103,430,447,C3O436C7O442C11O436C26O446,,
code-creation,LazyCompile,10,122250,0x1eea8f60a8ce,13,desc.value node:internal/per_context/primordials:325:32,0x1eeab58c9d90,~
code-source-info,0x1eea8f60a8ce,6,9496,9555,C0O9513C7O9520C12O9543,,
code-creation,LazyCompile,10,122286,0x1eea8f60a9d6,13,SafeIterator node:internal/per_context/primordials:270:16,0x1eeab58c97e0,~
code-source-info,0x1eea8f60a9d6,6,7785,7845,C0O7804C3O7821C7O7819C12O7844,,
code-creation,LazyCompile,10,122322,0x1eea8f60ab0e,13,next node:internal/per_context/primordials:273:9,0x1eeab58c98a8,~
code-source-info,0x1eea8f60ab0e,6,7854,7899,C0O7865C3O7882C8O7872C12O7893,,
code-creation,LazyCompile,10,122623,0x1eea8f60ad8e,152,deprecate node:internal/util:96:19,0x1eeab58e9c68,~
code-source-info,0x1eea8f60ad8e,12,2408,3584,C0O2408C26O2428C31O2440C37O2454C42O2470C44O2480C45O2535C53O2573C61O2595C66O2576C83O2631C87O2659C100O2659C105O2705C106O2705C108O3280C121O3280C126O3320C129O3327C135O3520C141O3546C145O3541C149O3564C151O3582,,
tick,0x10f009d05,122764,0,0x0,2,0x10f0ac650,0x1eea2da9d1a9,0x1eea2da848f2,0x1eea4787e23d
code-creation,LazyCompile,10,122840,0x1eea8f60b4e6,315,Module._initPaths node:internal/modules/cjs/loader:1227:29,0x1eea2daa03b8,~
code-source-info,0x1eea8f60b4e6,99,38372,39328,C0O38395C9O38415C14O38419C22O38433C28O38433C33O38472C42O38492C47O38496C55O38508C61O38508C66O38703C74O38719C77O38724C85O38740C93O38724C103O38762C106O38767C114O38783C125O38767C131O38823C140O38824C143O38829C157O38829C169O38868C173O38887C180O38916C183O38921C191O38921C198O38887C203O38963C210O38992C213O38997C221O38997C228O38963C233O39040C237O39060C244O39094C249O39122C254O39153C257O39158C262O39122C270O39176C273O39094C279O39060C284O39199C286O39211C292O39272C297O39293C302O39313C305O39293C309O39291C314O39327,,
code-creation,Function,11,123026,0x11b703e60,3076,normalizeString node:path:66:25,0x1eeac2067f68,^
code-source-info,0x11b703e60,35,2161,4085,,,
code-creation,Function,11,123052,0x11b704ae0,104,next node:internal/per_context/primordials:273:9,0x1eeab58c98a8,^
code-source-info,0x11b704ae0,6,7854,7899,,,
code-creation,Function,11,123076,0x11b704bc0,252,SafeMap node:internal/per_context/primordials:351:16,0x1eeab58c9e38,^
code-source-info,0x11b704bc0,6,10200,10217,,,
code-creation,Eval,10,123694,0x1eea8f60e78e,5, node:internal/modules/run_main:1:1,0x1eea8f60e588,~
script-source,114,node:internal/modules/run_main,'use strict';\n\nconst {\n  StringPrototypeEndsWith\x2C\n} = primordials;\nconst CJSLoader = require('internal/modules/cjs/loader');\nconst { Module\x2C toRealPath\x2C readPackageScope } = CJSLoader;\nconst { getOptionValue } = require('internal/options');\nconst path = require('path');\n\nfunction resolveMainPath(main) {\n  // Note extension resolution for the main entry point can be deprecated in a\n  // future major.\n  // Module._findPath is monkey-patchable here.\n  let mainPath = Module._findPath(path.resolve(main)\x2C null\x2C true);\n  if (!mainPath)\n    return;\n\n  const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n  if (!preserveSymlinksMain)\n    mainPath = toRealPath(mainPath);\n\n  return mainPath;\n}\n\nfunction shouldUseESMLoader(mainPath) {\n  const userLoader = getOptionValue('--experimental-loader');\n  if (userLoader)\n    return true;\n  const esModuleSpecifierResolution =\n    getOptionValue('--experimental-specifier-resolution');\n  if (esModuleSpecifierResolution === 'node')\n    return true;\n  // Determine the module format of the main\n  if (mainPath && StringPrototypeEndsWith(mainPath\x2C '.mjs'))\n    return true;\n  if (!mainPath || StringPrototypeEndsWith(mainPath\x2C '.cjs'))\n    return false;\n  const pkg = readPackageScope(mainPath);\n  return pkg && pkg.data.type === 'module';\n}\n\nfunction runMainESM(mainPath) {\n  const { loadESM } = require('internal/process/esm_loader');\n  const { pathToFileURL } = require('internal/url');\n\n  handleMainPromise(loadESM((esmLoader) => {\n    const main = path.isAbsolute(mainPath) ?\n      pathToFileURL(mainPath).href :\n      mainPath;\n    return esmLoader.import(main);\n  }));\n}\n\nasync function handleMainPromise(promise) {\n  // Handle a Promise from running code that potentially does Top-Level Await.\n  // In that case\x2C it makes sense to set the exit code to a specific non-zero\n  // value if the main code never finishes running.\n  function handler() {\n    if (process.exitCode === undefined)\n      process.exitCode = 13;\n  }\n  process.on('exit'\x2C handler);\n  try {\n    return await promise;\n  } finally {\n    process.off('exit'\x2C handler);\n  }\n}\n\n// For backwards compatibility\x2C we have to run a bunch of\n// monkey-patchable code that belongs to the CJS loader (exposed by\n// `require('module')`) even when the entry point is ESM.\nfunction executeUserEntryPoint(main = process.argv[1]) {\n  const resolvedMain = resolveMainPath(main);\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\n  if (useESMLoader) {\n    runMainESM(resolvedMain || main);\n  } else {\n    // Module._load is the monkey-patchable CJS module loader.\n    Module._load(main\x2C null\x2C true);\n  }\n}\n\nmodule.exports = {\n  executeUserEntryPoint\x2C\n  handleMainPromise\x2C\n};\n
code-source-info,0x1eea8f60e78e,114,0,2695,C0O0C4O2695,,
code-creation,Function,10,123940,0x1eea8f60ea86,149, node:internal/modules/run_main:1:1,0x1eea8f60e708,~
code-source-info,0x1eea8f60ea86,114,0,2695,C0O0C60O25C66O85C72O85C77O133C83O141C89O153C95O212C101O212C106O193C112O254C118O254C122O254C124O2627C131O2648C137O2673C143O2642C148O2694,,
tick,0x7fff202fa0c8,123976,1,0x10ea6ba00,3,0x10ebf8f80,0x11b703b3b,0x11b703885,0x1eea2da9d1b8,0x1eea2da848f2,0x1eea4787e23d
code-creation,LazyCompile,10,124071,0x1eea8f60f236,154,initializeESMLoader node:internal/bootstrap/pre_execution:432:29,0x1eea2da81b10,~
code-source-info,0x1eea8f60f236,92,13713,14780,C0O13795C6O13795C13O13844C16O13840C21O13838C25O13862C31O13894C32O13901C33O14001C39O14001C44O13917C49O13957C54O14047C60O14047C65O14248C70O14206C74O14318C79O14279C83O14484C91O14488C97O14604C103O14604C108O14553C113O14561C118O14579C123O14650C129O14650C134O14669C136O14679C140O14693C142O14713C146O14737C148O14756C153O14779,,
code-creation,LazyCompile,10,124155,0x1eea8f60f436,5,get hasLoadedAnyUserCJSModule node:internal/modules/cjs/loader:74:32,0x1eea2da9f8a8,~
code-source-info,0x1eea8f60f436,99,2306,2346,C0O2311C4O2344,,
code-creation,LazyCompile,10,124194,0x1eea8f60f4de,21,assert node:internal/assert:11:16,0x1eea1f7d77b8,~
script-source,16,node:internal/assert,'use strict';\n\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\n\nfunction assert(value\x2C message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\n\nassert.fail = fail;\n\nmodule.exports = assert;\n
code-source-info,0x1eea8f60f4de,16,172,307,C0O193C4O242C7O242C11O259C13O265C18O259C20O306,,
code-creation,LazyCompile,10,124274,0x1eea8f60f6de,53,loadPreloadModules node:internal/bootstrap/pre_execution:475:28,0x1eea2da81c00,~
code-source-info,0x1eea8f60f6de,92,15256,15576,C0O15343C8O15343C13O15374C15O15411C21O15418C26O15494C32O15494C37O15494C42O15461C47O15538C52O15575,,
code-creation,LazyCompile,10,124316,0x1eea8f60f8c6,50,initializeFrozenIntrinsics node:internal/bootstrap/pre_execution:467:36,0x1eea2da81bb0,~
code-source-info,0x1eea8f60f8c6,92,15005,15227,C0O15012C8O15016C14O15061C17O15069C28O15069C34O15181C40O15181C45O15218C49O15226,,
code-creation,LazyCompile,10,124370,0x1eea8f60f9ee,80,executeUserEntryPoint node:internal/modules/run_main:74:31,0x1eea8f60e928,~
code-source-info,0x1eea8f60f9ee,114,2320,2625,C7O2336C14O2340C22O2370C25O2370C30O2416C33O2416C38O2452C40O2476C45O2487C50O2476C56O2588C61O2595C73O2595C79O2624,,
code-creation,LazyCompile,10,124417,0x1eea8f60fe3e,68,resolveMainPath node:internal/modules/run_main:11:25,0x1eea8f60e7c0,~
code-source-info,0x1eea8f60fe3e,114,296,710,C0O468C5O475C12O485C15O490C20O490C30O475C36O520C38O539C39O546C40O579C48O579C53O625C55O656C60O667C65O692C67O708,,
code-creation,LazyCompile,10,124558,0x1eea8f610136,436,Module._findPath node:internal/modules/cjs/loader:494:28,0x1eea2da9fbc8,~
code-source-info,0x1eea8f610136,99,14327,16931,C0O14380C5O14385C10O14385C16O14408C18O14435C26O14458C30O14478C36O14485C41O14498C42O14511C43O14536C45O14544C51O14555C57O14555C62O14553C66O14606C69O14613C76O14623C80O14637C82O14652C84O14665C85O14673C87O14709C93O14716C100O14727C103O14770C107O14777C111O14727C119O14790C121O14782C125O14812C127O14838C134O14874C137O14854C143O14943C145O14956C149O14948C154O15041C156O15046C160O15055C165O15070C172O15084C177O15089C179O15104C183O15158C186O15158C192O15198C194O15227C196O15250C197O15279C202O15284C207O15284C214O15319C216O15345C219O15345C224O15365C228O15393C229O15400C234O15427C238O15452C244O15488C249O15504C254O15504C262O15554C265O15565C272O15614C278O16228C283O16244C288O16244C296O16290C299O16301C304O16348C308O16419C312O16453C320O16478C325O16460C330O16500C342O16511C348O16569C354O16589C359O16674C363O16706C371O16731C376O16713C381O16751C396O16762C402O16818C406O16840C409O16847C416O16868C420O16886C422O16902C423O14965C428O14930C434O16916C435O16929,,
code-creation,LazyCompile,10,124642,0x1eea8f6104e6,45,isAbsolute node:path:1156:13,0x1eeac20684f0,~
code-source-info,0x1eea8f6104e6,35,35448,35594,C0O35461C8O35461C13O35507C19O35514C26O35532C31O35532C39O35571C41O35567C44O35590,,
tick,0x10f46b5c0,124844,0,0x0,0,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
tick,0x10f07a310,125903,0,0x0,0,0x10f0c4b60,0x10f4b124e,0x1eea8f6101bf,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
code-creation,LazyCompile,10,126792,0x1eea8f6106ee,85,stat node:internal/modules/cjs/loader:151:14,0x1eea2da9f168,~
code-source-info,0x1eea8f6106ee,99,4627,5024,C0O4642C5O4658C10O4658C17O4688C23O4733C28O4743C33O4743C39O4762C41O4788C43O4802C44O4824C49O4824C54O4856C61O4889C66O4969C71O4979C76O4979C82O5008C84O5022,,
code-creation,LazyCompile,10,126851,0x1eea8f61082e,3,toNamespacedPath node:path:1266:19,0x1eeac20685e0,~
code-source-info,0x1eea8f61082e,35,38609,38669,C0O38653C2O38665,,
tick,0x10ea2a190,127166,1,0x10ea2a190,6,0x10ebf8f80,0x1eea8f61071f,0x1eea8f610211,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
code-creation,LazyCompile,10,127280,0x1eea8f61091e,42,toRealPath node:internal/modules/cjs/loader:393:20,0x1eea2da9f438,~
code-source-info,0x1eea8f61091e,99,11292,11404,C0O11310C5O11320C10O11333C17O11353C20O11364C28O11383C35O11320C41O11402,,
code-creation,LazyCompile,10,127573,0x1eea8f610d4e,1036,realpathSync node:fs:2408:22,0x1eeaaa6615b0,~
script-source,77,node:fs,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers\x2C keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\n// When using FSReqCallback\x2C make sure to create the object only *after* all\n// parameter validation has happened\x2C so that the objects are not kept in memory\n// in case they are created but never used due to an exception.\n\nconst {\n  ArrayPrototypePush\x2C\n  BigIntPrototypeToString\x2C\n  MathMax\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  S_IFIFO\x2C\n  S_IFLNK\x2C\n  S_IFMT\x2C\n  S_IFREG\x2C\n  S_IFSOCK\x2C\n  F_OK\x2C\n  R_OK\x2C\n  W_OK\x2C\n  X_OK\x2C\n  O_WRONLY\x2C\n  O_SYMLINK\n} = constants;\n\nconst pathModule = require('path');\nconst { isArrayBufferView } = require('internal/util/types');\n\n// We need to get the statValues from the binding at the callsite since\n// it's re-initialized after deserialization.\n\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\x2C\n  }\x2C\n  AbortError\x2C\n  uvErrmapGet\x2C\n  uvException\n} = require('internal/errors');\n\nconst { FSReqCallback } = binding;\nconst { toPathIfFileURL } = require('internal/url');\nconst internalUtil = require('internal/util');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n  }\x2C\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  Stats\x2C\n  getStatsFromBinding\x2C\n  realpathCacheKey\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n} = require('internal/fs/utils');\nconst {\n  Dir\x2C\n  opendir\x2C\n  opendirSync\n} = require('internal/fs/dir');\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n} = require('internal/constants');\nconst {\n  isUint32\x2C\n  parseFileMode\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateCallback\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst watchers = require('internal/fs/watchers');\nconst ReadFileContext = require('internal/fs/read_file_context');\n\nlet truncateWarn = true;\nlet fs;\n\n// Lazy loaded\nlet cpFn;\nlet cpSyncFn;\nlet promises = null;\nlet ReadStream;\nlet WriteStream;\nlet rimraf;\nlet rimrafSync;\n\n// These have to be separate because of how graceful-fs happens to do it's\n// monkeypatching.\nlet FileReadStream;\nlet FileWriteStream;\n\nconst isWindows = process.platform === 'win32';\nconst isOSX = process.platform === 'darwin';\n\n\nfunction showTruncateDeprecation() {\n  if (truncateWarn) {\n    process.emitWarning(\n      'Using fs.truncate with a file descriptor is deprecated. Please use ' +\n      'fs.ftruncate with a file descriptor instead.'\x2C\n      'DeprecationWarning'\x2C 'DEP0081');\n    truncateWarn = false;\n  }\n}\n\nfunction maybeCallback(cb) {\n  validateCallback(cb);\n\n  return cb;\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer\x2C callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  validateCallback(cb);\n\n  return (...args) => ReflectApply(cb\x2C this\x2C args);\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization\x2C since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  validateCallback(cb);\n\n  return (err\x2C stats) => {\n    if (err) return cb(err);\n    cb(err\x2C getStatsFromBinding(stats));\n  };\n}\n\nconst isFd = isUint32;\n\nfunction isFileType(stats\x2C fileType) {\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  let mode = stats[1];\n  if (typeof mode === 'bigint')\n    mode = Number(mode);\n  return (mode & S_IFMT) === fileType;\n}\n\n/**\n * Tests a user's permissions for the file or directory\n * specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction access(path\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = F_OK;\n  }\n\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously tests a user's permissions for the file or\n * directory specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @returns {void | never}\n */\nfunction accessSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n\n  const ctx = { path };\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @param {(exists?: boolean) => any} callback\n * @returns {void}\n */\nfunction exists(path\x2C callback) {\n  maybeCallback(callback);\n\n  function suppressedCallback(err) {\n    callback(err ? false : true);\n  }\n\n  try {\n    fs.access(path\x2C F_OK\x2C suppressedCallback);\n  } catch {\n    return callback(false);\n  }\n}\n\nObjectDefineProperty(exists\x2C internalUtil.promisify.custom\x2C {\n  value: (path) => {\n    return new Promise((resolve) => fs.exists(path\x2C resolve));\n  }\n});\n\n// fs.existsSync never throws\x2C it only returns true or false.\n// Since fs.existsSync never throws\x2C users have established\n// the expectation that passing invalid arguments to it\x2C even like\n// fs.existsSync()\x2C would only get a false in return\x2C so we cannot signal\n// validation errors to users properly out of compatibility concerns.\n// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n/**\n * Synchronously tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @returns {boolean}\n */\nfunction existsSync(path) {\n  try {\n    path = getValidatedPath(path);\n  } catch {\n    return false;\n  }\n  const ctx = { path };\n  const nPath = pathModule.toNamespacedPath(path);\n  binding.access(nPath\x2C F_OK\x2C undefined\x2C ctx);\n\n  // In case of an invalid symlink\x2C `binding.access()` on win32\n  // will **not** return an error and is therefore not enough.\n  // Double check with `binding.stat()`.\n  if (isWindows && ctx.errno === undefined) {\n    binding.stat(nPath\x2C false\x2C undefined\x2C ctx);\n  }\n\n  return ctx.errno === undefined;\n}\n\nfunction readFileAfterOpen(err\x2C fd) {\n  const context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  const req = new FSReqCallback();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd\x2C false\x2C req);\n}\n\nfunction readFileAfterStat(err\x2C stats) {\n  const context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  const size = context.size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n\n  if (size > kIoMaxLength) {\n    err = new ERR_FS_FILE_TOO_LARGE(size);\n    return context.close(err);\n  }\n\n  try {\n    if (size === 0) {\n      context.buffers = [];\n    } else {\n      context.buffer = Buffer.allocUnsafeSlow(size);\n    }\n  } catch (err) {\n    return context.close(err);\n  }\n  context.read();\n}\n\nfunction checkAborted(signal\x2C callback) {\n  if (signal?.aborted) {\n    callback(new AbortError());\n    return true;\n  }\n  return false;\n}\n\n/**\n * Asynchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   data?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readFile(path\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { flag: 'r' });\n  const context = new ReadFileContext(callback\x2C options.encoding);\n  context.isUserFd = isFd(path); // File descriptor ownership\n\n  if (options.signal) {\n    context.signal = options.signal;\n  }\n  if (context.isUserFd) {\n    process.nextTick(function tick(context) {\n      ReflectApply(readFileAfterOpen\x2C { context }\x2C [null\x2C path]);\n    }\x2C context);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  const flagsNumber = stringToFlags(options.flag\x2C 'options.flag');\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               0o666\x2C\n               req);\n}\n\nfunction tryStatSync(fd\x2C isUserFd) {\n  const ctx = {};\n  const stats = binding.fstat(fd\x2C false\x2C undefined\x2C ctx);\n  if (ctx.errno !== undefined && !isUserFd) {\n    fs.closeSync(fd);\n    throw uvException(ctx);\n  }\n  return stats;\n}\n\nfunction tryCreateBuffer(size\x2C fd\x2C isUserFd) {\n  let threw = true;\n  let buffer;\n  try {\n    if (size > kIoMaxLength) {\n      throw new ERR_FS_FILE_TOO_LARGE(size);\n    }\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C len) {\n  let threw = true;\n  let bytesRead;\n  try {\n    bytesRead = fs.readSync(fd\x2C buffer\x2C pos\x2C len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\n/**\n * Synchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   }} [options]\n * @returns {string | Buffer}\n */\nfunction readFileSync(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C options.flag\x2C 0o666);\n\n  const stats = tryStatSync(fd\x2C isUserFd);\n  const size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n  let pos = 0;\n  let buffer; // Single buffer with file data\n  let buffers; // List for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size\x2C fd\x2C isUserFd);\n  }\n\n  let bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // The kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C 0\x2C 8192);\n      if (bytesRead !== 0) {\n        ArrayPrototypePush(buffers\x2C buffer.slice(0\x2C bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // Data was collected into the buffers list.\n    buffer = Buffer.concat(buffers\x2C pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0\x2C pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n}\n\nfunction defaultCloseCallback(err) {\n  if (err != null) throw err;\n}\n\n/**\n * Closes the file descriptor.\n * @param {number} fd\n * @param {(err?: Error) => any} [callback]\n * @returns {void}\n */\nfunction close(fd\x2C callback = defaultCloseCallback) {\n  fd = getValidatedFd(fd);\n  if (callback !== defaultCloseCallback)\n    callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.close(fd\x2C req);\n}\n\n/**\n * Synchronously closes the file descriptor.\n * @param {number} fd\n * @returns {void}\n */\nfunction closeSync(fd) {\n  fd = getValidatedFd(fd);\n\n  const ctx = {};\n  binding.close(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @param {(\n *   err?: Error\x2C\n *   fd?: number\n *   ) => any} callback\n * @returns {void}\n */\nfunction open(path\x2C flags\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  if (arguments.length < 3) {\n    callback = flags;\n    flags = 'r';\n    mode = 0o666;\n  } else if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0o666;\n  } else {\n    mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  }\n  const flagsNumber = stringToFlags(flags);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               mode\x2C\n               req);\n}\n\n/**\n * Synchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @returns {number}\n */\nfunction openSync(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n\n  const ctx = { path };\n  const result = binding.open(pathModule.toNamespacedPath(path)\x2C\n                              flagsNumber\x2C mode\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {number} offset\n * @param {number} length\n * @param {number | bigint} position\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffer?: Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\n  fd = getValidatedFd(fd);\n\n  if (arguments.length <= 3) {\n    // Assume fs.read(fd\x2C options\x2C callback)\n    let options = {};\n    if (arguments.length < 3) {\n      // This is fs.read(fd\x2C callback)\n      // buffer will be the callback\n      callback = buffer;\n    } else {\n      // This is fs.read(fd\x2C {}\x2C callback)\n      // buffer will be the options object\n      // offset is the callback\n      options = buffer;\n      callback = offset;\n    }\n\n    ({\n      buffer = Buffer.alloc(16384)\x2C\n      offset = 0\x2C\n      length = buffer.byteLength\x2C\n      position\n    } = options);\n  }\n\n  validateBuffer(buffer);\n  callback = maybeCallback(callback);\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return process.nextTick(function tick() {\n      callback(null\x2C 0\x2C buffer);\n    });\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  function wrapper(err\x2C bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C bytesRead || 0\x2C buffer);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n}\n\nObjectDefineProperty(read\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesRead'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously reads the file from the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | bigint;\n *   }} [offset]\n * @returns {number}\n */\nfunction readSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n\n  validateBuffer(buffer);\n\n  if (arguments.length <= 3) {\n    // Assume fs.read(fd\x2C buffer\x2C options)\n    const options = offset || {};\n\n    ({ offset = 0\x2C length = buffer.byteLength\x2C position } = options);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return 0;\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  const ctx = {};\n  const result = binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor)\n * and writes to an array of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffers?: ArrayBufferView[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readv(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C read) {\n    callback(err\x2C read || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.readBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(readv\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesRead'\x2C 'buffers']\x2C enumerable: false });\n\n/**\n * Synchronously reads file from the\n * specified `fd` (file descriptor) and writes to an array\n * of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @returns {number}\n */\nfunction readvSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.readBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes `buffer` to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | Object} buffer\n * @param {number} [offset]\n * @param {number} [length]\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number;\n *   buffer?: Buffer | TypedArray | DataView\n *   ) => any} callback\n * @returns {void}\n */\nfunction write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C written || 0\x2C buffer);\n  }\n\n  fd = getValidatedFd(fd);\n\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n    if (offset == null || typeof offset === 'function') {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n\n    const req = new FSReqCallback();\n    req.oncomplete = wrapper;\n    return binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n\n  const str = String(buffer);\n  validateEncoding(str\x2C length);\n  callback = maybeCallback(position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  return binding.writeString(fd\x2C str\x2C offset\x2C length\x2C req);\n}\n\nObjectDefineProperty(write\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesWritten'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously writes `buffer` to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | Object} buffer\n * @param {number} [offset]\n * @param {number} [length]\n * @param {number} [position]\n * @returns {number}\n */\nfunction writeSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  let result;\n  if (isArrayBufferView(buffer)) {\n    if (position === undefined)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    result = binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                                 undefined\x2C ctx);\n  } else {\n    validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n    validateEncoding(buffer\x2C length);\n\n    if (offset === undefined)\n      offset = null;\n    result = binding.writeString(fd\x2C buffer\x2C offset\x2C length\x2C\n                                 undefined\x2C ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes an array of `ArrayBufferView`s to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number\x2C\n *   buffers?: ArrayBufferView[]\n *   ) => any} callback\n * @returns {void}\n */\nfunction writev(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    callback(err\x2C written || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.writeBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(writev\x2C internalUtil.customPromisifyArgs\x2C {\n  value: ['bytesWritten'\x2C 'buffer']\x2C\n  enumerable: false\n});\n\n/**\n * Synchronously writes an array of `ArrayBufferView`s\n * to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @returns {number}\n */\nfunction writevSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.writeBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rename(oldPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C\n                 req);\n}\n\n\n/**\n * Synchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction renameSync(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const ctx = { path: oldPath\x2C dest: newPath };\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction truncate(path\x2C len\x2C callback) {\n  if (typeof path === 'number') {\n    showTruncateDeprecation();\n    return fs.ftruncate(path\x2C len\x2C callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = maybeCallback(callback);\n  fs.open(path\x2C 'r+'\x2C (er\x2C fd) => {\n    if (er) return callback(er);\n    const req = new FSReqCallback();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd\x2C (er2) => {\n        callback(aggregateTwoErrors(er2\x2C er));\n      });\n    };\n    binding.ftruncate(fd\x2C len\x2C req);\n  });\n}\n\n/**\n * Synchronously truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @returns {void}\n */\nfunction truncateSync(path\x2C len) {\n  if (typeof path === 'number') {\n    // legacy\n    showTruncateDeprecation();\n    return fs.ftruncateSync(path\x2C len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // Allow error to be thrown\x2C but still close fd.\n  const fd = fs.openSync(path\x2C 'r+');\n  let ret;\n\n  try {\n    ret = fs.ftruncateSync(fd\x2C len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction ftruncate(fd\x2C len = 0\x2C callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  }\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.ftruncate(fd\x2C len\x2C req);\n}\n\n/**\n * Synchronously truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @returns {void}\n */\nfunction ftruncateSync(fd\x2C len = 0) {\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  const ctx = {};\n  binding.ftruncate(fd\x2C len\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lazyLoadCp() {\n  if (cpFn === undefined) {\n    ({ cpFn } = require('internal/fs/cp/cp'));\n    cpFn = require('util').callbackify(cpFn);\n    ({ cpSyncFn } = require('internal/fs/cp/cp-sync'));\n  }\n}\n\nfunction lazyLoadRimraf() {\n  if (rimraf === undefined)\n    ({ rimraf\x2C rimrafSync } = require('internal/fs/rimraf'));\n}\n\n/**\n * Asynchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rmdir(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  callback = makeCallback(callback);\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    validateRmOptions(\n      path\x2C\n      { ...options\x2C force: false }\x2C\n      true\x2C\n      (err\x2C options) => {\n        if (err === false) {\n          const req = new FSReqCallback();\n          req.oncomplete = callback;\n          return binding.rmdir(path\x2C req);\n        }\n        if (err) {\n          return callback(err);\n        }\n\n        lazyLoadRimraf();\n        rimraf(path\x2C options\x2C callback);\n      });\n  } else {\n    validateRmdirOptions(options);\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    return binding.rmdir(path\x2C req);\n  }\n}\n\n/**\n * Synchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmdirSync(path\x2C options) {\n  path = getValidatedPath(path);\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    options = validateRmOptionsSync(path\x2C { ...options\x2C force: false }\x2C true);\n    if (options !== false) {\n      lazyLoadRimraf();\n      return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n    }\n  } else {\n    validateRmdirOptions(options);\n  }\n\n  const ctx = { path };\n  binding.rmdir(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  return handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rm(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  validateRmOptions(path\x2C options\x2C false\x2C (err\x2C options) => {\n    if (err) {\n      return callback(err);\n    }\n    lazyLoadRimraf();\n    return rimraf(pathModule.toNamespacedPath(path)\x2C options\x2C callback);\n  });\n}\n\n/**\n * Synchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmSync(path\x2C options) {\n  options = validateRmOptionsSync(path\x2C options\x2C false);\n\n  lazyLoadRimraf();\n  return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n}\n\n/**\n * Forces all currently queued I/O operations associated\n * with the file to the operating system's synchronized\n * I/O completion state.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fdatasync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd\x2C req);\n}\n\n/**\n * Synchronously forces all currently queued I/O operations\n * associated with the file to the operating\n * system's synchronized I/O completion state.\n * @param {number} fd\n * @returns {void}\n */\nfunction fdatasyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fdatasync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Requests for all data for the open file descriptor\n * to be flushed to the storage device.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fsync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd\x2C req);\n}\n\n/**\n * Synchronously requests for all data for the open\n * file descriptor to be flushed to the storage device.\n * @param {number} fd\n * @returns {void}\n */\nfunction fsyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fsync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction mkdir(path\x2C options\x2C callback) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                parseFileMode(mode\x2C 'mode')\x2C recursive\x2C req);\n}\n\n/**\n * Synchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @returns {string | void}\n */\nfunction mkdirSync(path\x2C options) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const ctx = { path };\n  const result = binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                               parseFileMode(mode\x2C 'mode')\x2C recursive\x2C\n                               undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  if (recursive) {\n    return result;\n  }\n}\n\n/**\n * Reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @param {(\n *   err?: Error\x2C\n *   files?: string[] | Buffer[] | Direct[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readdir(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  if (!options.withFileTypes) {\n    req.oncomplete = callback;\n  } else {\n    req.oncomplete = (err\x2C result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      getDirents(path\x2C result\x2C callback);\n    };\n  }\n  binding.readdir(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C\n                  !!options.withFileTypes\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @returns {string | Buffer[] | Dirent[]}\n */\nfunction readdirSync(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                 options.encoding\x2C !!options.withFileTypes\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return options.withFileTypes ? getDirents(path\x2C result) : result;\n}\n\n/**\n * Invokes the callback with the `fs.Stats`\n * for the file descriptor.\n * @param {number} fd\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction fstat(fd\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  fd = getValidatedFd(fd);\n  callback = makeStatsCallback(callback);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.fstat(fd\x2C options.bigint\x2C req);\n}\n\n/**\n * Retrieves the `fs.Stats` for the symbolic link\n * referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction lstat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.lstat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\n/**\n * Asynchronously gets the stats of a file.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction stat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\nfunction hasNoEntryError(ctx) {\n  if (ctx.errno) {\n    const uvErr = uvErrmapGet(ctx.errno);\n    return uvErr?.[0] === 'ENOENT';\n  }\n\n  if (ctx.error) {\n    return ctx.error.code === 'ENOENT';\n  }\n\n  return false;\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the file descriptor.\n * @param {number} fd\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction fstatSync(fd\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  fd = getValidatedFd(fd);\n  const ctx = { fd };\n  const stats = binding.fstat(fd\x2C options.bigint\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the symbolic link referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction lstatSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                              options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats`\n * for the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction statSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.stat(pathModule.toNamespacedPath(path)\x2C\n                             options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   linkString?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readlink(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.readlink(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @returns {string | Buffer}\n */\nfunction readlinkSync(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  const ctx = { path };\n  const result = binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                                  options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Creates the link called `path` pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string} [type_]\n * @param {(err?: Error) => any} callback_\n * @returns {void}\n */\nfunction symlink(target\x2C path\x2C type_\x2C callback_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  const callback = makeCallback(arguments[arguments.length - 1]);\n\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n\n  if (isWindows && type === null) {\n    let absoluteTarget;\n    try {\n      // Symlinks targets can be relative to the newly created path.\n      // Calculate absolute file name of the symlink target\x2C and check\n      // if it is a directory. Ignore resolve error to keep symlink\n      // errors consistent between platforms if invalid path is\n      // provided.\n      absoluteTarget = pathModule.resolve(path\x2C '..'\x2C target);\n    } catch { }\n    if (absoluteTarget !== undefined) {\n      stat(absoluteTarget\x2C (err\x2C stat) => {\n        const resolvedType = !err && stat.isDirectory() ? 'dir' : 'file';\n        const resolvedFlags = stringToSymlinkType(resolvedType);\n        const destination = preprocessSymlinkDestination(target\x2C\n                                                         resolvedType\x2C\n                                                         path);\n\n        const req = new FSReqCallback();\n        req.oncomplete = callback;\n        binding.symlink(destination\x2C\n                        pathModule.toNamespacedPath(path)\x2C resolvedFlags\x2C req);\n      });\n      return;\n    }\n  }\n\n  const destination = preprocessSymlinkDestination(target\x2C type\x2C path);\n\n  const flags = stringToSymlinkType(type);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.symlink(destination\x2C pathModule.toNamespacedPath(path)\x2C flags\x2C req);\n}\n\n/**\n * Synchronously creates the link called `path`\n * pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string} [type]\n * @returns {void}\n */\nfunction symlinkSync(target\x2C path\x2C type) {\n  type = (typeof type === 'string' ? type : null);\n  if (isWindows && type === null) {\n    const absoluteTarget = pathModule.resolve(`${path}`\x2C '..'\x2C `${target}`);\n    if (statSync(absoluteTarget\x2C { throwIfNoEntry: false })?.isDirectory()) {\n      type = 'dir';\n    }\n  }\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  const flags = stringToSymlinkType(type);\n\n  const ctx = { path: target\x2C dest: path };\n  binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                  pathModule.toNamespacedPath(path)\x2C flags\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction link(existingPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n               pathModule.toNamespacedPath(newPath)\x2C\n               req);\n}\n\n/**\n * Synchronously creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction linkSync(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const ctx = { path: existingPath\x2C dest: newPath };\n  const result = binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                              pathModule.toNamespacedPath(newPath)\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction unlink(path\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C req);\n}\n\n/**\n * Synchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @returns {void}\n */\nfunction unlinkSync(path) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchmod(fd\x2C mode\x2C callback) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchmod(fd\x2C mode\x2C req);\n}\n\n/**\n * Synchronously sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @returns {void}\n */\nfunction fchmodSync(fd\x2C mode) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  const ctx = {};\n  binding.fchmod(fd\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchmod(path\x2C mode\x2C callback) {\n  callback = maybeCallback(callback);\n  mode = parseFileMode(mode\x2C 'mode');\n  fs.open(path\x2C O_WRONLY | O_SYMLINK\x2C (err\x2C fd) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    // Prefer to return the chmod error\x2C if one occurs\x2C\n    // but still try to close\x2C and report closing errors if they occur.\n    fs.fchmod(fd\x2C mode\x2C (err) => {\n      fs.close(fd\x2C (err2) => {\n        callback(aggregateTwoErrors(err2\x2C err));\n      });\n    });\n  });\n}\n\n/**\n * Synchronously changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @returns {void}\n */\nfunction lchmodSync(path\x2C mode) {\n  const fd = fs.openSync(path\x2C O_WRONLY | O_SYMLINK);\n\n  // Prefer to return the chmod error\x2C if one occurs\x2C\n  // but still try to close\x2C and report closing errors if they occur.\n  let ret;\n  try {\n    ret = fs.fchmodSync(fd\x2C mode);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Asynchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chmod(path\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @returns {void}\n */\nfunction chmodSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n\n  const ctx = { path };\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction lchownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchown(fd\x2C uid\x2C gid\x2C callback) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchown(fd\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction fchownSync(fd\x2C uid\x2C gid) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const ctx = {};\n  binding.fchown(fd\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction chownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction utimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C\n                 toUnixTimestamp(mtime)\x2C\n                 req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction utimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C toUnixTimestamp(mtime)\x2C\n                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by the supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction futimes(fd\x2C atime\x2C mtime\x2C callback) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.futimes(fd\x2C atime\x2C mtime\x2C req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by the\n * supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction futimesSync(fd\x2C atime\x2C mtime) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  const ctx = {};\n  binding.futimes(fd\x2C atime\x2C mtime\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the access and modification times of\n * a file in the same way as `fs.utimes()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lutimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  req);\n}\n\n/**\n * Synchronously changes the access and modification\n * times of a file in the same way as `fs.utimesSync()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction lutimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback) {\n  if (signal?.aborted) {\n    const abortError = new AbortError();\n    if (isUserFd) {\n      callback(abortError);\n    } else {\n      fs.close(fd\x2C (err) => {\n        callback(aggregateTwoErrors(err\x2C abortError));\n      });\n    }\n    return;\n  }\n  // write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback)\n  fs.write(fd\x2C buffer\x2C offset\x2C length\x2C null\x2C (writeErr\x2C written) => {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd\x2C (err) => {\n          callback(aggregateTwoErrors(err\x2C writeErr));\n        });\n      }\n    } else if (written === length) {\n      if (isUserFd) {\n        callback(null);\n      } else {\n        fs.close(fd\x2C callback);\n      }\n    } else {\n      offset += written;\n      length -= written;\n      writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Asynchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | Object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction writeFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  if (isFd(path)) {\n    const isUserFd = true;\n    const signal = options.signal;\n    writeAll(path\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  fs.open(path\x2C flag\x2C options.mode\x2C (openErr\x2C fd) => {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      const isUserFd = false;\n      const signal = options.signal;\n      writeAll(fd\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Synchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | Object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction writeFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  const flag = options.flag || 'w';\n\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C flag\x2C options.mode);\n\n  let offset = 0;\n  let length = data.byteLength;\n  try {\n    while (length > 0) {\n      const written = fs.writeSync(fd\x2C data\x2C offset\x2C length);\n      offset += written;\n      length -= written;\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n}\n\n/**\n * Asynchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction appendFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path\x2C data\x2C options\x2C callback);\n}\n\n/**\n * Synchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction appendFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path\x2C data\x2C options);\n}\n\n/**\n * Watches for the changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {string | {\n *   persistent?: boolean;\n *   recursive?: boolean;\n *   encoding?: string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   eventType?: string\x2C\n *   filename?: string | Buffer\n *   ) => any} [listener]\n * @returns {watchers.FSWatcher}\n */\nfunction watch(filename\x2C options\x2C listener) {\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options\x2C {});\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n  if (options.recursive && !(isOSX || isWindows))\n    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');\n  const watcher = new watchers.FSWatcher();\n  watcher[watchers.kFSWatchStart](filename\x2C\n                                  options.persistent\x2C\n                                  options.recursive\x2C\n                                  options.encoding);\n\n  if (listener) {\n    watcher.addListener('change'\x2C listener);\n  }\n  if (options.signal) {\n    if (options.signal.aborted) {\n      process.nextTick(() => watcher.close());\n    } else {\n      const listener = () => watcher.close();\n      options.signal.addEventListener('abort'\x2C listener);\n      watcher.once('close'\x2C () => {\n        options.signal.removeEventListener('abort'\x2C listener);\n      });\n    }\n  }\n\n  return watcher;\n}\n\n\nconst statWatchers = new SafeMap();\n\n/**\n * Watches for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {{\n *   bigint?: boolean;\n *   persistent?: boolean;\n *   interval?: number;\n *   }} [options]\n * @param {(\n *   current?: Stats\x2C\n *   previous?: Stats\n *   ) => any} listener\n * @returns {watchers.StatWatcher}\n */\nfunction watchFile(filename\x2C options\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  let stat;\n\n  if (options === null || typeof options !== 'object') {\n    listener = options;\n    options = null;\n  }\n\n  options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007\x2C\n    persistent: true\x2C\n    ...options\n  };\n\n  validateFunction(listener\x2C 'listener');\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    stat = new watchers.StatWatcher(options.bigint);\n    stat[watchers.kFSStatWatcherStart](filename\x2C\n                                       options.persistent\x2C options.interval);\n    statWatchers.set(filename\x2C stat);\n  } else {\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('add');\n  }\n\n  stat.addListener('change'\x2C listener);\n  return stat;\n}\n\n/**\n * Stops watching for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {() => any} [listener]\n * @returns {void}\n */\nfunction unwatchFile(filename\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  const stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    const beforeListenerCount = stat.listenerCount('change');\n    stat.removeListener('change'\x2C listener);\n    if (stat.listenerCount('change') < beforeListenerCount)\n      stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');\n  } else {\n    stat.removeAllListeners('change');\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n}\n\n\nlet splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\')\x2C including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return RegExpPrototypeExec(splitRootRe\x2C str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (StringPrototypeCharCodeAt(str\x2C i) !== CHAR_FORWARD_SLASH)\n        return StringPrototypeSlice(str\x2C 0\x2C i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result\x2C options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  }\n  return asBuffer.toString(options.encoding);\n}\n\n// Finds the next portion of a (partial) path\x2C up to the next path delimiter\nlet nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p\x2C i) {\n    for (; i < p.length; ++i) {\n      const ch = StringPrototypeCharCodeAt(p\x2C i);\n\n      // Check for a separator character\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p\x2C i) {\n    return StringPrototypeIndexOf(p\x2C '/'\x2C i);\n  };\n}\n\nconst emptyObj = ObjectCreate(null);\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string | null; }} [options]\n * @returns {string | Buffer}\n */\nfunction realpathSync(p\x2C options) {\n  options = getOptions(options\x2C emptyObj);\n  p = toPathIfFileURL(p);\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[realpathCacheKey];\n  const maybeCachedResult = cache?.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n  const original = p;\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows) {\n    const ctx = { path: base };\n    binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n    handleErrorFromBinding(ctx);\n    knownHard[base] = true;\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard[base] || cache?.get(base) === base) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        break;\n      }\n      continue;\n    }\n\n    let resolvedLink;\n    const maybeCachedResolved = cache?.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      const baseLong = pathModule.toNamespacedPath(base);\n      const ctx = { path: base };\n      const stats = binding.lstat(baseLong\x2C true\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n\n      if (!isFileType(stats\x2C S_IFLNK)) {\n        knownHard[base] = true;\n        cache?.set(base\x2C base);\n        continue;\n      }\n\n      // Read the link if it wasn't read before\n      // dev/ino always return 0 on windows\x2C so skip the check.\n      let linkTarget = null;\n      let id;\n      if (!isWindows) {\n        const dev = BigIntPrototypeToString(stats[0]\x2C 32);\n        const ino = BigIntPrototypeToString(stats[7]\x2C 32);\n        id = `${dev}:${ino}`;\n        if (seenLinks[id]) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        const ctx = { path: base };\n        binding.stat(baseLong\x2C false\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n        linkTarget = binding.readlink(baseLong\x2C undefined\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n      }\n      resolvedLink = pathModule.resolve(previous\x2C linkTarget);\n\n      if (cache) cache.set(base\x2C resolvedLink);\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      const ctx = { path: base };\n      binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n      knownHard[base] = true;\n    }\n  }\n\n  cache?.set(original\x2C p);\n  return encodeRealpathResult(p\x2C options);\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @returns {string | Buffer}\n */\nrealpathSync.native = (path\x2C options) => {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.realpath(path\x2C options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n};\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction realpath(p\x2C options\x2C callback) {\n  callback = typeof options === 'function' ? options : maybeCallback(callback);\n  options = getOptions(options\x2C {});\n  p = toPathIfFileURL(p);\n\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    fs.lstat(base\x2C (err\x2C stats) => {\n      if (err) return callback(err);\n      knownHard[base] = true;\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  function LOOP() {\n    // Stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null\x2C encodeRealpathResult(p\x2C options));\n    }\n\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard[base]) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        return callback(null\x2C encodeRealpathResult(p\x2C options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base\x2C { bigint: true }\x2C gotStat);\n  }\n\n  function gotStat(err\x2C stats) {\n    if (err) return callback(err);\n\n    // If not a symlink\x2C skip to the next path part\n    if (!stats.isSymbolicLink()) {\n      knownHard[base] = true;\n      return process.nextTick(LOOP);\n    }\n\n    // Stat & read the link if not read before.\n    // Call `gotTarget()` as soon as the link target is known.\n    // `dev`/`ino` always return 0 on windows\x2C so skip the check.\n    let id;\n    if (!isWindows) {\n      const dev = BigIntPrototypeToString(stats.dev\x2C 32);\n      const ino = BigIntPrototypeToString(stats.ino\x2C 32);\n      id = `${dev}:${ino}`;\n      if (seenLinks[id]) {\n        return gotTarget(null\x2C seenLinks[id]);\n      }\n    }\n    fs.stat(base\x2C (err) => {\n      if (err) return callback(err);\n\n      fs.readlink(base\x2C (err\x2C target) => {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err\x2C target);\n      });\n    });\n  }\n\n  function gotTarget(err\x2C target) {\n    if (err) return callback(err);\n\n    gotResolvedLink(pathModule.resolve(previous\x2C target));\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base\x2C (err) => {\n        if (err) return callback(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n}\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nrealpath.native = (path\x2C options\x2C callback) => {\n  callback = makeCallback(callback || options);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  return binding.realpath(path\x2C options.encoding\x2C req);\n};\n\n/**\n * Creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   directory?: string\n *   ) => any} callback\n * @returns {void}\n */\nfunction mkdtemp(prefix\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @returns {string}\n */\nfunction mkdtempSync(prefix\x2C options) {\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const path = `${prefix}XXXXXX`;\n  const ctx = { path };\n  const result = binding.mkdtemp(path\x2C options.encoding\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction copyFile(src\x2C dest\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0;\n  }\n\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.copyFile(src\x2C dest\x2C mode\x2C req);\n}\n\n/**\n * Synchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @returns {void}\n */\nfunction copyFileSync(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  const ctx = { path: src\x2C dest };  // non-prefixed\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  binding.copyFile(src\x2C dest\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {Object} [options]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction cp(src\x2C dest\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  callback = makeCallback(callback);\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpFn(src\x2C dest\x2C options\x2C callback);\n}\n\n/**\n * Synchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {Object} [options]\n * @returns {void}\n */\nfunction cpSync(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpSyncFn(src\x2C dest\x2C options);\n}\n\nfunction lazyLoadStreams() {\n  if (!ReadStream) {\n    ({ ReadStream\x2C WriteStream } = require('internal/fs/streams'));\n    FileReadStream = ReadStream;\n    FileWriteStream = WriteStream;\n  }\n}\n\n/**\n * Creates a readable stream with a default `highWaterMark`\n * of 64 kb.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   end?: number;\n *   highWaterMark?: number;\n *   fs?: Object | null;\n *   }} [options]\n * @returns {ReadStream}\n */\nfunction createReadStream(path\x2C options) {\n  lazyLoadStreams();\n  return new ReadStream(path\x2C options);\n}\n\n/**\n * Creates a write stream.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   fs?: Object | null;\n *   }} [options]\n * @returns {WriteStream}\n */\nfunction createWriteStream(path\x2C options) {\n  lazyLoadStreams();\n  return new WriteStream(path\x2C options);\n}\n\nmodule.exports = fs = {\n  appendFile\x2C\n  appendFileSync\x2C\n  access\x2C\n  accessSync\x2C\n  chown\x2C\n  chownSync\x2C\n  chmod\x2C\n  chmodSync\x2C\n  close\x2C\n  closeSync\x2C\n  copyFile\x2C\n  copyFileSync\x2C\n  cp\x2C\n  cpSync\x2C\n  createReadStream\x2C\n  createWriteStream\x2C\n  exists\x2C\n  existsSync\x2C\n  fchown\x2C\n  fchownSync\x2C\n  fchmod\x2C\n  fchmodSync\x2C\n  fdatasync\x2C\n  fdatasyncSync\x2C\n  fstat\x2C\n  fstatSync\x2C\n  fsync\x2C\n  fsyncSync\x2C\n  ftruncate\x2C\n  ftruncateSync\x2C\n  futimes\x2C\n  futimesSync\x2C\n  lchown\x2C\n  lchownSync\x2C\n  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined\x2C\n  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined\x2C\n  link\x2C\n  linkSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  lutimes\x2C\n  lutimesSync\x2C\n  mkdir\x2C\n  mkdirSync\x2C\n  mkdtemp\x2C\n  mkdtempSync\x2C\n  open\x2C\n  openSync\x2C\n  opendir\x2C\n  opendirSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  read\x2C\n  readSync\x2C\n  readv\x2C\n  readvSync\x2C\n  readFile\x2C\n  readFileSync\x2C\n  readlink\x2C\n  readlinkSync\x2C\n  realpath\x2C\n  realpathSync\x2C\n  rename\x2C\n  renameSync\x2C\n  rm\x2C\n  rmSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  symlink\x2C\n  symlinkSync\x2C\n  truncate\x2C\n  truncateSync\x2C\n  unwatchFile\x2C\n  unlink\x2C\n  unlinkSync\x2C\n  utimes\x2C\n  utimesSync\x2C\n  watch\x2C\n  watchFile\x2C\n  writeFile\x2C\n  writeFileSync\x2C\n  write\x2C\n  writeSync\x2C\n  writev\x2C\n  writevSync\x2C\n  Dir\x2C\n  Dirent\x2C\n  Stats\x2C\n\n  get ReadStream() {\n    lazyLoadStreams();\n    return ReadStream;\n  }\x2C\n\n  set ReadStream(val) {\n    ReadStream = val;\n  }\x2C\n\n  get WriteStream() {\n    lazyLoadStreams();\n    return WriteStream;\n  }\x2C\n\n  set WriteStream(val) {\n    WriteStream = val;\n  }\x2C\n\n  // Legacy names... these have to be separate because of how graceful-fs\n  // (and possibly other) modules monkey patch the values.\n  get FileReadStream() {\n    lazyLoadStreams();\n    return FileReadStream;\n  }\x2C\n\n  set FileReadStream(val) {\n    FileReadStream = val;\n  }\x2C\n\n  get FileWriteStream() {\n    lazyLoadStreams();\n    return FileWriteStream;\n  }\x2C\n\n  set FileWriteStream(val) {\n    FileWriteStream = val;\n  }\x2C\n\n  // For tests\n  _toUnixTimestamp: toUnixTimestamp\n};\n\nObjectDefineProperties(fs\x2C {\n  F_OK: { enumerable: true\x2C value: F_OK || 0 }\x2C\n  R_OK: { enumerable: true\x2C value: R_OK || 0 }\x2C\n  W_OK: { enumerable: true\x2C value: W_OK || 0 }\x2C\n  X_OK: { enumerable: true\x2C value: X_OK || 0 }\x2C\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  promises: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      if (promises === null)\n        promises = require('internal/fs/promises').exports;\n      return promises;\n    }\n  }\n});\n
code-source-info,0x1eea8f610d4e,77,63994,67905,C0O64011C8O64041C12O64021C19O64054C25O64058C31O64080C35O64113C45O64128C51O64128C55O64147C61O64162C67O64162C74O64191C76O64199C78O64198C82O64246C86O64251C92O64253C101O64263C103O64292C105O64317C106O64343C115O64343C120O64383C129O64383C134O64422C137O64469C139O64544C141O64639C143O64715C145O64749C151O64766C157O64796C162O64878C168O64911C176O64919C183O64931C189O64939C197O64945C201O64956C207O64956C223O64939C228O65008C234O65008C238O65041C239O65057C243O65197C247O65193C252O65252C258O65252C264O65274C267O65298C269O65309C274O65338C280O65338C287O65374C289O65385C296O65397C298O65413C302O65435C309O65462C311O65473C317O65509C328O65473C340O65521C342O65539C355O65539C360O65537C364O65583C366O65596C370O65669C372O65682C384O65697C390O65699C402O65709C407O65727C413O65742C417O65750C425O65762C429O65731C442O65795C446O65803C454O65815C458O65784C465O65836C467O65857C469O65882C471O65928C478O65933C484O65935C493O65950C495O65983C502O66165C508O66176C514O66176C520O66218C528O66226C535O66254C541O66262C559O66262C565O66307C571O66307C575O66343C581O66366C585O66348C592O66386C593O66402C597O66418C604O66423C610O66425C619O66450C621O66604C624O66620C627O66630C633O66668C640O66697C649O66668C656O66727C664O66756C673O66727C680O66774C694O66789C700O66804C702O66817C707O66835C709O66857C714O66887C718O66934C726O66942C733O66958C739O66966C757O66966C762O67013C768O67013C772O67050C778O67071C796O67071C803O67126C809O67126C813O67169C819O67195C825O67195C832O67233C836O67250C842O67250C848O67281C854O67297C856O67311C860O67377C866O67392C874O67414C878O67414C885O67392C893O67473C899O67490C905O67522C910O67608C918O67635C923O67663C931O67671C938O67685C944O67693C952O67699C956O67710C962O67710C978O67693C983O67764C989O67764C993O67799C994O67815C998O65182C1004O67836C1011O67841C1017O67843C1026O67863C1030O67870C1035O67903,,
tick,0x7fff203b72be,133223,0,0x0,3,0x10f0ac650,0x1eea8f610941,0x1eea8f610261,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
tick,0x7fff202fa261,133248,0,0x0,3,0x10f0ac650,0x1eea8f610941,0x1eea8f610261,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
tick,0x10ebc3ba6,133262,0,0x0,3,0x10f0ac650,0x1eea8f610941,0x1eea8f610261,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
tick,0x7fff203e537c,133274,0,0x0,3,0x10f0ac650,0x1eea8f610941,0x1eea8f610261,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
tick,0x7fff203e537c,133286,0,0x0,3,0x10f0ac650,0x1eea8f610941,0x1eea8f610261,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
code-creation,LazyCompile,10,133310,0x1eea8f6173ee,123,getOptions node:internal/fs/utils:314:20,0x1eeaaa669958,~
script-source,78,node:internal/fs/utils,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  BigInt\x2C\n  Date\x2C\n  DateNow\x2C\n  DatePrototypeGetTime\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeCall\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  NumberIsInteger\x2C\n  MathMin\x2C\n  ObjectIs\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplace\x2C\n  Symbol\x2C\n  TypedArrayPrototypeIncludes\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  codes: {\n    ERR_FS_EISDIR\x2C\n    ERR_FS_INVALID_SYMLINK_TYPE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\n  }\x2C\n  hideStackFrames\x2C\n  uvException\n} = require('internal/errors');\nconst {\n  isArrayBufferView\x2C\n  isUint8Array\x2C\n  isDate\x2C\n  isBigUint64Array\n} = require('internal/util/types');\nconst { once } = require('internal/util');\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst kType = Symbol('type');\nconst kStats = Symbol('stats');\nconst assert = require('internal/assert');\n\nconst {\n  fs: {\n    F_OK = 0\x2C\n    W_OK = 0\x2C\n    R_OK = 0\x2C\n    X_OK = 0\x2C\n    COPYFILE_EXCL\x2C\n    COPYFILE_FICLONE\x2C\n    COPYFILE_FICLONE_FORCE\x2C\n    O_APPEND\x2C\n    O_CREAT\x2C\n    O_EXCL\x2C\n    O_RDONLY\x2C\n    O_RDWR\x2C\n    O_SYNC\x2C\n    O_TRUNC\x2C\n    O_WRONLY\x2C\n    S_IFBLK\x2C\n    S_IFCHR\x2C\n    S_IFDIR\x2C\n    S_IFIFO\x2C\n    S_IFLNK\x2C\n    S_IFMT\x2C\n    S_IFREG\x2C\n    S_IFSOCK\x2C\n    UV_FS_SYMLINK_DIR\x2C\n    UV_FS_SYMLINK_JUNCTION\x2C\n    UV_DIRENT_UNKNOWN\x2C\n    UV_DIRENT_FILE\x2C\n    UV_DIRENT_DIR\x2C\n    UV_DIRENT_LINK\x2C\n    UV_DIRENT_FIFO\x2C\n    UV_DIRENT_SOCKET\x2C\n    UV_DIRENT_CHAR\x2C\n    UV_DIRENT_BLOCK\n  }\x2C\n  os: {\n    errno: {\n      EISDIR\n    }\n  }\n} = internalBinding('constants');\n\n// The access modes can be any of F_OK\x2C R_OK\x2C W_OK or X_OK. Some might not be\n// available on specific systems. They can be used in combination as well\n// (F_OK | R_OK | W_OK | X_OK).\nconst kMinimumAccessMode = MathMin(F_OK\x2C W_OK\x2C R_OK\x2C X_OK);\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\n\nconst kDefaultCopyMode = 0;\n// The copy modes can be any of COPYFILE_EXCL\x2C COPYFILE_FICLONE or\n// COPYFILE_FICLONE_FORCE. They can be used in combination as well\n// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).\nconst kMinimumCopyMode = MathMin(\n  kDefaultCopyMode\x2C\n  COPYFILE_EXCL\x2C\n  COPYFILE_FICLONE\x2C\n  COPYFILE_FICLONE_FORCE\n);\nconst kMaximumCopyMode = COPYFILE_EXCL |\n                         COPYFILE_FICLONE |\n                         COPYFILE_FICLONE_FORCE;\n\n// Most platforms don't allow reads or writes >= 2 GB.\n// See https://github.com/libuv/libuv/pull/1501.\nconst kIoMaxLength = 2 ** 31 - 1;\n\n// Use 64kb in case the file type is not a regular file and thus do not know the\n// actual file size. Increasing the value further results in more frequent over\n// allocation for small files and consumes CPU time and memory that should be\n// used else wise.\n// Use up to 512kb per read otherwise to partition reading big files to prevent\n// blocking other threads in case the available threads are all in use.\nconst kReadFileUnknownBufferLength = 64 * 1024;\nconst kReadFileBufferLength = 512 * 1024;\n\nconst kWriteFileMaxChunkSize = 512 * 1024;\n\nconst kMaxUserId = 2 ** 32 - 1;\n\nconst isWindows = process.platform === 'win32';\n\nlet fs;\nfunction lazyLoadFs() {\n  if (!fs) {\n    fs = require('fs');\n  }\n  return fs;\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    const reason = 'is invalid encoding';\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'encoding'\x2C reason);\n  }\n}\n\nclass Dirent {\n  constructor(name\x2C type) {\n    this.name = name;\n    this[kType] = type;\n  }\n\n  isDirectory() {\n    return this[kType] === UV_DIRENT_DIR;\n  }\n\n  isFile() {\n    return this[kType] === UV_DIRENT_FILE;\n  }\n\n  isBlockDevice() {\n    return this[kType] === UV_DIRENT_BLOCK;\n  }\n\n  isCharacterDevice() {\n    return this[kType] === UV_DIRENT_CHAR;\n  }\n\n  isSymbolicLink() {\n    return this[kType] === UV_DIRENT_LINK;\n  }\n\n  isFIFO() {\n    return this[kType] === UV_DIRENT_FIFO;\n  }\n\n  isSocket() {\n    return this[kType] === UV_DIRENT_SOCKET;\n  }\n}\n\nclass DirentFromStats extends Dirent {\n  constructor(name\x2C stats) {\n    super(name\x2C null);\n    this[kStats] = stats;\n  }\n}\n\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\n  if (name === 'constructor') {\n    continue;\n  }\n  DirentFromStats.prototype[name] = function() {\n    return this[kStats][name]();\n  };\n}\n\nfunction copyObject(source) {\n  const target = {};\n  for (const key in source)\n    target[key] = source[key];\n  return target;\n}\n\nconst bufferSep = Buffer.from(pathModule.sep);\n\nfunction join(path\x2C name) {\n  if ((typeof path === 'string' || isUint8Array(path)) &&\n      name === undefined) {\n    return path;\n  }\n\n  if (typeof path === 'string' && isUint8Array(name)) {\n    const pathBuffer = Buffer.from(pathModule.join(path\x2C pathModule.sep));\n    return Buffer.concat([pathBuffer\x2C name]);\n  }\n\n  if (typeof path === 'string' && typeof name === 'string') {\n    return pathModule.join(path\x2C name);\n  }\n\n  if (isUint8Array(path) && isUint8Array(name)) {\n    return Buffer.concat([path\x2C bufferSep\x2C name]);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'path'\x2C ['string'\x2C 'Buffer']\x2C path);\n}\n\nfunction getDirents(path\x2C { 0: names\x2C 1: types }\x2C callback) {\n  let i;\n  if (typeof callback === 'function') {\n    const len = names.length;\n    let toFinish = 0;\n    callback = once(callback);\n    for (i = 0; i < len; i++) {\n      const type = types[i];\n      if (type === UV_DIRENT_UNKNOWN) {\n        const name = names[i];\n        const idx = i;\n        toFinish++;\n        let filepath;\n        try {\n          filepath = join(path\x2C name);\n        } catch (err) {\n          callback(err);\n          return;\n        }\n        lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n          if (err) {\n            callback(err);\n            return;\n          }\n          names[idx] = new DirentFromStats(name\x2C stats);\n          if (--toFinish === 0) {\n            callback(null\x2C names);\n          }\n        });\n      } else {\n        names[i] = new Dirent(names[i]\x2C types[i]);\n      }\n    }\n    if (toFinish === 0) {\n      callback(null\x2C names);\n    }\n  } else {\n    const len = names.length;\n    for (i = 0; i < len; i++) {\n      names[i] = getDirent(path\x2C names[i]\x2C types[i]);\n    }\n    return names;\n  }\n}\n\nfunction getDirent(path\x2C name\x2C type\x2C callback) {\n  if (typeof callback === 'function') {\n    if (type === UV_DIRENT_UNKNOWN) {\n      let filepath;\n      try {\n        filepath = join(path\x2C name);\n      } catch (err) {\n        callback(err);\n        return;\n      }\n      lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        callback(null\x2C new DirentFromStats(name\x2C stats));\n      });\n    } else {\n      callback(null\x2C new Dirent(name\x2C type));\n    }\n  } else if (type === UV_DIRENT_UNKNOWN) {\n    const stats = lazyLoadFs().lstatSync(join(path\x2C name));\n    return new DirentFromStats(name\x2C stats);\n  } else {\n    return new Dirent(name\x2C type);\n  }\n}\n\nfunction getOptions(options\x2C defaultOptions) {\n  if (options === null || options === undefined ||\n      typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = { ...defaultOptions };\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C ['string'\x2C 'Object']\x2C options);\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n\n  if (options.signal !== undefined) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n  return options;\n}\n\n/**\n * @param {InternalFSBinding.FSSyncContext} ctx\n */\nfunction handleErrorFromBinding(ctx) {\n  if (ctx.errno !== undefined) {  // libuv error numbers\n    const err = uvException(ctx);\n    ErrorCaptureStackTrace(err\x2C handleErrorFromBinding);\n    throw err;\n  }\n  if (ctx.error !== undefined) {  // Errors created in C++ land.\n    // TODO(joyeecheung): currently\x2C ctx.error are encoding errors\n    // usually caused by memory problems. We need to figure out proper error\n    // code(s) for this.\n    ErrorCaptureStackTrace(ctx.error\x2C handleErrorFromBinding);\n    throw ctx.error;\n  }\n}\n\n// Check if the path contains null types if it is a string nor Uint8Array\x2C\n// otherwise return silently.\nconst nullCheck = hideStackFrames((path\x2C propName\x2C throwError = true) => {\n  const pathIsString = typeof path === 'string';\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if ((!pathIsString && !pathIsUint8Array) ||\n      (pathIsString && !StringPrototypeIncludes(path\x2C '\\u0000')) ||\n      (pathIsUint8Array && !TypedArrayPrototypeIncludes(path\x2C 0))) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(\n    propName\x2C\n    path\x2C\n    'must be a string or Uint8Array without null bytes'\n  );\n  if (throwError) {\n    throw err;\n  }\n  return err;\n});\n\nfunction preprocessSymlinkDestination(path\x2C type\x2C linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  }\n  path = '' + path;\n  if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath\x2C '..'\x2C path);\n    return pathModule.toNamespacedPath(path);\n  }\n  if (pathModule.isAbsolute(path)) {\n    // If the path is absolute\x2C use the \\\\?\\-prefix to enable long filenames\n    return pathModule.toNamespacedPath(path);\n  }\n  // Windows symlinks don't tolerate forward slashes.\n  return StringPrototypeReplace(path\x2C /\\//g\x2C '\\\\');\n}\n\n// Constructor for file stats.\nfunction StatsBase(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                   ino\x2C size\x2C blocks) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n}\n\nStatsBase.prototype.isDirectory = function() {\n  return this._checkModeProperty(S_IFDIR);\n};\n\nStatsBase.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStatsBase.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(S_IFBLK);\n};\n\nStatsBase.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(S_IFCHR);\n};\n\nStatsBase.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStatsBase.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStatsBase.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst kNsPerMsBigInt = 10n ** 6n;\nconst kNsPerSecBigInt = 10n ** 9n;\nconst kMsPerSec = 10 ** 3;\nconst kNsPerMs = 10 ** 6;\nfunction msFromTimeSpec(sec\x2C nsec) {\n  return sec * kMsPerSec + nsec / kNsPerMs;\n}\n\nfunction nsFromTimeSpecBigInt(sec\x2C nsec) {\n  return sec * kNsPerSecBigInt + nsec;\n}\n\n// The Date constructor performs Math.floor() to the timestamp.\n// https://www.ecma-international.org/ecma-262/#sec-timeclip\n// Since there may be a precision loss when the timestamp is\n// converted to a floating point number\x2C we manually round\n// the timestamp here before passing it to Date().\n// Refs: https://github.com/nodejs/node/pull/12607\nfunction dateFromMs(ms) {\n  return new Date(Number(ms) + 0.5);\n}\n\nfunction BigIntStats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                     ino\x2C size\x2C blocks\x2C\n                     atimeNs\x2C mtimeNs\x2C ctimeNs\x2C birthtimeNs) {\n  ReflectApply(StatsBase\x2C this\x2C [dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                                 ino\x2C size\x2C blocks]);\n\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\n  this.atimeNs = atimeNs;\n  this.mtimeNs = mtimeNs;\n  this.ctimeNs = ctimeNs;\n  this.birthtimeNs = birthtimeNs;\n  this.atime = dateFromMs(this.atimeMs);\n  this.mtime = dateFromMs(this.mtimeMs);\n  this.ctime = dateFromMs(this.ctimeMs);\n  this.birthtime = dateFromMs(this.birthtimeMs);\n}\n\nObjectSetPrototypeOf(BigIntStats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(BigIntStats\x2C StatsBase);\n\nBigIntStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n};\n\nfunction Stats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n               ino\x2C size\x2C blocks\x2C\n               atimeMs\x2C mtimeMs\x2C ctimeMs\x2C birthtimeMs) {\n  FunctionPrototypeCall(StatsBase\x2C this\x2C dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C\n                        blksize\x2C ino\x2C size\x2C blocks);\n  this.atimeMs = atimeMs;\n  this.mtimeMs = mtimeMs;\n  this.ctimeMs = ctimeMs;\n  this.birthtimeMs = birthtimeMs;\n  this.atime = dateFromMs(atimeMs);\n  this.mtime = dateFromMs(mtimeMs);\n  this.ctime = dateFromMs(ctimeMs);\n  this.birthtime = dateFromMs(birthtimeMs);\n}\n\nObjectSetPrototypeOf(Stats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(Stats\x2C StatsBase);\n\n// HACK: Workaround for https://github.com/standard-things/esm/issues/821.\n// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.\nStats.prototype.isFile = StatsBase.prototype.isFile;\n\nStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & S_IFMT) === property;\n};\n\n/**\n * @param {Float64Array | BigUint64Array} stats\n * @param {number} offset\n * @returns\n */\nfunction getStatsFromBinding(stats\x2C offset = 0) {\n  if (isBigUint64Array(stats)) {\n    return new BigIntStats(\n      stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n      stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n      stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n      stats[9 + offset]\x2C\n      nsFromTimeSpecBigInt(stats[10 + offset]\x2C stats[11 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[12 + offset]\x2C stats[13 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[14 + offset]\x2C stats[15 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[16 + offset]\x2C stats[17 + offset])\n    );\n  }\n  return new Stats(\n    stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n    stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n    stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n    stats[9 + offset]\x2C\n    msFromTimeSpec(stats[10 + offset]\x2C stats[11 + offset])\x2C\n    msFromTimeSpec(stats[12 + offset]\x2C stats[13 + offset])\x2C\n    msFromTimeSpec(stats[14 + offset]\x2C stats[15 + offset])\x2C\n    msFromTimeSpec(stats[16 + offset]\x2C stats[17 + offset])\n  );\n}\n\nfunction stringToFlags(flags\x2C name = 'flags') {\n  if (typeof flags === 'number') {\n    validateInt32(flags\x2C name);\n    return flags;\n  }\n\n  if (flags == null) {\n    return O_RDONLY;\n  }\n\n  switch (flags) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n    case 'as' : // Fall through.\n    case 'sa' : return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n    case 'as+': // Fall through.\n    case 'sa+': return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('flags'\x2C flags);\n}\n\nconst stringToSymlinkType = hideStackFrames((type) => {\n  let flags = 0;\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'dir':\n        flags |= UV_FS_SYMLINK_DIR;\n        break;\n      case 'junction':\n        flags |= UV_FS_SYMLINK_JUNCTION;\n        break;\n      case 'file':\n        break;\n      default:\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\n    }\n  }\n  return flags;\n});\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time\x2C name = 'time') {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (NumberIsFinite(time)) {\n    if (time < 0) {\n      return DateNow() / 1000;\n    }\n    return time;\n  }\n  if (isDate(time)) {\n    // Convert to 123.456 UNIX timestamp\n    return DatePrototypeGetTime(time) / 1000;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name\x2C ['Date'\x2C 'Time in seconds']\x2C time);\n}\n\nconst validateOffsetLengthRead = hideStackFrames(\n  (offset\x2C length\x2C bufferLength) => {\n    if (offset < 0) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C '>= 0'\x2C offset);\n    }\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n    if (offset + length > bufferLength) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C\n                                 `<= ${bufferLength - offset}`\x2C length);\n    }\n  }\n);\n\nconst validateOffsetLengthWrite = hideStackFrames(\n  (offset\x2C length\x2C byteLength) => {\n    if (offset > byteLength) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C `<= ${byteLength}`\x2C offset);\n    }\n\n    if (length > byteLength - offset) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C `<= ${byteLength - offset}`\x2C length);\n    }\n\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n\n    validateInt32(length\x2C 'length'\x2C 0);\n  }\n);\n\nconst validatePath = hideStackFrames((path\x2C propName = 'path') => {\n  if (typeof path !== 'string' && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C ['string'\x2C 'Buffer'\x2C 'URL']\x2C path);\n  }\n\n  const err = nullCheck(path\x2C propName\x2C false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n});\n\nconst getValidatedPath = hideStackFrames((fileURLOrPath\x2C propName = 'path') => {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path\x2C propName);\n  return path;\n});\n\nconst getValidatedFd = hideStackFrames((fd\x2C propName = 'fd') => {\n  if (ObjectIs(fd\x2C -0)) {\n    return 0;\n  }\n\n  validateInt32(fd\x2C propName\x2C 0);\n\n  return fd;\n});\n\nconst validateBufferArray = hideStackFrames((buffers\x2C propName = 'buffers') => {\n  if (!ArrayIsArray(buffers))\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n\n  for (let i = 0; i < buffers.length; i++) {\n    if (!isArrayBufferView(buffers[i]))\n      throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n  }\n\n  return buffers;\n});\n\nlet nonPortableTemplateWarn = true;\n\nfunction warnOnNonPortableTemplate(template) {\n  // Template strings passed to the mkdtemp() family of functions should not\n  // end with 'X' because they are handled inconsistently across platforms.\n  if (nonPortableTemplateWarn && StringPrototypeEndsWith(template\x2C 'X')) {\n    process.emitWarning('mkdtemp() templates ending with X are not portable. ' +\n                        'For details see: https://nodejs.org/api/fs.html');\n    nonPortableTemplateWarn = false;\n  }\n}\n\nconst defaultCpOptions = {\n  dereference: false\x2C\n  errorOnExist: false\x2C\n  filter: undefined\x2C\n  force: true\x2C\n  preserveTimestamps: false\x2C\n  recursive: false\x2C\n};\n\nconst defaultRmOptions = {\n  recursive: false\x2C\n  force: false\x2C\n  retryDelay: 100\x2C\n  maxRetries: 0\n};\n\nconst defaultRmdirOptions = {\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n  recursive: false\x2C\n};\n\nconst validateCpOptions = hideStackFrames((options) => {\n  if (options === undefined)\n    return { ...defaultCpOptions };\n  validateObject(options\x2C 'options');\n  options = { ...defaultCpOptions\x2C ...options };\n  validateBoolean(options.dereference\x2C 'options.dereference');\n  validateBoolean(options.errorOnExist\x2C 'options.errorOnExist');\n  validateBoolean(options.force\x2C 'options.force');\n  validateBoolean(options.preserveTimestamps\x2C 'options.preserveTimestamps');\n  validateBoolean(options.recursive\x2C 'options.recursive');\n  if (options.filter !== undefined) {\n    validateFunction(options.filter\x2C 'options.filter');\n  }\n  return options;\n});\n\nconst validateRmOptions = hideStackFrames((path\x2C options\x2C expectDir\x2C cb) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  lazyLoadFs().stat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (options.force && err.code === 'ENOENT') {\n        return cb(null\x2C options);\n      }\n      return cb(err\x2C options);\n    }\n\n    if (expectDir && !stats.isDirectory()) {\n      return cb(false);\n    }\n\n    if (stats.isDirectory() && !options.recursive) {\n      return cb(new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      }));\n    }\n    return cb(null\x2C options);\n  });\n});\n\nconst validateRmOptionsSync = hideStackFrames((path\x2C options\x2C expectDir) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  if (!options.force || expectDir || !options.recursive) {\n    const isDirectory = lazyLoadFs()\n      .statSync(path\x2C { throwIfNoEntry: !options.force })?.isDirectory();\n\n    if (expectDir && !isDirectory) {\n      return false;\n    }\n\n    if (isDirectory && !options.recursive) {\n      throw new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      });\n    }\n  }\n\n  return options;\n});\n\nlet recursiveRmdirWarned = process.noDeprecation;\nfunction emitRecursiveRmdirWarning() {\n  if (!recursiveRmdirWarned) {\n    process.emitWarning(\n      'In future versions of Node.js\x2C fs.rmdir(path\x2C { recursive: true }) ' +\n      'will be removed. Use fs.rm(path\x2C { recursive: true }) instead'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0147'\n    );\n    recursiveRmdirWarned = true;\n  }\n}\n\nconst validateRmdirOptions = hideStackFrames(\n  (options\x2C defaults = defaultRmdirOptions) => {\n    if (options === undefined)\n      return defaults;\n    validateObject(options\x2C 'options');\n\n    options = { ...defaults\x2C ...options };\n\n    validateBoolean(options.recursive\x2C 'options.recursive');\n    validateInt32(options.retryDelay\x2C 'options.retryDelay'\x2C 0);\n    validateUint32(options.maxRetries\x2C 'options.maxRetries');\n\n    return options;\n  });\n\nconst getValidMode = hideStackFrames((mode\x2C type) => {\n  let min = kMinimumAccessMode;\n  let max = kMaximumAccessMode;\n  let def = F_OK;\n  if (type === 'copyFile') {\n    min = kMinimumCopyMode;\n    max = kMaximumCopyMode;\n    def = mode || kDefaultCopyMode;\n  } else {\n    assert(type === 'access');\n  }\n  if (mode == null) {\n    return def;\n  }\n  if (NumberIsInteger(mode) && mode >= min && mode <= max) {\n    return mode;\n  }\n  if (typeof mode !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE('mode'\x2C 'integer'\x2C mode);\n  }\n  throw new ERR_OUT_OF_RANGE(\n    'mode'\x2C `an integer >= ${min} && <= ${max}`\x2C mode);\n});\n\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer === 'string') {\n    return;\n  }\n\n  if (\n    typeof buffer === 'object' &&\n    buffer !== null &&\n    typeof buffer.toString === 'function' &&\n    ObjectPrototypeHasOwnProperty(buffer\x2C 'toString')\n  ) {\n    return;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    name\x2C\n    ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n    buffer\n  );\n});\n\nconst validatePosition = hideStackFrames((position\x2C name) => {\n  if (typeof position === 'number') {\n    validateInteger(position\x2C 'position');\n  } else if (typeof position === 'bigint') {\n    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {\n      throw new ERR_OUT_OF_RANGE('position'\x2C\n                                 `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`\x2C\n                                 position);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('position'\x2C\n                                   ['integer'\x2C 'bigint']\x2C\n                                   position);\n  }\n});\n\nmodule.exports = {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  assertEncoding\x2C\n  BigIntStats\x2C  // for testing\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  realpathCacheKey: Symbol('realpathCacheKey')\x2C\n  getStatsFromBinding\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  Stats\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n};\n
code-source-info,0x1eea8f6173ee,78,7218,7841,C0O7248C14O7340C16O7362C17O7370C23O7409C29O7453C31O7477C35O7492C42O7527C48O7566C66O7572C71O7566C72O7659C79O7668C84O7686C87O7709C92O7686C96O7735C102O7763C107O7791C115O7763C120O7824C122O7839,,
tick,0x7fff2030d928,135098,0,0x0,3,0x10f0ac650,0x1eea8f610d5a,0x1eea8f610941,0x1eea8f610261,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
code-creation,LazyCompile,10,135136,0x1eea8f619346,48,assertEncoding node:internal/fs/utils:151:24,0x1eeaaa669360,~
code-source-info,0x1eea8f619346,78,3527,3704,C0O3542C6O3559C9O3566C14O3566C21O3609C24O3636C40O3642C45O3636C47O3703,,
code-creation,LazyCompile,10,135229,0x1eea8f61945e,20,toPathIfFileURL node:internal/url:1496:25,0x1eeac205b128,~
script-source,33,node:internal/url,'use strict';\n\nconst {\n  Array\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  FunctionPrototypeBind\x2C\n  Int8Array\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ReflectApply\x2C\n  ReflectGetOwnPropertyDescriptor\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { inspect } = require('internal/util/inspect');\nconst {\n  encodeStr\x2C\n  hexTable\x2C\n  isHexTable\n} = require('internal/querystring');\n\nconst {\n  getConstructorOf\x2C\n  removeColors\x2C\n  toUSVString\x2C\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_ARG_NOT_ITERABLE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FILE_URL_HOST\x2C\n    ERR_INVALID_FILE_URL_PATH\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_INVALID_TUPLE\x2C\n    ERR_INVALID_URL\x2C\n    ERR_INVALID_URL_SCHEME\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_NO_CRYPTO\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  CHAR_AMPERSAND\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_EQUAL\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_PERCENT\x2C\n  CHAR_PLUS\n} = require('internal/constants');\nconst path = require('path');\n\nconst {\n  validateCallback\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst {\n  domainToASCII: _domainToASCII\x2C\n  domainToUnicode: _domainToUnicode\x2C\n  encodeAuth\x2C\n  parse\x2C\n  setURLConstructor\x2C\n  URL_FLAGS_CANNOT_BE_BASE\x2C\n  URL_FLAGS_HAS_FRAGMENT\x2C\n  URL_FLAGS_HAS_HOST\x2C\n  URL_FLAGS_HAS_PASSWORD\x2C\n  URL_FLAGS_HAS_PATH\x2C\n  URL_FLAGS_HAS_QUERY\x2C\n  URL_FLAGS_HAS_USERNAME\x2C\n  URL_FLAGS_IS_DEFAULT_SCHEME_PORT\x2C\n  URL_FLAGS_SPECIAL\x2C\n  kFragment\x2C\n  kHost\x2C\n  kHostname\x2C\n  kPathStart\x2C\n  kPort\x2C\n  kQuery\x2C\n  kSchemeStart\n} = internalBinding('url');\n\nconst {\n  storeDataObject\x2C\n  revokeDataObject\x2C\n} = internalBinding('blob');\n\nconst context = Symbol('context');\nconst cannotBeBase = Symbol('cannot-be-base');\nconst cannotHaveUsernamePasswordPort =\n    Symbol('cannot-have-username-password-port');\nconst special = Symbol('special');\nconst searchParams = Symbol('query');\nconst kFormat = Symbol('format');\n\nlet blob;\nlet cryptoRandom;\n\nfunction lazyBlob() {\n  blob ??= require('internal/blob');\n  return blob;\n}\n\nfunction lazyCryptoRandom() {\n  try {\n    cryptoRandom ??= require('internal/crypto/random');\n  } catch {\n    // If Node.js built without crypto support\x2C we'll fall\n    // through here and handle it later.\n  }\n  return cryptoRandom;\n}\n\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nconst IteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf([][SymbolIterator]())\n);\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-opaque\nconst kOpaqueOrigin = 'null';\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin\nfunction serializeTupleOrigin(scheme\x2C host\x2C port) {\n  return `${scheme}//${host}${port === null ? '' : `:${port}`}`;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard\x2C with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  constructor() {\n    this.flags = 0;\n    this.scheme = ':';\n    this.username = '';\n    this.password = '';\n    this.host = null;\n    this.port = null;\n    this.path = [];\n    this.query = null;\n    this.fragment = null;\n  }\n}\n\nfunction isURLSearchParams(self) {\n  return self && self[searchParams] && !self[searchParams][searchParams];\n}\n\nclass URLSearchParams {\n  // URL Standard says the default value is ''\x2C but as undefined and '' have\n  // the same result\x2C undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init === null || init === undefined) {\n      this[searchParams] = [];\n    } else if (typeof init === 'object' || typeof init === 'function') {\n      const method = init[SymbolIterator];\n      if (method === this[SymbolIterator]) {\n        // While the spec does not have this branch\x2C we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') {\n          throw new ERR_ARG_NOT_ITERABLE('Query pairs');\n        }\n\n        // Sequence<sequence<USVString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if ((typeof pair !== 'object' && typeof pair !== 'function') ||\n              pair === null ||\n              typeof pair[SymbolIterator] !== 'function') {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          const convertedPair = [];\n          for (const element of pair)\n            ArrayPrototypePush(convertedPair\x2C toUSVString(element));\n          ArrayPrototypePush(pairs\x2C convertedPair);\n        }\n\n        this[searchParams] = [];\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          ArrayPrototypePush(this[searchParams]\x2C pair[0]\x2C pair[1]);\n        }\n      } else {\n        // Record<USVString\x2C USVString>\n        // Need to use reflection APIs for full spec compliance.\n        this[searchParams] = [];\n        const keys = ReflectOwnKeys(init);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = ReflectGetOwnPropertyDescriptor(init\x2C key);\n          if (desc !== undefined && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n            this[searchParams].push(typedKey\x2C typedValue);\n          }\n        }\n      }\n    } else {\n      // USVString\n      init = toUSVString(init);\n      if (init[0] === '?') init = init.slice(1);\n      initSearchParams(this\x2C init);\n    }\n\n    // "associated url object"\n    this[context] = null;\n  }\n\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const separator = '\x2C ';\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const innerInspect = (v) => inspect(v\x2C innerOpts);\n\n    const list = this[searchParams];\n    const output = [];\n    for (let i = 0; i < list.length; i += 2)\n      ArrayPrototypePush(\n        output\x2C\n        `${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    const length = ArrayPrototypeReduce(\n      output\x2C\n      (prev\x2C cur) => prev + removeColors(cur).length + separator.length\x2C\n      -separator.length\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n` +\n      `  ${ArrayPrototypeJoin(output\x2C '\x2C\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ` +\n      `${ArrayPrototypeJoin(output\x2C separator)} }`;\n    }\n    return `${this.constructor.name} {}`;\n  }\n\n  append(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    ArrayPrototypePush(this[searchParams]\x2C name\x2C value);\n    update(this[context]\x2C this);\n  }\n\n  delete(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i\x2C 2);\n      } else {\n        i += 2;\n      }\n    }\n    update(this[context]\x2C this);\n  }\n\n  get(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  }\n\n  getAll(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  }\n\n  has(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  set(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`\x2C in `list`\x2C set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    let found = false;\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i\x2C 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise\x2C append a new name-value pair whose name is `name` and value\n    // is `value`\x2C to `list`.\n    if (!found) {\n      ArrayPrototypePush(list\x2C name\x2C value);\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n\n    if (len <= 2) {\n      // Nothing needs to be done.\n    } else if (len < 100) {\n      // 100 is found through testing.\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (let i = 2; i < len; i += 2) {\n        const curKey = a[i];\n        const curVal = a[i + 1];\n        let j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (let step = 2; step < len; step *= 2) {\n        for (let start = 0; start < len - 2; start += 2 * step) {\n          const mid = start + step;\n          let end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer);\n        }\n      }\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key+value');\n  }\n\n  forEach(callback\x2C thisArg = undefined) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    validateCallback(callback);\n\n    let list = this[searchParams];\n\n    let i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg\x2C value\x2C key\x2C this);\n      // In case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key');\n  }\n\n  values() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'value');\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return serializeParams(this[searchParams]);\n  }\n}\n\nObjectDefineProperties(URLSearchParams.prototype\x2C {\n  append: { enumerable: true }\x2C\n  delete: { enumerable: true }\x2C\n  get: { enumerable: true }\x2C\n  getAll: { enumerable: true }\x2C\n  has: { enumerable: true }\x2C\n  set: { enumerable: true }\x2C\n  sort: { enumerable: true }\x2C\n  entries: { enumerable: true }\x2C\n  forEach: { enumerable: true }\x2C\n  keys: { enumerable: true }\x2C\n  values: { enumerable: true }\x2C\n  toString: { enumerable: true }\x2C\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URLSearchParams' }\x2C\n\n  // https://heycam.github.io/webidl/#es-iterable-entries\n  [SymbolIterator]: {\n    configurable: true\x2C\n    writable: true\x2C\n    value: URLSearchParams.prototype.entries\x2C\n  }\x2C\n});\n\nfunction onParseComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                         host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  if (!this[searchParams]) { // Invoked from URL constructor\n    this[searchParams] = new URLSearchParams();\n    this[searchParams][context] = this;\n  }\n  initSearchParams(this[searchParams]\x2C query);\n}\n\nfunction onParseError(flags\x2C input) {\n  throw new ERR_INVALID_URL(input);\n}\n\nfunction onParseProtocolComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\n    ctx.flags |= URL_FLAGS_SPECIAL;\n  } else {\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\n  }\n  ctx.scheme = protocol;\n  ctx.port = port;\n}\n\nfunction onParseHostnameComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParsePortComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].port = port;\n}\n\nfunction onParseHostComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  ReflectApply(onParseHostnameComplete\x2C this\x2C arguments);\n  if (port !== null || ((flags & URL_FLAGS_IS_DEFAULT_SCHEME_PORT) !== 0))\n    ReflectApply(onParsePortComplete\x2C this\x2C arguments);\n}\n\nfunction onParsePathComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\n    ctx.path = path;\n    ctx.flags |= URL_FLAGS_HAS_PATH;\n  } else {\n    ctx.path = [];\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\n  }\n\n  // The C++ binding may set host to empty string.\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParseSearchComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                               host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].query = query;\n}\n\nfunction onParseHashComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].fragment = fragment;\n}\n\nclass URL {\n  constructor(input\x2C base) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    let base_context;\n    if (base !== undefined) {\n      base_context = new URL(base)[context];\n    }\n    this[context] = new URLContext();\n    parse(input\x2C -1\x2C base_context\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C onParseError);\n  }\n\n  get [special]() {\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\n  }\n\n  get [cannotBeBase]() {\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\n  }\n\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  get [cannotHaveUsernamePasswordPort]() {\n    const { host\x2C scheme } = this[context];\n    return ((host == null || host === '') ||\n            this[cannotBeBase] ||\n            scheme === 'file:');\n  }\n\n  [inspect.custom](depth\x2C opts) {\n    if (this == null ||\n        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new ERR_INVALID_THIS('URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || URL;\n    const obj = ObjectCreate({ constructor });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj.cannotBeBase = this[cannotBeBase];\n      obj.special = this[special];\n      obj[context] = this[context];\n    }\n\n    return `${constructor.name} ${inspect(obj\x2C opts)}`;\n  }\n\n  [kFormat](options) {\n    if (options)\n      validateObject(options\x2C 'options');\n\n    options = {\n      fragment: true\x2C\n      unicode: false\x2C\n      search: true\x2C\n      auth: true\x2C\n      ...options\n    };\n    const ctx = this[context];\n    // https://url.spec.whatwg.org/#url-serializing\n    let ret = ctx.scheme;\n    if (ctx.host !== null) {\n      ret += '//';\n      const has_username = ctx.username !== '';\n      const has_password = ctx.password !== '';\n      if (options.auth && (has_username || has_password)) {\n        if (has_username)\n          ret += ctx.username;\n        if (has_password)\n          ret += `:${ctx.password}`;\n        ret += '@';\n      }\n      ret += options.unicode ?\n        domainToUnicode(ctx.host) : ctx.host;\n      if (ctx.port !== null)\n        ret += `:${ctx.port}`;\n    }\n    if (this[cannotBeBase]) {\n      ret += ctx.path[0];\n    } else {\n      if (ctx.host === null && ctx.path.length > 1 && ctx.path[0] === '') {\n        ret += '/.';\n      }\n      if (ctx.path.length) {\n        ret += '/' + ArrayPrototypeJoin(ctx.path\x2C '/');\n      }\n    }\n    if (options.search && ctx.query !== null)\n      ret += `?${ctx.query}`;\n    if (options.fragment && ctx.fragment !== null)\n      ret += `#${ctx.fragment}`;\n    return ret;\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  toString() {\n    return this[kFormat]({});\n  }\n\n  get href() {\n    return this[kFormat]({});\n  }\n\n  set href(input) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    parse(input\x2C -1\x2C undefined\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C onParseError);\n  }\n\n  // readonly\n  get origin() {\n    // Refs: https://url.spec.whatwg.org/#concept-url-origin\n    const ctx = this[context];\n    switch (ctx.scheme) {\n      case 'blob:':\n        if (ctx.path.length > 0) {\n          try {\n            return (new URL(ctx.path[0])).origin;\n          } catch {\n            // Fall through... do nothing\n          }\n        }\n        return kOpaqueOrigin;\n      case 'ftp:':\n      case 'http:':\n      case 'https:':\n      case 'ws:':\n      case 'wss:':\n        return serializeTupleOrigin(ctx.scheme\x2C ctx.host\x2C ctx.port);\n    }\n    return kOpaqueOrigin;\n  }\n\n  get protocol() {\n    return this[context].scheme;\n  }\n\n  set protocol(scheme) {\n    // toUSVString is not needed.\n    scheme = `${scheme}`;\n    if (scheme.length === 0)\n      return;\n    const ctx = this[context];\n    parse(scheme\x2C kSchemeStart\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseProtocolComplete\x2C this));\n  }\n\n  get username() {\n    return this[context].username;\n  }\n\n  set username(username) {\n    // toUSVString is not needed.\n    username = `${username}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (username === '') {\n      ctx.username = '';\n      ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\n      return;\n    }\n    ctx.username = encodeAuth(username);\n    ctx.flags |= URL_FLAGS_HAS_USERNAME;\n  }\n\n  get password() {\n    return this[context].password;\n  }\n\n  set password(password) {\n    // toUSVString is not needed.\n    password = `${password}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (password === '') {\n      ctx.password = '';\n      ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\n      return;\n    }\n    ctx.password = encodeAuth(password);\n    ctx.flags |= URL_FLAGS_HAS_PASSWORD;\n  }\n\n  get host() {\n    const ctx = this[context];\n    let ret = ctx.host || '';\n    if (ctx.port !== null)\n      ret += `:${ctx.port}`;\n    return ret;\n  }\n\n  set host(host) {\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHost\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHostComplete\x2C this));\n  }\n\n  get hostname() {\n    return this[context].host || '';\n  }\n\n  set hostname(host) {\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHostname\x2C null\x2C ctx\x2C onParseHostnameComplete.bind(this));\n  }\n\n  get port() {\n    const port = this[context].port;\n    return port === null ? '' : String(port);\n  }\n\n  set port(port) {\n    // toUSVString is not needed.\n    port = `${port}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (port === '') {\n      ctx.port = null;\n      return;\n    }\n    parse(port\x2C kPort\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParsePortComplete\x2C this));\n  }\n\n  get pathname() {\n    const ctx = this[context];\n    if (this[cannotBeBase])\n      return ctx.path[0];\n    if (ctx.path.length === 0)\n      return '';\n    return `/${ArrayPrototypeJoin(ctx.path\x2C '/')}`;\n  }\n\n  set pathname(path) {\n    // toUSVString is not needed.\n    path = `${path}`;\n    if (this[cannotBeBase])\n      return;\n    parse(path\x2C kPathStart\x2C null\x2C this[context]\x2C\n          onParsePathComplete.bind(this));\n  }\n\n  get search() {\n    const { query } = this[context];\n    if (query === null || query === '')\n      return '';\n    return `?${query}`;\n  }\n\n  set search(search) {\n    const ctx = this[context];\n    search = toUSVString(search);\n    if (search === '') {\n      ctx.query = null;\n      ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n    } else {\n      if (search[0] === '?') search = StringPrototypeSlice(search\x2C 1);\n      ctx.query = '';\n      ctx.flags |= URL_FLAGS_HAS_QUERY;\n      if (search) {\n        parse(search\x2C kQuery\x2C null\x2C ctx\x2C\n              FunctionPrototypeBind(onParseSearchComplete\x2C this));\n      }\n    }\n    initSearchParams(this[searchParams]\x2C search);\n  }\n\n  // readonly\n  get searchParams() {\n    return this[searchParams];\n  }\n\n  get hash() {\n    const { fragment } = this[context];\n    if (fragment === null || fragment === '')\n      return '';\n    return `#${fragment}`;\n  }\n\n  set hash(hash) {\n    const ctx = this[context];\n    // toUSVString is not needed.\n    hash = `${hash}`;\n    if (!hash) {\n      ctx.fragment = null;\n      ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\n      return;\n    }\n    if (hash[0] === '#') hash = StringPrototypeSlice(hash\x2C 1);\n    ctx.fragment = '';\n    ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\n    parse(hash\x2C kFragment\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHashComplete\x2C this));\n  }\n\n  toJSON() {\n    return this[kFormat]({});\n  }\n\n  static createObjectURL(obj) {\n    const cryptoRandom = lazyCryptoRandom();\n    if (cryptoRandom === undefined)\n      throw new ERR_NO_CRYPTO();\n\n    // Yes\x2C lazy loading is annoying but because of circular\n    // references between the url\x2C internal/blob\x2C and buffer\n    // modules\x2C lazy loading here makes sure that things work.\n    const blob = lazyBlob();\n    if (!blob.isBlob(obj))\n      throw new ERR_INVALID_ARG_TYPE('obj'\x2C 'Blob'\x2C obj);\n\n    const id = cryptoRandom.randomUUID();\n\n    storeDataObject(id\x2C obj[blob.kHandle]\x2C obj.size\x2C obj.type);\n\n    return `blob:nodedata:${id}`;\n  }\n\n  static revokeObjectURL(url) {\n    url = `${url}`;\n    try {\n      const parsed = new URL(url);\n      const split = StringPrototypeSplit(parsed.pathname\x2C ':');\n      if (split.length === 2)\n        revokeDataObject(split[1]);\n    } catch {\n      // If there's an error\x2C it's ignored.\n    }\n  }\n}\n\nObjectDefineProperties(URL.prototype\x2C {\n  [kFormat]: { configurable: false\x2C writable: false }\x2C\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URL' }\x2C\n  toString: { enumerable: true }\x2C\n  href: { enumerable: true }\x2C\n  origin: { enumerable: true }\x2C\n  protocol: { enumerable: true }\x2C\n  username: { enumerable: true }\x2C\n  password: { enumerable: true }\x2C\n  host: { enumerable: true }\x2C\n  hostname: { enumerable: true }\x2C\n  port: { enumerable: true }\x2C\n  pathname: { enumerable: true }\x2C\n  search: { enumerable: true }\x2C\n  searchParams: { enumerable: true }\x2C\n  hash: { enumerable: true }\x2C\n  toJSON: { enumerable: true }\x2C\n});\n\nfunction update(url\x2C params) {\n  if (!url)\n    return;\n\n  const ctx = url[context];\n  const serializedParams = params.toString();\n  if (serializedParams) {\n    ctx.query = serializedParams;\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\n  } else {\n    ctx.query = null;\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n  }\n}\n\nfunction initSearchParams(url\x2C init) {\n  if (!init) {\n    url[searchParams] = [];\n    return;\n  }\n  url[searchParams] = parseParams(init);\n}\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  let pairStart = 0;\n  let lastPos = 0;\n  let seenSep = false;\n  let buf = '';\n  let encoded = false;\n  let encodeCheck = 0;\n  let i;\n  for (i = 0; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs\x2C i);\n\n    // Try matching key/value pair separator\n    if (code === CHAR_AMPERSAND) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key\x2C add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === CHAR_EQUAL) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === CHAR_PLUS) {\n      if (lastPos < i)\n        buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === CHAR_PERCENT) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        if (isHexTable[code] === 1) {\n          if (++encodeCheck === 3) {\n            encoded = true;\n          }\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  ArrayPrototypePush(out\x2C buf);\n\n  // If `buf` is the key\x2C add an empty value.\n  if (!seenSep)\n    ArrayPrototypePush(out\x2C '');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = new Int8Array([\n/*\n  0\x2C 1\x2C 2\x2C 3\x2C 4\x2C 5\x2C 6\x2C 7\x2C 8\x2C 9\x2C A\x2C B\x2C C\x2C D\x2C E\x2C F\n*/\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x00 - 0x0F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x10 - 0x1F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 0x20 - 0x2F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x30 - 0x3F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x40 - 0x4F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 0x50 - 0x5F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x60 - 0x6F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C  // 0x70 - 0x7F\n]);\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  const firstEncodedParam = encodeStr(array[0]\x2C noEscape\x2C paramHexTable);\n  const firstEncodedValue = encodeStr(array[1]\x2C noEscape\x2C paramHexTable);\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\n\n  for (let i = 2; i < len; i += 2) {\n    const encodedParam = encodeStr(array[i]\x2C noEscape\x2C paramHexTable);\n    const encodedValue = encodeStr(array[i + 1]\x2C noEscape\x2C paramHexTable);\n    output += `&${encodedParam}=${encodedValue}`;\n  }\n\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto\x2C classStr\x2C obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  ObjectDefineProperty(proto\x2C SymbolToStringTag\x2C {\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: classStr\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of ObjectKeys(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      writable: true\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n  for (const key of ObjectGetOwnPropertySymbols(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n}\n\n// for merge sort\nfunction merge(out\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  let l\x2C r\x2C o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target\x2C kind) {\n  const iterator = ObjectCreate(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target\x2C\n    kind\x2C\n    index: 0\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = ObjectCreate(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype\x2C 'URLSearchParams Iterator'\x2C {\n  next() {\n    if (!this ||\n        ObjectGetPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n    }\n\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined\x2C\n        done: true\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name\x2C value];\n    }\n\n    return {\n      value: result\x2C\n      done: false\n    };\n  }\x2C\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const output = ArrayPrototypeReduce(\n      ArrayPrototypeSlice(target[searchParams]\x2C index)\x2C\n      (prev\x2C cur\x2C i) => {\n        const key = i % 2 === 0;\n        if (kind === 'key' && key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'value' && !key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'key+value' && !key) {\n          ArrayPrototypePush(prev\x2C [target[searchParams][index + i - 1]\x2C cur]);\n        }\n        return prev;\n      }\x2C\n      []\n    );\n    const breakLn = inspect(output\x2C innerOpts).includes('\\n');\n    const outputStrs = ArrayPrototypeMap(output\x2C (p) => inspect(p\x2C innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${ArrayPrototypeJoin(outputStrs\x2C '\x2C\\n  ')}`;\n    } else {\n      outputStr = ` ${ArrayPrototypeJoin(outputStrs\x2C '\x2C ')}`;\n    }\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\n  }\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToUnicode(`${domain}`);\n}\n\n// Utility function that converts a URL object into an ordinary\n// options object as expected by the http.request and https.request\n// APIs.\nfunction urlToHttpOptions(url) {\n  const options = {\n    protocol: url.protocol\x2C\n    hostname: typeof url.hostname === 'string' &&\n              StringPrototypeStartsWith(url.hostname\x2C '[') ?\n      StringPrototypeSlice(url.hostname\x2C 1\x2C -1) :\n      url.hostname\x2C\n    hash: url.hash\x2C\n    search: url.search\x2C\n    pathname: url.pathname\x2C\n    path: `${url.pathname || ''}${url.search || ''}`\x2C\n    href: url.href\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;\n  }\n  return options;\n}\n\nconst forwardSlashRegEx = /\\//g;\n\nfunction getPathFromURLWin32(url) {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded \\\\ or / characters'\n        );\n      }\n    }\n  }\n  pathname = pathname.replace(forwardSlashRegEx\x2C '\\\\');\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set\x2C then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n  // Otherwise\x2C it's a local path that requires a drive letter\n  const letter = pathname.codePointAt(1) | 0x20;\n  const sep = pathname[2];\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||   // a..z A..Z\n      (sep !== ':')) {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\n  }\n  return pathname.slice(1);\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\n  }\n  const pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded / characters'\n        );\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction fileURLToPath(path) {\n  if (typeof path === 'string')\n    path = new URL(path);\n  else if (!isURLInstance(path))\n    throw new ERR_INVALID_ARG_TYPE('path'\x2C ['string'\x2C 'URL']\x2C path);\n  if (path.protocol !== 'file:')\n    throw new ERR_INVALID_URL_SCHEME('file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\n// The following characters are percent-encoded when converting from file path\n// to URL:\n// - %: The percent character is the only character not encoded by the\n//        `pathname` setter.\n// - \\: Backslash is encoded on non-windows platforms since it's a valid\n//      character but the `pathname` setters replaces it by a forward slash.\n// - LF: The newline character is stripped out by the `pathname` setter.\n//       (See whatwg/url#419)\n// - CR: The carriage return character is also stripped out by the `pathname`\n//       setter.\n// - TAB: The tab character is also stripped out by the `pathname` setter.\nconst percentRegEx = /%/g;\nconst backslashRegEx = /\\\\/g;\nconst newlineRegEx = /\\n/g;\nconst carriageReturnRegEx = /\\r/g;\nconst tabRegEx = /\\t/g;\n\nfunction encodePathChars(filepath) {\n  if (StringPrototypeIncludes(filepath\x2C '%'))\n    filepath = StringPrototypeReplace(filepath\x2C percentRegEx\x2C '%25');\n  // In posix\x2C backslash is a valid character in paths:\n  if (!isWindows && StringPrototypeIncludes(filepath\x2C '\\\\'))\n    filepath = StringPrototypeReplace(filepath\x2C backslashRegEx\x2C '%5C');\n  if (StringPrototypeIncludes(filepath\x2C '\\n'))\n    filepath = StringPrototypeReplace(filepath\x2C newlineRegEx\x2C '%0A');\n  if (StringPrototypeIncludes(filepath\x2C '\\r'))\n    filepath = StringPrototypeReplace(filepath\x2C carriageReturnRegEx\x2C '%0D');\n  if (StringPrototypeIncludes(filepath\x2C '\\t'))\n    filepath = StringPrototypeReplace(filepath\x2C tabRegEx\x2C '%09');\n  return filepath;\n}\n\nfunction pathToFileURL(filepath) {\n  const outURL = new URL('file://');\n  if (isWindows && StringPrototypeStartsWith(filepath\x2C '\\\\\\\\')) {\n    // UNC path format: \\\\server\\share\\resource\n    const paths = StringPrototypeSplit(filepath\x2C '\\\\');\n    if (paths.length <= 3) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Missing UNC resource path'\n      );\n    }\n    const hostname = paths[2];\n    if (hostname.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Empty UNC servername'\n      );\n    }\n    outURL.hostname = domainToASCII(hostname);\n    outURL.pathname = encodePathChars(\n      ArrayPrototypeJoin(ArrayPrototypeSlice(paths\x2C 3)\x2C '/'));\n  } else {\n    let resolved = path.resolve(filepath);\n    // path.resolve strips trailing slashes so we must add them back\n    const filePathLast = StringPrototypeCharCodeAt(filepath\x2C\n                                                   filepath.length - 1);\n    if ((filePathLast === CHAR_FORWARD_SLASH ||\n         (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&\n        resolved[resolved.length - 1] !== path.sep)\n      resolved += '/';\n    outURL.pathname = encodePathChars(resolved);\n  }\n  return outURL;\n}\n\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath))\n    return fileURLOrPath;\n  return fileURLToPath(fileURLOrPath);\n}\n\nfunction constructUrl(flags\x2C protocol\x2C username\x2C password\x2C\n                      host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = new URLContext();\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n\n  const url = ObjectCreate(URL.prototype);\n  url[context] = ctx;\n  const params = new URLSearchParams();\n  url[searchParams] = params;\n  params[context] = url;\n  initSearchParams(params\x2C query);\n  return url;\n}\nsetURLConstructor(constructUrl);\n\nmodule.exports = {\n  toUSVString\x2C\n  fileURLToPath\x2C\n  pathToFileURL\x2C\n  toPathIfFileURL\x2C\n  isURLInstance\x2C\n  URL\x2C\n  URLSearchParams\x2C\n  domainToASCII\x2C\n  domainToUnicode\x2C\n  urlToHttpOptions\x2C\n  formatSymbol: kFormat\x2C\n  searchParamsSymbol: searchParams\x2C\n  encodeStr\n};\n
code-source-info,0x1eea8f61945e,33,41449,41570,C0O41469C3O41474C9O41508C11O41529C12O41532C15O41539C19O41568,,
tick,0x7fff2042c000,138170,0,0x0,3,0x10f0ac650,0x1eea8f610d67,0x1eea8f610941,0x1eea8f610261,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
tick,0x7fff203b72be,138193,0,0x0,3,0x10f0ac650,0x1eea8f610d67,0x1eea8f610941,0x1eea8f610261,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
tick,0x7fff2035a803,138211,0,0x0,3,0x10f0ac650,0x1eea8f610d67,0x1eea8f610941,0x1eea8f610261,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
code-creation,LazyCompile,10,138227,0x1eea8f61c58e,17,isURLInstance node:internal/url:1492:23,0x1eeac205b0d8,~
code-source-info,0x1eea8f61c58e,33,41326,41423,C0O41346C3O41367C6O41392C12O41414C16O41421,,
code-creation,LazyCompile,10,138298,0x1eea8f61c6ee,81, node:internal/fs/utils:668:38,0x1eeaaa66a380,~
code-source-info,0x1eea8f61c6ee,78,18141,18411,C14O18174C22O18207C25O18207C31O18233C36O18264C49O18239C54O18233C55O18329C68O18329C74O18366C76O18395C78O18395C80O18410,,
code-creation,LazyCompile,10,138356,0x1eea8f61c8fe,110, node:internal/fs/utils:357:35,0x1eeaaa6699f8,~
code-source-info,0x1eea8f61c8fe,78,8569,9158,C16O8633C21O8686C26O8686C31O8780C37O8803C41O8831C45O8848C51O8848C60O8899C64O8920C69O8920C76O8965C77O8972C78O8992C94O8992C100O9106C104O9128C106O9128C107O9145C109O9156,,
code-creation,LazyCompile,10,138401,0x1eea8f61ca76,16,isUint8Array node:internal/util/types:13:22,0x1eea1f7d6d90,~
script-source,15,node:internal/util/types,'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n} = primordials;\n\nfunction isTypedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n}\n\nfunction isUint8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\n\nfunction isUint8ClampedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8ClampedArray';\n}\n\nfunction isUint16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint16Array';\n}\n\nfunction isUint32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint32Array';\n}\n\nfunction isInt8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int8Array';\n}\n\nfunction isInt16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int16Array';\n}\n\nfunction isInt32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int32Array';\n}\n\nfunction isFloat32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float32Array';\n}\n\nfunction isFloat64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float64Array';\n}\n\nfunction isBigInt64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigInt64Array';\n}\n\nfunction isBigUint64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigUint64Array';\n}\n\nmodule.exports = {\n  ...internalBinding('types')\x2C\n  isArrayBufferView: ArrayBufferIsView\x2C\n  isTypedArray\x2C\n  isUint8Array\x2C\n  isUint8ClampedArray\x2C\n  isUint16Array\x2C\n  isUint32Array\x2C\n  isInt8Array\x2C\n  isInt16Array\x2C\n  isInt32Array\x2C\n  isFloat32Array\x2C\n  isFloat64Array\x2C\n  isBigInt64Array\x2C\n  isBigUint64Array\n};\n\nlet isCryptoKey;\nlet isKeyObject;\n\nObjectDefineProperties(module.exports\x2C {\n  isKeyObject: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isKeyObject) {\n        ({ isKeyObject } = require('internal/crypto/keys'));\n      }\n\n      return isKeyObject(obj);\n    }\n  }\x2C\n  isCryptoKey: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isCryptoKey) {\n        ({ isCryptoKey } = require('internal/crypto/keys'));\n      }\n\n      return isCryptoKey(obj);\n    }\n  }\n});\n
code-source-info,0x1eea8f61ca76,15,257,342,C0O269C5O276C12O323C15O340,,
code-creation,LazyCompile,10,138680,0x1eea8f61ceee,61,splitRoot node:fs:2362:33,0x1eeaaa6614c0,~
code-source-info,0x1eea8f61ceee,77,62796,62988,C0O62821C2O62832C6O62826C11O62853C16O62857C24O62895C26O62891C31O62923C44O62930C49O62962C50O62842C55O62808C58O62973C60O62984,,
code-creation,LazyCompile,10,138727,0x1eea8f61d026,20,nextPart node:fs:2395:31,0x1eeaaa661560,~
code-source-info,0x1eea8f61d026,77,63703,63761,C0O63716C14O63723C19O63757,,
code-creation,LazyCompile,10,138879,0x1eea8f61d226,63,handleErrorFromBinding node:internal/fs/utils:340:32,0x1eeaaa6699a8,~
code-source-info,0x1eea8f61d226,78,7930,8428,C0O7948C6O8011C11O8011C16O8033C24O8033C29O8090C31O8090C32O8115C38O8343C43O8370C51O8343C56O8416C60O8406C62O8427,,
code-creation,LazyCompile,10,138927,0x1eea8f61d376,34,isFileType node:fs:205:20,0x1eeaaa65f150,~
code-source-info,0x1eea8f61d376,77,5285,5526,C0O5419C2O5424C6O5431C10O5465C15O5472C20O5488C22O5503C24O5501C30O5511C33O5524,,
tick,0x7fff203bad22,139078,1,0x10ea2a980,6,0x10ebf8f80,0x1eea8f610f7d,0x1eea8f610941,0x1eea8f610261,0x1eea8f60fe5c,0x1eea8f60fa07,0x1eea4787e261
code-creation,LazyCompile,10,139135,0x1eea8f61d5ae,72,encodeRealpathResult node:fs:2371:30,0x1eeaaa661510,~
code-source-info,0x1eea8f61d5ae,77,63022,63280,C0O63044C4O63069C10O63089C17O63098C22O63114C24O63128C25O63148C30O63155C35O63155C41O63183C48O63192C53O63212C55O63228C56O63251C61O63268C66O63251C71O63278,,
code-creation,LazyCompile,10,139214,0x1eea8f61d75e,109,shouldUseESMLoader node:internal/modules/run_main:26:28,0x1eea8f60e810,~
code-source-info,0x1eea8f61d75e,114,739,1299,C0O773C8O773C13O816C15O836C16O848C17O891C25O891C30O948C32O980C37O996C38O1008C39O1056C45O1072C51O1072C58O1119C59O1131C60O1134C66O1151C72O1151C79O1198C80O1211C81O1226C86O1226C91O1256C93O1274C98O1279C105O1284C108O1297,,
code-creation,LazyCompile,10,139321,0x1eea8f61d97e,129,readPackageScope node:internal/modules/cjs/loader:321:26,0x1eea2da9f348,~
code-source-info,0x1eea8f61d97e,99,8919,9437,C0O8962C7O8996C10O8962C16O9008C18O9035C25O9090C28O9052C34O9100C47O9112C54O9168C61O9207C66O9211C70O9172C77O9236C78O9249C79O9268C84O9292C86O9290C90O9268C95O9302C97O9313C104O9334C110O9353C116O9370C117O9397C119O9397C124O9026C127O9422C128O9435,,
code-creation,LazyCompile,10,139421,0x1eea8f61dcde,234,readPackage node:internal/modules/cjs/loader:290:21,0x1eea2da9f2f8,~
code-source-info,0x1eea8f61dcde,99,8102,8892,C0O8137C5O8142C13O8142C20O8200C25O8217C30O8217C36O8234C38O8262C40O8278C41O8297C46O8315C51O8315C57O8353C63O8366C72O8392C77O8402C79O8432C84O8449C91O8449C97O8475C98O8488C102O8521C107O8521C112O8559C117O8580C125O8605C133O8633C141O8664C149O8692C160O8708C165O8725C170O8725C176O8754C178O8770C190O8791C195O8798C199O8814C207O8843C213O8854C220O8865C224O8861C227O8824C231O8878C233O8878,,
code-creation,LazyCompile,10,139519,0x1eea8f61dfe6,199,read node:internal/modules/package_json_reader:16:14,0x1eea2daa4e98,~
code-source-info,0x1eea8f61dfe6,100,292,954,C0O307C5O317C10O317C17O338C22O351C27O351C32O365C33O412C40O440C43O440C48O412C53O384C59O395C66O489C73O491C79O499C86O544C92O544C97O525C102O575C106O607C112O643C115O654C127O704C132O738C142O652C148O774C154O821C159O821C164O852C169O861C174O861C180O907C185O913C190O913C196O938C198O952,,
code-creation,LazyCompile,10,139811,0x1eea8f61e4de,619,Module._load node:internal/modules/cjs/loader:757:24,0x1eea2da9fea8,~
code-source-info,0x1eea8f61e4de,99,23208,26126,C0O23242C2O23271C6O23289C14O23349C23O23289C28O23579C42O23590C47O23622C54O23642C58O23675C60O23732C63O23739C70O23745C74O23763C76O23805C88O23805C93O23875C99O23893C102O23900C106O23943C107O23972C111O23980C112O23995C119O24023C121O24081C124O24088C138O24088C144O24133C152O24137C159O24228C167O24228C173O24283C178O24283C184O24318C189O24329C198O24361C205O24367C210O24361C211O24434C215O24442C216O24471C219O24478C226O24484C230O24498C232O24536C244O24536C249O24602C255O24644C260O24658C265O24658C271O24683C273O24727C279O24743C282O24750C286O24793C287O24800C288O24825C294O24872C298O24880C299O24906C304O24906C310O24945C315O24952C324O24987C328O24995C329O25081C344O25097C350O25130C354O25148C359O25167C363O25181C365O25191C369O25205C372O25212C379O25229C383O25241C387O25273C394O25321C398O25352C403O25377C409O25377C414O25397C426O25403C427O25430C432O25449C436O25463C444O25470C446O25487C450O25523C458O25551C460O25604C467O25610C475O25630C481O25634C487O25684C493O25684C499O25735C501O25745C506O25767C522O25767C529O25861C537O25888C541O25903C547O25888C555O25930C559O25958C565O25930C573O25988C575O25967C580O26034C586O26062C594O26071C598O26034C614O26116C618O26124,,
code-creation,LazyCompile,10,140012,0x1eea8f61ec46,812,Module._resolveFilename node:internal/modules/cjs/loader:848:35,0x1eea2da9ff30,~
code-source-info,0x1eea8f61ec46,99,26163,29160,C0O26202C10O26206C19O26259C23O26272C29O26272C36O26309C38O26324C39O26336C41O26346C51O26405C57O26430C63O26409C69O26465C79O26465C88O26519C96O26519C105O26576C111O26589C119O26589C128O26645C136O26645C142O26697C144O26739C151O26788C164O26788C170O26819C173O26853C175O26868C181O26874C185O26858C190O26920C198O26925C202O26940C206O26966C212O26966C217O26957C221O27020C225O27027C231O27027C238O27093C240O27112C244O27098C249O27139C257O27185C262O27144C269O27205C277O27242C282O27205C287O27121C292O27080C295O26883C300O26840C305O27301C311O27330C315O27345C321O27345C330O27402C340O27459C348O27408C353O27402C356O27488C360O27503C366O27503C373O27548C380O27558C389O27576C390O27587C397O27591C402O27620C406O27644C412O27620C420O27675C428O27679C441O27724C447O27766C453O27797C457O27818C463O27797C471O27863C478O27766C485O27895C491O27921C500O27731C505O27927C519O27960C523O27966C531O27971C536O28011C542O28017C546O28011C547O28058C549O28058C550O28155C554O28155C559O28205C563O28205C569O28237C571O28278C573O28286C578O28313C586O28320C592O28333C599O28339C607O28339C612O28295C616O28379C620O28386C628O28407C632O28427C634O28447C635O28533C639O28540C657O28540C663O28584C665O28598C667O28614C668O28638C671O28662C676O28674C680O28732C686O28772C695O28791C701O28732C706O28693C712O28713C718O28713C724O28644C727O28816C733O28839C745O28870C752O28877C757O28888C759O28906C766O28947C774O28947C779O28931C783O29058C791O29058C797O29080C799O29089C803O29113C805O29130C809O29148C811O29148,,
code-creation,LazyCompile,10,140124,0x1eea8f61f206,28,canBeRequiredByUsers node:internal/bootstrap/loaders:240:30,0x1eeab58cf658,~
code-source-info,0x1eea8f61f206,9,7353,7449,C0O7376C5O7389C10O7393C15O7393C21O7406C23O7424C27O7445,,
code-creation,LazyCompile,10,140211,0x1eea8f61f4be,327,Module._resolveLookupPaths node:internal/modules/cjs/loader:667:38,0x1eea2da9fd78,~
code-source-info,0x1eea8f61f4be,99,19964,21141,C0O19986C5O20003C10O20003C17O20040C25O20040C30O20084C31O20096C32O20139C39O20143C47O20177C52O20203C59O20210C66O20223C72O20223C80O20257C87O20274C93O20274C101O20308C108O20327C114O20340C120O20340C128O20374C133O20405C138O20422C145O20432C152O20439C161O20457C166O20493C171O20465C177O20519C191O20519C196O20583C202O20590C212O20609C213O20656C217O20679C223O20693C229O20864C234O20876C248O20876C253O20931C255O20948C256O20956C264O21023C272O20956C277O21049C286O21050C289O21055C294O21070C299O21055C311O21084C319O21084C324O21122C326O21139,,
code-creation,LazyCompile,10,140284,0x1eea8f61f786,104,logger node:internal/util/debuglog:96:18,0x1eeac207ad30,~
code-source-info,0x1eea8f61f786,40,2899,3124,C0O2899C3O2931C30O2955C35O2962C38O2970C39O2985C45O3002C49O2992C53O3007C54O3022C60O3039C66O3048C70O3029C75O3053C76O3069C80O3076C87O3089C92O3085C98O3076C103O3114,,
tick,0x7fff203b4afe,140338,0,0x0,3,0x10f0ac650,0x1eea8f61f57d,0x1eea8f61edb4,0x1eea8f61e568,0x1eea8f60fa37,0x1eea4787e261
code-creation,LazyCompile,10,140367,0x1eea8f61f8de,3, node:internal/per_context/primordials:276:21,0x1eeab58c9950,~
code-source-info,0x1eea8f61f8de,6,7920,7949,C0O7931C2O7943,,
code-creation,LazyCompile,10,140424,0x1eea8f61f9b6,155,debug node:internal/util/debuglog:76:15,0x1eeac207ac90,~
code-source-info,0x1eea8f61f9b6,40,2357,2781,C0O2357C3O2376C6O2376C9O2484C16O2505C22O2492C30O2490C36O2524C42O2560C47O2563C50O2560C54O2588C81O2612C86O2619C89O2627C90O2642C96O2659C100O2649C104O2664C105O2679C111O2696C117O2705C121O2686C126O2710C127O2726C131O2733C138O2746C143O2742C149O2733C154O2771,,
code-creation,LazyCompile,10,140471,0x1eea8f61fb86,41,init node:internal/util/debuglog:72:16,0x1eeac207ac40,~
code-source-info,0x1eea8f61fb86,40,2259,2342,C0O2268C10O2274C14O2272C16O2311C26O2321C33O2319C40O2341,,
code-creation,LazyCompile,10,140540,0x1eea8f61fc76,2,testEnabled node:internal/util/debuglog:32:19,0x1eea2da916a8,~
code-source-info,0x1eea8f61fc76,40,973,984,C0O979C1O984,,
code-creation,LazyCompile,10,140597,0x1eea8f61fe0e,116,debuglogImpl node:internal/util/debuglog:49:22,0x1eeac207aa78,~
code-source-info,0x1eea8f61fe0e,40,1451,1995,C0O1451C9O1470C18O1484C23O1511C34O1544C39O1552C43O1544C45O1563C55O1563C59O1595C71O1606C75O1611C83O1934C97O1952C99O1950C103O1970C112O1987C115O1993,,
code-creation,LazyCompile,10,140640,0x1eea8f61ffc6,10, node:internal/modules/cjs/loader:272:66,0x1eea2da9fb78,~
code-source-info,0x1eea8f61ffc6,99,7709,7734,C0O7721C2O7727C9O7733,,
code-creation,LazyCompile,10,140673,0x1eea8f620076,2,noop node:internal/util/debuglog:47:14,0x1eeac207aa28,~
code-source-info,0x1eea8f620076,40,1419,1427,C1O1426,,
code-creation,LazyCompile,10,140715,0x1eea8f6201b6,76,trySelfParentPath node:internal/modules/cjs/loader:427:27,0x1eea2da9f528,~
code-source-info,0x1eea8f6201b6,99,12270,12533,C0O12283C4O12296C5O12309C6O12324C12O12354C16O12363C17O12384C24O12387C29O12410C36O12413C44O12455C47O12470C52O12470C59O12478C62O12483C66O12476C69O12487C72O12508C73O12521C75O12532,,
code-creation,LazyCompile,10,140791,0x1eea8f6203f6,235,trySelf node:internal/modules/cjs/loader:441:17,0x1eea2da9f578,~
code-source-info,0x1eea8f6203f6,99,12551,13384,C0O12577C4O12594C5O12607C6O12648C9O12648C17O12625C22O12636C27O12686C31O12702C37O12725C38O12738C39O12756C47O12775C48O12788C49O12796C51O12829C55O12821C60O12841C65O12867C70O12913C82O12871C89O12929C94O12947C97O12981C102O12986C107O12947C112O12945C118O13010C119O13023C123O13041C128O13070C133O13099C138O13121C142O13099C149O13163C152O13163C159O13190C168O13070C183O13048C188O13236C200O13257C203O13263C210O13268C215O13302C222O13346C226O13308C231O13302C232O13370C234O13370,,
code-creation,LazyCompile,10,140872,0x1eea8f62068e,62,loadNativeModule node:internal/modules/cjs/helpers:44:26,0x1eea2da99b30,~
code-source-info,0x1eea8f62068e,98,1151,1431,C0O1187C5O1200C10O1204C15O1204C21O1221C26O1228C35O1258C43O1258C48O1384C53O1384C57O1414C59O1425C61O1430,,
code-creation,LazyCompile,10,140942,0x1eea8f620f4e,94,Module node:internal/modules/cjs/loader:172:16,0x1eea2da9f208,~
code-source-info,0x1eea8f620f4e,99,5284,5521,C14O5306C16O5314C20O5322C22O5334C25O5339C30O5339C35O5332C39O5354C40O5367C44O5375C49O5393C54O5393C60O5414C71O5414C76O5453C77O5467C81O5477C82O5489C86O5500C88O5514C93O5520,,
code-creation,LazyCompile,10,141018,0x1eea8f621186,162,dirname node:path:1275:10,0x1eeac2068630,~
code-source-info,0x1eea8f621186,35,38742,39411,C0O38755C8O38755C13O38798C19O38805C24O38818C26O38829C27O38850C34O38850C42O38889C44O38885C48O38923C51O38950C53O38978C57O38985C61O38992C63O38992C68O39011C73O39015C81O39054C83O39050C88O39084C92O39115C97O39134C101O39221C103O39000C108O38960C111O39262C113O39270C118O39284C128O39311C129O39316C135O39335C140O39348C142O39360C143O39365C156O39372C161O39407,,
code-creation,LazyCompile,10,141115,0x1eea8f62139e,45,updateChildren node:internal/modules/cjs/loader:165:24,0x1eea2da9f1b8,~
code-source-info,0x1eea8f62139e,99,5049,5222,C0O5092C7O5098C15O5112C19O5130C23O5138C26O5138C33O5184C38O5184C44O5221,,
code-creation,LazyCompile,10,141191,0x1eea8f621596,246,Module.load node:internal/modules/cjs/loader:969:33,0x1eea2da9ffc0,~
code-source-info,0x1eea8f621596,99,30265,31078,C0O30280C8O30326C16O30280C21O30334C26O30347C32O30334C36O30358C38O30372C42O30386C45O30406C52O30423C55O30428C60O30428C66O30406C71O30397C75O30469C78O30469C83O30546C91O30550C101O30603C106O30614C112O30628C124O30634C129O30628C130O30674C133O30681C140O30692C144O30703C150O30723C151O30735C155O30764C160O30773C165O30875C170O30910C175O30921C187O30961C192O30968C197O30968C204O30982C206O30980C211O31014C216O31023C221O31023C228O31048C233O31057C238O31057C245O31077,,
code-creation,LazyCompile,10,141282,0x1eea8f62188e,183,Module._nodeModulePaths node:internal/modules/cjs/loader:629:37,0x1eea2da9fce8,~
code-source-info,0x1eea8f62188e,99,18791,19922,C0O18846C5O18858C10O18858C17O19037C19O19046C24O19061C28O19086C29O19301C32O19327C36O19334C40O19343C42O19358C47O19368C48O19368C53O19400C58O19400C64O19442C66O19455C68O19451C73O19485C75O19495C77O19491C82O19512C89O19563C100O19563C108O19599C112O19512C117O19638C120O19656C124O19676C126O19682C131O19700C138O19711C144O19715C149O19737C156O19769C159O19376C164O19309C167O19856C175O19856C180O19905C182O19918,,
code-creation,LazyCompile,10,141392,0x1eea8f621bc6,98,findLongestRegisteredExtension node:internal/modules/cjs/loader:413:40,0x1eea2da9f4d8,~
code-source-info,0x1eea8f621bc6,99,11813,12242,C0O11841C5O11846C10O11846C16O11872C18O11896C20O11922C22O11990C36O11943C44O11990C49O12004C51O12023C55O12032C56O12042C61O12049C63O12096C68O12115C74O12154C77O12165C84O12176C89O12196C91O12220C92O11927C95O12227C97O12240,,
code-creation,LazyCompile,10,141496,0x1eea8f621da6,353,basename node:path:1306:11,0x1eeac2068680,~
code-source-info,0x1eea8f621da6,35,39512,41904,C0O39530C4O39559C12O39559C17O39591C25O39591C30O39638C32O39655C35O39682C37O39693C41O39722C47O39729C52O39740C57O39755C61O39747C66O39771C68O39779C73O39797C75O39807C76O39831C80O39838C84O39872C87O39900C91O39907C95O39914C96O39914C101O39948C106O39948C112O39992C114O40005C116O40001C121O40175C125O40208C127O40218C131O40235C135O40281C137O40302C142O40468C144O40502C146O40523C150O40550C151O40561C156O40632C158O40645C161O40645C166O40641C171O40701C178O40714C183O40850C190O41013C193O41040C198O39922C203O39882C206O41115C208O41125C213O41142C220O41177C222O41185C227O41212C232O41226C246O41233C251O41272C252O41301C256O41308C260O41315C261O41315C266O41334C271O41338C279O41377C281O41373C286O41541C290O41572C292O41582C296O41597C300O41627C302O41635C307O41755C309O41785C311O41793C315O41323C320O41283C323O41817C325O41825C330O41839C332O41849C333O41854C347O41861C352O41900,,
tick,0x7fff20212731,141597,0,0x0,2,0x10f0ac650,0x1eea8f621626,0x1eea8f61e677,0x1eea8f60fa37,0x1eea4787e261
code-creation,LazyCompile,10,141655,0x1eea8f622266,485,Module._extensions..js node:internal/modules/cjs/loader:1110:37,0x1eea2daa0160,~
code-source-info,0x1eea8f622266,99,34668,36368,C0O34767C5O34781C10O34781C16O34800C18O34811C25O34821C34O34854C39O34866C40O34880C46O34908C51O34921C60O34921C67O34959C76O34963C83O35023C86O35023C91O35112C96O35119C103O35125C113O35132C118O35169C123O35187C128O35187C134O35225C139O35231C147O35273C152O35278C157O35290C167O35278C174O35335C179O35335C184O35376C203O35376C209O35547C212O35558C219O35564C224O35592C229O35630C235O35648C244O35648C254O35643C257O35709C261O35755C268O35789C271O35814C279O35821C283O35863C293O35821C300O35789C314O35755C321O35891C325O35948C335O35948C345O35917C352O35926C359O36011C365O36023C367O36058C376O36058C384O36104C387O36098C391O36136C403O36153C416O36162C429O36189C438O36220C443O36189C459O36243C464O36243C469O36308C471O36308C472O36338C477O36338C484O36367,,
code-creation,LazyCompile,10,141792,0x1eea8f6226c6,376,readFileSync node:fs:450:22,0x1eeaaa65f608,~
code-source-info,0x1eea8f6226c6,77,11355,12732,C0O11375C5O11396C10O11385C17O11440C22O11440C27O11494C35O11512C38O11515C43O11538C56O11515C62O11569C65O11569C71O11611C76O11629C79O11611C88O11645C95O11666C97O11675C99O11721C101O11766C102O11775C107O11788C112O11817C124O11826C130O11874C132O11888C133O11897C138O11921C143O11977C159O11933C165O11991C167O11998C174O12038C175O12032C182O12045C187O11910C192O12169C197O12185C207O12185C213O12210C232O12222C238O12272C239O12286C244O12303C249O12338C256O12338C263O12303C268O12374C270O12381C277O12415C278O12415C283O12069C286O12430C290O12449C295O12452C300O12452C305O12470C306O12479C311O12541C316O12557C321O12557C330O12588C332O12596C337O12626C344O12626C351O12660C357O12686C362O12703C367O12686C373O12716C375O12730,,
code-creation,LazyCompile,10,141888,0x1eea8f6229e6,30,isEncoding node:buffer:529:40,0x1eea1f7e5138,~
code-source-info,0x1eea8f6229e6,18,14774,14906,C0O14789C6O14837C12O14844C20O14862C23O14862C28O14890C29O14904,,
code-creation,LazyCompile,10,141927,0x1eea8f622aee,30,normalizeEncoding node:internal/util:160:27,0x1eeab58e9f18,~
code-source-info,0x1eea8f622aee,12,4206,4311,C0O4216C7O4239C14O4257C19O4270C21O4284C22O4287C25O4294C29O4309,,
code-creation,LazyCompile,10,141961,0x1eea8f622bd6,9,isUint32 node:internal/validators:39:18,0x1eea1f7d9d48,~
code-source-info,0x1eea8f622bd6,17,777,822,C0O789C2O813C5O802C8O820,,
code-creation,LazyCompile,10,142009,0x1eea8f622d2e,113,openSync node:fs:576:18,0x1eeaaa65f7f0,~
code-source-info,0x1eea8f622d2e,77,14426,14805,C0O14450C5O14457C11O14503C16O14503C21O14527C37O14534C44O14585C51O14587C58O14612C63O14620C70O14625C73O14636C78O14636C95O14620C101O14758C106O14758C110O14789C112O14803,,
code-creation,LazyCompile,10,142054,0x1eea8f622eae,37, node:internal/fs/utils:680:42,0x1eeaaa66a3d0,~
code-source-info,0x1eea8f622eae,78,18456,18591,C14O18511C19O18511C24O18545C29O18545C34O18577C36O18589,,
code-creation,LazyCompile,10,142130,0x1eea8f623286,515,stringToFlags node:internal/fs/utils:555:23,0x1eeaaa66a1f0,~
code-source-info,0x1eea8f623286,78,15047,16281,C14O15075C20O15112C25O15112C30O15144C32O15157C33O15165C38O15190C42O15206C43O15214C202O15246C206O15262C207O15312C214O15330C216O15328C219O15337C220O15354C224O15368C225O15420C232O15436C234O15434C237O15443C238O15460C245O15477C247O15475C253O15487C255O15485C258O15496C259O15546C266O15563C268O15561C274O15573C276O15571C282O15584C284O15582C287O15591C288O15609C295O15626C297O15624C303O15636C305O15634C308O15643C309O15693C316O15710C318O15708C324O15720C326O15718C332O15729C334O15727C337O15736C338O15753C345O15771C347O15769C353O15781C355O15779C358O15790C359O15840C366O15858C368O15856C374O15868C376O15866C382O15879C384O15877C387O15886C388O15936C395O15954C397O15952C403O15964C405O15962C411O15975C413O15973C416O15982C417O16000C424O16018C426O16016C432O16028C434O16026C437O16035C438O16085C445O16103C447O16101C453O16113C455O16111C461O16122C463O16120C466O16129C467O16179C474O16197C476O16195C482O16207C484O16205C490O16216C492O16214C495O16223C496O16231C509O16237C514O16231,,
code-creation,LazyCompile,10,142257,0x1eea8f623676,97,parseFileMode node:internal/validators:58:23,0x1eea1f7d9d98,~
code-source-info,0x1eea8f623676,17,1468,1764,C0O1491C11O1508C17O1545C24O1570C27O1550C34O1596C41O1641C52O1602C57O1596C58O1662C66O1670C73O1703C89O1703C94O1749C96O1762,,
code-creation,LazyCompile,10,142326,0x1eea8f623846,206, node:internal/validators:83:3,0x1eea1f7d9e58,~
code-source-info,0x1eea8f623846,17,2236,2817,C36O2377C39O2382C45O2406C51O2447C67O2453C72O2447C73O2516C78O2521C84O2555C100O2561C105O2555C106O2624C116O2663C129O2676C142O2630C147O2624C148O2701C150O2711C157O2726C162O2741C172O2780C185O2793C198O2747C203O2741C205O2816,,
code-creation,LazyCompile,10,142368,0x1eea8f623a0e,9,isInt32 node:internal/validators:35:17,0x1eea1f7d9990,~
code-source-info,0x1eea8f623a0e,17,715,758,C0O727C2O751C5O740C8O756,,
code-creation,LazyCompile,10,142489,0x1eea8f623b16,66,tryStatSync node:fs:404:21,0x1eeaaa65f518,~
code-source-info,0x1eea8f623b16,77,10330,10540,C0O10361C2O10381C7O10389C22O10389C28O10433C36O10457C38O10473C43O10476C48O10476C53O10495C58O10501C62O10495C63O10525C65O10538,,
code-creation,LazyCompile,10,142561,0x1eea8f623c46,17,allocUnsafe node:buffer:372:42,0x1eea1f7e4cb0,~
code-source-info,0x1eea8f623c46,18,10871,10926,C0O10882C5O10882C9O10902C12O10909C16O10924,,
code-creation,LazyCompile,10,142599,0x1eea8f623d4e,54, node:buffer:348:36,0x1eea1f7e4bf8,~
code-source-info,0x1eea8f623d4e,18,10169,10324,C0O10183C8O10183C13O10215C14O10226C21O10242C23O10239C28O10261C33O10293C46O10267C51O10261C53O10323,,
code-creation,LazyCompile,10,142634,0x1eea8f623e76,30,validateNumber node:internal/validators:122:24,0x1eea1f7d9f98,~
code-source-info,0x1eea8f623e76,17,3532,3641,C0O3550C6O3585C22O3591C27O3585C29O3640,,
code-creation,LazyCompile,10,142682,0x1eea8f623f8e,119,allocate node:buffer:397:18,0x1eea1f7e4e00,~
code-source-info,0x1eea8f623f8e,18,11573,11888,C0O11584C1O11593C6O11605C11O11612C16O11629C17O11636C20O11655C24O11664C27O11645C32O11678C34O11690C39O11701C41O11699C44O11687C49O11720C52O11720C55O11748C62O11763C67O11774C75O11748C81O11797C88O11811C94O11808C100O11821C103O11821C106O11838C108O11847C109O11854C114O11861C118O11886,,
code-creation,LazyCompile,10,142733,0x1eea8f624156,71,createUnsafeBuffer node:internal/buffer:1059:28,0x1eea1f7f1c30,~
code-source-info,0x1eea8f624156,19,30321,30430,C0O30332C8O30344C15O30361C22O30368C39O30408C48O30420C70O30429,,
tick,0x10eecb730,142870,0,0x0,0,0x10f0bcdc0,0x1eea8f62415e,0x1eea8f624000,0x1eea8f623c52,0x1eea8f622795,0x1eea8f6222a2,0x1eea8f621626,0x1eea8f61e677,0x1eea8f60fa37,0x1eea4787e261
code-creation,LazyCompile,10,143246,0x1eea8f6242ae,86,tryReadSync node:fs:429:21,0x1eeaaa65f5b8,~
code-source-info,0x1eea8f6242ae,77,10875,11110,C0O10924C2O10936C7O10959C12O10974C29O10974C35O11010C47O11016C48O11043C55O11057C57O11067C62O11070C67O11070C83O11091C85O11108,,
code-creation,LazyCompile,10,143335,0x1eea8f624496,239,readSync node:fs:684:18,0x1eeaaa65f8c0,~
code-source-info,0x1eea8f624496,77,17128,18059,C0O17128C2O17171C7O17176C13O17199C18O17199C22O17240C29O17247C34O17318C40O17340C52O17352C58O17368C64O17380C70O17410C75O17436C80O17463C93O17463C98O17508C105O17524C106O17535C111O17548C112O17557C113O17576C119O17587C124O17600C140O17606C145O17600C146O17728C151O17776C162O17728C167O17792C172O17818C176O17836C184O17836C189O17891C191O17912C196O17920C221O17920C227O18012C232O18012C236O18043C238O18057,,
code-creation,LazyCompile,10,143395,0x1eea8f6246e6,52, node:internal/fs/utils:686:40,0x1eeaaa66a420,~
code-source-info,0x1eea8f6246e6,78,18634,18755,C14O18663C22O18667C29O18691C30O18700C31O18708C44O18708C49O18743C51O18753,,
code-creation,LazyCompile,10,143452,0x1eea8f624856,51, node:internal/validators:190:40,0x1eea1f7da1c0,~
code-source-info,0x1eea8f624856,17,5662,5892,C14O5695C19O5700C25O5733C30O5764C43O5739C48O5733C50O5891,,
code-creation,LazyCompile,10,143516,0x1eea8f6249ae,151, node:internal/validators:72:3,0x1eea1f7d9e08,~
code-source-info,0x1eea8f6249ae,17,1809,2190,C12O1829C25O1859C32O1892C38O1929C54O1935C59O1929C60O1988C65O1993C71O2023C87O2029C92O2023C93O2082C95O2092C102O2107C107O2120C117O2159C130O2172C143O2126C148O2120C150O2189,,
code-creation,LazyCompile,10,143587,0x1eea8f624bb6,103, node:internal/fs/utils:636:3,0x1eeaaa66a2e0,~
code-source-info,0x1eea8f624bb6,78,17258,17637,C0O17298C1O17309C6O17322C22O17328C27O17322C28O17386C29O17397C34O17410C50O17416C55O17410C56O17474C58O17485C64O17494C69O17518C82O17607C95O17524C100O17518C102O17636,,
code-creation,LazyCompile,10,143696,0x1eea8f624ebe,151, node:internal/fs/utils:886:42,0x1eeaaa66a740,~
code-source-info,0x1eea8f624ebe,78,23965,24523,C0O23989C6O24029C14O24029C21O24077C27O24117C32O24140C35O24135C37O24132C47O24166C53O24173C56O24160C61O24188C77O24271C80O24266C98O24291C104O24298C117O24194C122O24188C125O24371C143O24377C148O24371C150O24522,,
code-creation,LazyCompile,10,143793,0x1eea8f625076,47,closeSync node:fs:526:19,0x1eeaaa65f718,~
code-source-info,0x1eea8f625076,77,13295,13417,C0O13304C5O13309C11O13344C13O13350C18O13358C31O13358C36O13387C41O13387C46O13416,,
code-creation,LazyCompile,10,143902,0x1eea8f62522e,257,concat node:buffer:535:32,0x1eea1f7e51a8,~
code-source-info,0x1eea8f62522e,18,14987,16119,C0O15006C8O15006C13O15047C19O15054C24O15065C29O15072C34O15089C35O15093C39O15125C42O15154C44O15166C48O15159C53O15187C55O15195C59O15199C65O15217C67O15231C71O15235C83O15175C88O15141C93O15272C101O15272C106O15328C109O15335C114O15335C120O15368C122O15386C124O15398C128O15391C133O15429C135O15433C139O15442C144O15447C150O15603C160O15651C178O15687C184O15609C189O15603C190O15703C195O15747C209O15710C218O15407C223O15373C226O15832C228O15840C233O16047C249O16047C254O16103C256O16117,,
code-creation,LazyCompile,10,143969,0x1eea8f6254fe,95, node:internal/validators:167:39,0x1eea1f7da0f8,~
code-source-info,0x1eea8f6254fe,17,4966,5244,C16O5002C21O5007C27O5034C43O5040C48O5034C49O5104C56O5111C61O5145C66O5168C71O5185C87O5191C92O5185C94O5243,,
code-creation,LazyCompile,10,144033,0x1eea8f625676,162,toString node:buffer:782:46,0x1eea1f7e6b38,~
code-source-info,0x1eea8f625676,18,23264,23826,C0O23264C2O23305C8O23312C13O23337C20O23355C25O23337C31O23363C32O23388C37O23399C38O23409C43O23419C48O23437C50O23447C55O23459C57O23469C58O23481C65O23496C71O23525C76O23536C83O23558C90O23571C92O23579C97O23593C99O23603C100O23607C104O23651C109O23651C115O23673C116O23689C119O23689C124O23717C126O23744C133O23750C138O23744C139O23800C156O23800C161O23824,,
tick,0x10edffaab,144090,0,0x0,0,0x10ede27e0,0x1eea8f625696,0x1eea8f622835,0x1eea8f6222a2,0x1eea8f621626,0x1eea8f61e677,0x1eea8f60fa37,0x1eea4787e261
code-creation,Function,11,144169,0x11b704d20,1148,readPackageScope node:internal/modules/cjs/loader:321:26,0x1eea2da9f348,^
code-source-info,0x11b704d20,99,8919,9437,,,
code-creation,Function,11,144208,0x11b705200,1284,resolve node:path:1091:10,0x1eeac2068450,^
code-source-info,0x11b705200,35,33782,34692,,,
code-creation,Function,11,144227,0x11b705780,44,toNamespacedPath node:path:1266:19,0x1eeac20685e0,^
code-source-info,0x11b705780,35,38609,38669,,,
code-creation,Function,11,144261,0x11b705820,272,validateString node:internal/validators:117:24,0x1eea1f7d9ef8,^
code-source-info,0x11b705820,17,3398,3507,,,
code-creation,Function,11,144293,0x11b7059a0,1452,Module._nodeModulePaths node:internal/modules/cjs/loader:629:37,0x1eea2da9fce8,^
code-source-info,0x11b7059a0,99,18791,19922,,,
code-creation,LazyCompile,10,144398,0x1eea8f625db6,499,Module._compile node:internal/modules/cjs/loader:1055:37,0x1eea2daa00d0,~
code-source-info,0x1eea8f625db6,99,32760,34601,C0O32788C2O32805C4O32818C11O32828C20O32846C25O32858C30O32887C35O32906C40O32915C45O32915C51O32951C56O32958C61O32967C66O32967C72O33011C86O33011C91O33083C103O33083C109O33144C111O33152C119O33156C128O33199C135O33220C141O33314C144O33326C151O33330C159O33361C162O33383C170O33408C177O33412C185O33383C193O33374C203O33605C210O33612C215O33625C221O33625C226O33612C231O33605C237O33689C242O33702C248O33769C256O33790C262O33821C264O33817C269O33843C273O33858C279O33872C285O33891C290O33919C295O33969C300O33974C305O33974C311O34011C316O34011C322O34055C324O34086C329O34115C330O34141C333O34149C339O34166C344O34173C349O34185C357O34183C363O34202C367O34230C388O34239C396O34375C401O34414C410O34452C419O34461C428O34470C437O34478C446O34488C459O34384C465O34505C469O34531C475O34541C481O34558C486O34565C490O34575C496O34585C498O34599,,
code-creation,LazyCompile,10,144516,0x1eea8f626326,229,maybeCacheSourceMap node:internal/source_map/source_map_cache:74:29,0x1eea2da96c98,~
code-source-info,0x1eea8f626326,96,2239,3273,C0O2308C3O2308C7O2334C10O2348C15O2352C23O2372C25O2392C26O2399C30O2412C35O2423C44O2421C54O2564C64O2574C69O2564C73O2586C74O2593C75O2614C80O2640C85O2614C91O2717C93O2747C96O2775C101O2782C106O2747C112O2817C117O2837C122O2844C127O2866C131O2897C136O2915C141O2919C148O2948C155O2979C165O3009C171O3023C175O2915C183O3149C188O3167C193O3171C201O3204C211O3234C217O3248C221O3167C228O3272,,
code-creation,LazyCompile,10,144587,0x1eea8f626d86,31,getSourceMapsEnabled node:internal/source_map/source_map_cache:43:30,0x1eea2da96bf8,~
code-source-info,0x1eea8f626d86,96,1418,1563,C0O1425C6O1468C11O1489C17O1489C22O1468C26O1536C30O1561,,
code-creation,LazyCompile,10,144639,0x1eea8f626efe,100,setSourceMapsEnabled node:internal/source_map/source_map_cache:50:30,0x1eea2da96c48,~
code-source-info,0x1eea8f626efe,96,1594,2209,C0O1604C8O1604C13O1709C19O1709C24O1648C29O1674C34O1738C38O1767C42O1822C48O1822C53O1796C58O1878C64O1936C70O2095C76O2095C81O2068C86O2127C90O2183C92O2201C99O2208,,
code-creation,LazyCompile,10,144685,0x1eea8f627076,30,validateBoolean node:internal/validators:138:25,0x1eea1f7da058,~
code-source-info,0x1eea8f627076,17,4042,4153,C0O4060C6O4096C22O4102C27O4096C29O4152,,
code-creation,LazyCompile,10,144760,0x1eea8f62746e,165,wrapSafe node:internal/modules/cjs/loader:1017:18,0x1eea2da9f758,~
code-source-info,0x1eea8f62746e,99,31692,32552,C0O31692C9O31735C17O31770C22O31777C27O31777C33O31796C40O31806C45O31823C52O31840C56O31929C64O31806C70O32084C74O32101C81O32111C86O32127C98O32242C102O32258C113O32111C118O32427C130O32450C135O32462C142O32473C147O32502C157O32502C162O32536C164O32536,,
code-creation,LazyCompile,10,144911,0x1eea8f627c76,472,compileFunction node:vm:308:25,0x1eeaaa67bbe0,~
script-source,85,node:vm,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeUnshift\x2C\n  Symbol\x2C\n  PromiseReject\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst {\n  ContextifyScript\x2C\n  MicrotaskQueue\x2C\n  makeContext\x2C\n  isContext: _isContext\x2C\n  constants\x2C\n  compileFunction: _compileFunction\x2C\n  measureMemory: _measureMemory\x2C\n} = internalBinding('contextify');\nconst {\n  ERR_CONTEXT_NOT_INITIALIZED\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n} = require('internal/errors').codes;\nconst {\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst {\n  kVmBreakFirstLineSymbol\x2C\n  emitExperimentalWarning\x2C\n} = require('internal/util');\nconst kParsingContext = Symbol('script parsing context');\n\nclass Script extends ContextifyScript {\n  constructor(code\x2C options = {}) {\n    code = `${code}`;\n    if (typeof options === 'string') {\n      options = { filename: options };\n    } else {\n      validateObject(options\x2C 'options');\n    }\n\n    const {\n      filename = 'evalmachine.<anonymous>'\x2C\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      cachedData\x2C\n      produceCachedData = false\x2C\n      importModuleDynamically\x2C\n      [kParsingContext]: parsingContext\x2C\n    } = options;\n\n    validateString(filename\x2C 'options.filename');\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n    validateBoolean(produceCachedData\x2C 'options.produceCachedData');\n\n    // Calling `ReThrow()` on a native TryCatch does not generate a new\n    // abort-on-uncaught-exception check. A dummy try/catch in JS land\n    // protects against that.\n    try { // eslint-disable-line no-useless-catch\n      super(code\x2C\n            filename\x2C\n            lineOffset\x2C\n            columnOffset\x2C\n            cachedData\x2C\n            produceCachedData\x2C\n            parsingContext);\n    } catch (e) {\n      throw e; /* node-do-not-add-exception-line */\n    }\n\n    if (importModuleDynamically !== undefined) {\n      validateFunction(importModuleDynamically\x2C\n                       'options.importModuleDynamically');\n      const { importModuleDynamicallyWrap } =\n        require('internal/vm/module');\n      const { callbackMap } = internalBinding('module_wrap');\n      callbackMap.set(this\x2C {\n        importModuleDynamically:\n          importModuleDynamicallyWrap(importModuleDynamically)\x2C\n      });\n    }\n  }\n\n  runInThisContext(options) {\n    const { breakOnSigint\x2C args } = getRunInContextArgs(options);\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInThisContext\x2C this\x2C args);\n    }\n    return ReflectApply(super.runInThisContext\x2C this\x2C args);\n  }\n\n  runInContext(contextifiedObject\x2C options) {\n    validateContext(contextifiedObject);\n    const { breakOnSigint\x2C args } = getRunInContextArgs(options);\n    ArrayPrototypeUnshift(args\x2C contextifiedObject);\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInContext\x2C this\x2C args);\n    }\n    return ReflectApply(super.runInContext\x2C this\x2C args);\n  }\n\n  runInNewContext(contextObject\x2C options) {\n    const context = createContext(contextObject\x2C getContextOptions(options));\n    return this.runInContext(context\x2C options);\n  }\n}\n\nfunction validateContext(contextifiedObject) {\n  if (!isContext(contextifiedObject)) {\n    throw new ERR_INVALID_ARG_TYPE('contextifiedObject'\x2C 'vm.Context'\x2C\n                                   contextifiedObject);\n  }\n}\n\nfunction getRunInContextArgs(options = {}) {\n  validateObject(options\x2C 'options');\n\n  let timeout = options.timeout;\n  if (timeout === undefined) {\n    timeout = -1;\n  } else {\n    validateUint32(timeout\x2C 'options.timeout'\x2C true);\n  }\n\n  const {\n    displayErrors = true\x2C\n    breakOnSigint = false\x2C\n    [kVmBreakFirstLineSymbol]: breakFirstLine = false\x2C\n  } = options;\n\n  validateBoolean(displayErrors\x2C 'options.displayErrors');\n  validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n\n  return {\n    breakOnSigint\x2C\n    args: [timeout\x2C displayErrors\x2C breakOnSigint\x2C breakFirstLine]\n  };\n}\n\nfunction getContextOptions(options) {\n  if (!options)\n    return {};\n  const contextOptions = {\n    name: options.contextName\x2C\n    origin: options.contextOrigin\x2C\n    codeGeneration: undefined\x2C\n    microtaskMode: options.microtaskMode\x2C\n  };\n  if (contextOptions.name !== undefined)\n    validateString(contextOptions.name\x2C 'options.contextName');\n  if (contextOptions.origin !== undefined)\n    validateString(contextOptions.origin\x2C 'options.contextOrigin');\n  if (options.contextCodeGeneration !== undefined) {\n    validateObject(options.contextCodeGeneration\x2C\n                   'options.contextCodeGeneration');\n    const { strings\x2C wasm } = options.contextCodeGeneration;\n    if (strings !== undefined)\n      validateBoolean(strings\x2C 'options.contextCodeGeneration.strings');\n    if (wasm !== undefined)\n      validateBoolean(wasm\x2C 'options.contextCodeGeneration.wasm');\n    contextOptions.codeGeneration = { strings\x2C wasm };\n  }\n  if (options.microtaskMode !== undefined)\n    validateString(options.microtaskMode\x2C 'options.microtaskMode');\n  return contextOptions;\n}\n\nfunction isContext(object) {\n  validateObject(object\x2C 'object'\x2C { allowArray: true });\n\n  return _isContext(object);\n}\n\nlet defaultContextNameIndex = 1;\nfunction createContext(contextObject = {}\x2C options = {}) {\n  if (isContext(contextObject)) {\n    return contextObject;\n  }\n\n  validateObject(options\x2C 'options');\n\n  const {\n    name = `VM Context ${defaultContextNameIndex++}`\x2C\n    origin\x2C\n    codeGeneration\x2C\n    microtaskMode\n  } = options;\n\n  validateString(name\x2C 'options.name');\n  if (origin !== undefined)\n    validateString(origin\x2C 'options.origin');\n  if (codeGeneration !== undefined)\n    validateObject(codeGeneration\x2C 'options.codeGeneration');\n\n  let strings = true;\n  let wasm = true;\n  if (codeGeneration !== undefined) {\n    ({ strings = true\x2C wasm = true } = codeGeneration);\n    validateBoolean(strings\x2C 'options.codeGeneration.strings');\n    validateBoolean(wasm\x2C 'options.codeGeneration.wasm');\n  }\n\n  let microtaskQueue = null;\n  if (microtaskMode !== undefined) {\n    validateOneOf(microtaskMode\x2C 'options.microtaskMode'\x2C\n                  ['afterEvaluate'\x2C undefined]);\n\n    if (microtaskMode === 'afterEvaluate')\n      microtaskQueue = new MicrotaskQueue();\n  }\n\n  makeContext(contextObject\x2C name\x2C origin\x2C strings\x2C wasm\x2C microtaskQueue);\n  return contextObject;\n}\n\nfunction createScript(code\x2C options) {\n  return new Script(code\x2C options);\n}\n\n// Remove all SIGINT listeners and re-attach them after the wrapped function\n// has executed\x2C so that caught SIGINT are handled by the listeners again.\nfunction sigintHandlersWrap(fn\x2C thisArg\x2C argsArray) {\n  const sigintListeners = process.rawListeners('SIGINT');\n\n  process.removeAllListeners('SIGINT');\n\n  try {\n    return ReflectApply(fn\x2C thisArg\x2C argsArray);\n  } finally {\n    // Add using the public methods so that the `newListener` handler of\n    // process can re-attach the listeners.\n    ArrayPrototypeForEach(sigintListeners\x2C (listener) => {\n      process.addListener('SIGINT'\x2C listener);\n    });\n  }\n}\n\nfunction runInContext(code\x2C contextifiedObject\x2C options) {\n  validateContext(contextifiedObject);\n  if (typeof options === 'string') {\n    options = {\n      filename: options\x2C\n      [kParsingContext]: contextifiedObject\n    };\n  } else {\n    options = { ...options\x2C [kParsingContext]: contextifiedObject };\n  }\n  return createScript(code\x2C options)\n    .runInContext(contextifiedObject\x2C options);\n}\n\nfunction runInNewContext(code\x2C contextObject\x2C options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  contextObject = createContext(contextObject\x2C getContextOptions(options));\n  options = { ...options\x2C [kParsingContext]: contextObject };\n  return createScript(code\x2C options).runInNewContext(contextObject\x2C options);\n}\n\nfunction runInThisContext(code\x2C options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  return createScript(code\x2C options).runInThisContext(options);\n}\n\nfunction compileFunction(code\x2C params\x2C options = {}) {\n  validateString(code\x2C 'code');\n  if (params !== undefined) {\n    validateArray(params\x2C 'params');\n    ArrayPrototypeForEach(params\x2C\n                          (param\x2C i) => validateString(param\x2C `params[${i}]`));\n  }\n\n  const {\n    filename = ''\x2C\n    columnOffset = 0\x2C\n    lineOffset = 0\x2C\n    cachedData = undefined\x2C\n    produceCachedData = false\x2C\n    parsingContext = undefined\x2C\n    contextExtensions = []\x2C\n    importModuleDynamically\x2C\n  } = options;\n\n  validateString(filename\x2C 'options.filename');\n  validateUint32(columnOffset\x2C 'options.columnOffset');\n  validateUint32(lineOffset\x2C 'options.lineOffset');\n  if (cachedData !== undefined)\n    validateBuffer(cachedData\x2C 'options.cachedData');\n  validateBoolean(produceCachedData\x2C 'options.produceCachedData');\n  if (parsingContext !== undefined) {\n    if (\n      typeof parsingContext !== 'object' ||\n      parsingContext === null ||\n      !isContext(parsingContext)\n    ) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.parsingContext'\x2C\n        'Context'\x2C\n        parsingContext\n      );\n    }\n  }\n  validateArray(contextExtensions\x2C 'options.contextExtensions');\n  ArrayPrototypeForEach(contextExtensions\x2C (extension\x2C i) => {\n    const name = `options.contextExtensions[${i}]`;\n    validateObject(extension\x2C name\x2C { nullable: true });\n  });\n\n  const result = _compileFunction(\n    code\x2C\n    filename\x2C\n    lineOffset\x2C\n    columnOffset\x2C\n    cachedData\x2C\n    produceCachedData\x2C\n    parsingContext\x2C\n    contextExtensions\x2C\n    params\n  );\n\n  if (produceCachedData) {\n    result.function.cachedDataProduced = result.cachedDataProduced;\n  }\n\n  if (result.cachedData) {\n    result.function.cachedData = result.cachedData;\n  }\n\n  if (importModuleDynamically !== undefined) {\n    validateFunction(importModuleDynamically\x2C\n                     'options.importModuleDynamically');\n    const { importModuleDynamicallyWrap } =\n      require('internal/vm/module');\n    const { callbackMap } = internalBinding('module_wrap');\n    const wrapped = importModuleDynamicallyWrap(importModuleDynamically);\n    const func = result.function;\n    callbackMap.set(result.cacheKey\x2C {\n      importModuleDynamically: (s\x2C _k\x2C i) => wrapped(s\x2C func\x2C i)\x2C\n    });\n  }\n\n  return result.function;\n}\n\nconst measureMemoryModes = {\n  summary: constants.measureMemory.mode.SUMMARY\x2C\n  detailed: constants.measureMemory.mode.DETAILED\x2C\n};\n\nconst measureMemoryExecutions = {\n  default: constants.measureMemory.execution.DEFAULT\x2C\n  eager: constants.measureMemory.execution.EAGER\x2C\n};\n\nfunction measureMemory(options = {}) {\n  emitExperimentalWarning('vm.measureMemory');\n  validateObject(options\x2C 'options');\n  const { mode = 'summary'\x2C execution = 'default' } = options;\n  validateOneOf(mode\x2C 'options.mode'\x2C ['summary'\x2C 'detailed']);\n  validateOneOf(execution\x2C 'options.execution'\x2C ['default'\x2C 'eager']);\n  const result = _measureMemory(measureMemoryModes[mode]\x2C\n                                measureMemoryExecutions[execution]);\n  if (result === undefined) {\n    return PromiseReject(new ERR_CONTEXT_NOT_INITIALIZED());\n  }\n  return result;\n}\n\nmodule.exports = {\n  Script\x2C\n  createContext\x2C\n  createScript\x2C\n  runInContext\x2C\n  runInNewContext\x2C\n  runInThisContext\x2C\n  isContext\x2C\n  compileFunction\x2C\n  measureMemory\x2C\n};\n\n// The vm module is patched to include vm.Module\x2C vm.SourceTextModule\n// and vm.SyntheticModule in the pre-execution phase when\n// --experimental-vm-modules is on.\n
code-source-info,0x1eea8f627c76,85,9562,11817,C10O9562C16O9595C25O9595C30O9627C34O9659C43O9659C48O9696C53O9718C59O9696C64O9825C76O9844C84O9866C92O9886C100O9914C108O9945C116O9977C125O10005C130O10048C139O10048C144O10096C153O10096C158O10152C167O10152C172O10204C176O10238C185O10238C190O10290C199O10290C204O10357C208O10397C221O10486C227O10526C244O10532C249O10526C250O10655C259O10655C264O10720C269O10742C275O10720C280O10914C312O10914C318O11091C322O11127C327O11164C331O11155C335O11202C341O11227C346O11256C350O11247C354O11275C358O11303C368O11324C379O11324C384O11473C393O11473C398O11435C403O11532C412O11532C417O11516C422O11584C426O11584C428O11662C432O11655C434O11688C439O11699C451O11742C459O11688C467O11806C471O11815,,
tick,0x10e98ed37,145915,0,0x0,3,0x10f0ac650,0x1eea8f6274df,0x1eea8f625e1d,0x1eea8f622443,0x1eea8f621626,0x1eea8f61e677,0x1eea8f60fa37,0x1eea4787e261
code-creation,LazyCompile,10,145948,0x1eea8f628dde,27, node:vm:313:27,0x1eea8f627948,~
code-source-info,0x1eea8f628dde,85,9752,9803,C0O9766C10O9798C21O9766C26O9803,,
code-creation,LazyCompile,10,146006,0x1eea8f628f6e,149, node:internal/validators:100:40,0x1eea1f7d9ea8,~
code-source-info,0x1eea8f628f6e,17,2861,3371,C0O2892C3O2897C9O2920C15O2959C31O2965C36O2959C37O3024C42O3029C48O3061C64O3067C69O3061C70O3138C80O3190C90O3229C109O3196C114O3190C115O3266C120O3288C125O3301C141O3307C146O3301C148O3370,,
code-creation,Eval,10,146418,0x1eea8f629256,5, /Users/silvia/Desktop/NMAStudio/.run/index.js:1:1,0x1eea8f629110,~
script-source,115,/Users/silvia/Desktop/NMAStudio/.run/index.js,
code-source-info,0x1eea8f629256,115,0,0,C0O0C4O0,,
code-creation,Function,10,146457,0x1eea8f6292be,2, /Users/silvia/Desktop/NMAStudio/.run/index.js:1:1,0x1eea8f6291d0,~
code-source-info,0x1eea8f6292be,115,0,0,C1O0,,
code-creation,LazyCompile,10,146576,0x1eea8f62949e,19,importModuleDynamicallyWrap node:internal/vm/module:435:37,0x1eea8f606b70,~
code-source-info,0x1eea8f62949e,113,11705,12148,C0O11705C13O11774C18O12146,,
tick,0x7fff2042c000,146625,0,0x0,3,0x10f0ac650,0x1eea8f627e1c,0x1eea8f6274df,0x1eea8f625e1d,0x1eea8f622443,0x1eea8f621626,0x1eea8f61e677,0x1eea8f60fa37,0x1eea4787e261
code-creation,LazyCompile,10,146681,0x1eea8f62a676,159,makeRequireFunction node:internal/modules/cjs/helpers:58:29,0x1eea2da99b80,~
code-source-info,0x1eea8f62a676,98,1708,3678,C0O1708C22O1744C25O1748C29O1744C31O1768C33O1779C53O1811C58O1815C69O1831C73O1811C75O1858C81O1858C83O1885C89O1894C95O1922C104O3082C109O3313C111O3329C115O3469C117O3483C121O3495C126O3518C130O3508C134O3583C137O3611C141O3602C145O3627C148O3650C152O3641C156O3661C158O3676,,
profiler,end
delete,MemoryChunk,0x1eeab58c0000
delete,MemoryChunk,0x1eea1f7c0000
delete,MemoryChunk,0x1eeac2040000
delete,MemoryChunk,0x1eea56100000
delete,MemoryChunk,0x1eeaaa640000
delete,MemoryChunk,0x1eea35d00000
delete,MemoryChunk,0x1eea54280000
delete,MemoryChunk,0x1eea11d80000
delete,MemoryChunk,0x1eea3b180000
delete,MemoryChunk,0x1eea47840000
delete,MemoryChunk,0x1eea2da80000
delete,MemoryChunk,0x1eea8f600000
delete,MemoryChunk,0x11b6c0000
delete,MemoryChunk,0x11b700000
delete,MemoryChunk,0x1eea5b640000
delete,MemoryChunk,0x1eeafbf00000
delete,MemoryChunk,0x1eea86fc0000
delete,MemoryChunk,0x1eeaf2980000
delete,MemoryChunk,0x1eea9c500000
delete,MemoryChunk,0x1eeacbd80000
delete,MemoryChunk,0x1eea39e40000
